
(function() {
var __main_module_name__ = "main";
var __resources__ = {};
function __imageResource(data) { var img = new Image(); img.src = data; return img; };
var FLIP_Y_AXIS = true;
var ENABLE_WEB_GL = false;
var SHOW_REDRAW_REGIONS = false;

__resources__["/__builtin__/event.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*global module exports require*/
/*jslint white: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true*/


/**
 * @namespace
 * Support for listening for and triggering events
 */
var event = {};

/**
 * @private
 * @ignore
 * Returns the event listener property of an object, creating it if it doesn't
 * already exist.
 *
 * @returns {Object}
 */
function getListeners(obj, eventName) {
    if (!obj.js_listeners_) {
        obj.js_listeners_ = {};
    }
    if (!eventName) {
        return obj.js_listeners_;
    }
    if (!obj.js_listeners_[eventName]) {
        obj.js_listeners_[eventName] = {};
    }
    return obj.js_listeners_[eventName];
}

/**
 * @private
 * @ignore
 * Keep track of the next ID for each new EventListener
 */
var eventID = 0;

/**
 * @class
 * Represents an event being listened to. You should not create instances of
 * this directly, it is instead returned by event.addListener
 *
 * @extends Object
 * 
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 */
event.EventListener = function (source, eventName, handler) {
    /**
     * Object to listen to for an event
     * @type Object 
     */
    this.source = source;
    
    /**
     * Name of the event to listen for
     * @type String
     */
    this.eventName = eventName;

    /**
     * Callback to fire when the event triggers
     * @type Function
     */
    this.handler = handler;

    /**
     * Unique ID number for this instance
     * @type Integer 
     */
    this.id = ++eventID;

    getListeners(source, eventName)[this.id] = this;
};

/**
 * Register an event listener
 *
 * @param {Object} source Object to listen to for an event
 * @param {String} eventName Name of the event to listen for
 * @param {Function} handler Callback to fire when the event triggers
 *
 * @returns {event.EventListener} The event listener. Pass to removeListener to destroy it.
 */
event.addListener = function (source, eventName, handler) {
    return new event.EventListener(source, eventName, handler);
};

/**
 * Trigger an event. All listeners will be notified.
 *
 * @param {Object} source Object to trigger the event on
 * @param {String} eventName Name of the event to trigger
 */
event.trigger = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        args = Array.prototype.slice.call(arguments, 2),
        eventID,
        l;

    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            l = listeners[eventID];
            if (l) {
                l.handler.apply(undefined, args);
            }
        }
    }
};

/**
 * Remove a previously registered event listener
 *
 * @param {event.EventListener} listener EventListener to remove, as returned by event.addListener
 */
event.removeListener = function (listener) {
    delete getListeners(listener.source, listener.eventName)[listener.eventID];
};

/**
 * Remove a all event listeners for a given event
 *
 * @param {Object} source Object to remove listeners from
 * @param {String} eventName Name of event to remove listeners from
 */
event.clearListeners = function (source, eventName) {
    var listeners = getListeners(source, eventName),
        eventID;


    for (eventID in listeners) {
        if (listeners.hasOwnProperty(eventID)) {
            var l = listeners[eventID];
            if (l) {
                event.removeListener(l);
            }
        }
    }
};

/**
 * Remove all event listeners on an object
 *
 * @param {Object} source Object to remove listeners from
 */
event.clearInstanceListeners = function (source, eventName) {
    var listeners = getListeners(source),
        eventID;

    for (eventName in listeners) {
        if (listeners.hasOwnProperty(eventName)) {
            var el = listeners[eventName];
            for (eventID in el) {
                if (el.hasOwnProperty(eventID)) {
                    var l = el[eventID];
                    if (l) {
                        event.removeListener(l);
                    }
                }
            }
        }
    }
};

module.exports = event;

}};
__resources__["/__builtin__/global.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event');


/**
 * @ignore
 */
function getAccessors(obj) {
    if (!obj.js_accessors_) {
        obj.js_accessors_ = {};
    }
    return obj.js_accessors_;
}

/**
 * @ignore
 */
function getBindings(obj) {
    if (!obj.js_bindings_) {
        obj.js_bindings_ = {};
    }
    return obj.js_bindings_;
}

/**
 * @ignore
 */
function addAccessor(obj, key, target, targetKey, noNotify) {
    getAccessors(obj)[key] = {
        key: targetKey,
        target: target
    };

    if (!noNotify) {
        obj.triggerChanged(key);
    }
}


/**
 * @ignore
 */
var objectID = 0;

/**
 * @class
 * A bindable object. Allows observing and binding to its properties.
 */
var BObject = function () {};
BObject.prototype = util.extend(BObject.prototype, /** @lends BObject# */{
    /**
     * Unique ID
     * @type Integer
     */
    _id: 0,
    

    /**
     * The constructor for subclasses. Overwrite this for any initalisation you
     * need to do.
     * @ignore
     */
    init: function () {},

    /**
     * Get a property from the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @returns {*} Value of the property
     */
    get: function (key) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            return accessor.target.get(accessor.key);
        } else {
            // Call getting function
            if (this['get_' + key]) {
                return this['get_' + key]();
            }

            return this[key];
        }
    },


    /**
     * Set a property on the object. Always use this instead of trying to
     * access the property directly. This will ensure all bindings, setters and
     * getters work correctly.
     * 
     * @param {String} key Name of property to get
     * @param {*} value New value for the property
     */
    set: function (key, value) {
        var accessor = getAccessors(this)[key],
            oldVal = this.get(key);
        if (accessor) {
            accessor.target.set(accessor.key, value);
        } else {
            if (this['set_' + key]) {
                this['set_' + key](value);
            } else {
                this[key] = value;
            }
        }
        this.triggerChanged(key, oldVal);
    },

    /**
     * Set multiple propertys in one go
     *
     * @param {Object} kvp An Object where the key is a property name and the value is the value to assign to the property
     *
     * @example
     * var props = {
     *   monkey: 'ook',
     *   cat: 'meow',
     *   dog: 'woof'
     * };
     * foo.setValues(props);
     * console.log(foo.get('cat')); // Logs 'meow'
     */
    setValues: function (kvp) {
        for (var x in kvp) {
            if (kvp.hasOwnProperty(x)) {
                this.set(x, kvp[x]);
            }
        }
    },

    changed: function (key) {
    },

    /**
     * @private
     */
    notify: function (key, oldVal) {
        var accessor = getAccessors(this)[key];
        if (accessor) {
            accessor.target.notify(accessor.key, oldVal);
        }
    },

    /**
     * @private
     */
    triggerChanged: function(key, oldVal) {
        evt.trigger(this, key.toLowerCase() + '_changed', oldVal);
    },

    /**
     * Bind the value of a property on this object to that of another object so
     * they always have the same value. Setting the value on either object will update
     * the other too.
     *
     * @param {String} key Name of the property on this object that should be bound
     * @param {BOject} target Object to bind to
     * @param {String} [targetKey=key] Key on the target object to bind to
     * @param {Boolean} [noNotify=false] Set to true to prevent this object's property triggering a 'changed' event when adding the binding
     */
    bindTo: function (key, target, targetKey, noNotify) {
        targetKey = targetKey || key;
        var self = this;
        this.unbind(key);

        var oldVal = this.get(key);

        // When bound property changes, trigger a 'changed' event on this one too
        getBindings(this)[key] = evt.addListener(target, targetKey.toLowerCase() + '_changed', function (oldVal) {
            self.triggerChanged(key, oldVal);
        });

        addAccessor(this, key, target, targetKey, noNotify);
    },

    /**
     * Remove binding from a property which set setup using BObject#bindTo.
     *
     * @param {String} key Name of the property on this object to unbind
     */
    unbind: function (key) {
        var binding = getBindings(this)[key];
        if (!binding) {
            return;
        }

        delete getBindings(this)[key];
        evt.removeListener(binding);
        // Grab current value from bound property
        var val = this.get(key);
        delete getAccessors(this)[key];
        // Set bound value
        this[key] = val;
    },

    /**
     * Remove all bindings on this object
     */
    unbindAll: function () {
        var keys = [],
            bindings = getBindings(this);
        for (var k in bindings) {
            if (bindings.hasOwnProperty(k)) {
                this.unbind(k);
            }
        }
    },

    /**
     * Unique ID for this object
     * @getter id
     * @type Integer
     */
    get_id: function() {
        if (!this._id) {
            this._id = ++objectID;
        }

        return this._id;
    }
});


/**
 * Create a new instance of this object
 * @returns {BObject} New instance of this object
 */
BObject.create = function() {
    var ret = new this();
    ret.init.apply(ret, arguments);
    return ret;
};

/**
 * Create a new subclass by extending this one
 * @returns {Object} A new subclass of this object
 */
BObject.extend = function() {
    var newObj = function() {},
        args = [],
        i,
        x;

    // Copy 'class' methods
    for (x in this) {
        if (this.hasOwnProperty(x)) {
            newObj[x] = this[x];
        }
    }


    // Add given properties to the prototype
    newObj.prototype = util.beget(this.prototype);
    args.push(newObj.prototype);
    for (i = 0; i<arguments.length; i++) {
        args.push(arguments[i]);
    }
    util.extend.apply(null, args);

    newObj.superclass = this.prototype;
    // Create new instance
    return newObj;
};

/**
 * Get a property from the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @returns {*} Value of the property
 */
BObject.get = BObject.prototype.get;

/**
 * Set a property on the class. Always use this instead of trying to
 * access the property directly. This will ensure all bindings, setters and
 * getters work correctly.
 * 
 * @function
 * @param {String} key Name of property to get
 * @param {*} value New value for the property
 */
BObject.set = BObject.prototype.set;

var BArray = BObject.extend(/** @lends BArray# */{

    /**
     * @constructs 
     * A bindable array. Allows observing for changes made to its contents
     *
     * @extends BObject
     * @param {Array} [array=[]] A normal JS array to use for data
     */
    init: function (array) {
        this.array = array || [];
        this.set('length', this.array.length);
    },

    /**
     * Get an item
     *
     * @param {Integer} i Index to get item from
     * @returns {*} Value stored in the array at index 'i'
     */
    getAt: function (i) {
        return this.array[i];
    },

    /**
     * Set an item -- Overwrites any existing item at index
     *
     * @param {Integer} i Index to set item to
     * @param {*} value Value to assign to index
     */
    setAt: function (i, value) {
        var oldVal = this.array[i];
        this.array[i] = value;

        evt.trigger(this, 'set_at', i, oldVal);
    },

    /**
     * Insert a new item into the array without overwriting anything
     *
     * @param {Integer} i Index to insert item at
     * @param {*} value Value to insert
     */
    insertAt: function (i, value) {
        this.array.splice(i, 0, value);
        this.set('length', this.array.length);
        evt.trigger(this, 'insert_at', i);
    },

    /**
     * Remove item from the array and return it
     *
     * @param {Integer} i Index to remove
     * @returns {*} Value that was removed
     */
    removeAt: function (i) {
        var oldVal = this.array[i];
        this.array.splice(i, 1);
        this.set('length', this.array.length);
        evt.trigger(this, 'remove_at', i, oldVal);

        return oldVal;
    },

    /**
     * Get the internal Javascript Array instance
     *
     * @returns {Array} Internal Javascript Array
     */
    getArray: function () {
        return this.array;
    },

    /**
     * Append a value to the end of the array and return its new length
     *
     * @param {*} value Value to append to the array
     * @returns {Integer} New length of the array
     */
    push: function (value) {
        this.insertAt(this.array.length, value);
        return this.array.length;
    },

    /**
     * Remove value from the end of the array and return it
     *
     * @returns {*} Value that was removed
     */
    pop: function () {
        return this.removeAt(this.array.length - 1);
    }
});

exports.BObject = BObject;
exports.BArray = BArray;

}};
__resources__["/__builtin__/libs/base64.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * Thin wrapper around JXG's Base64 utils
 */

/** @ignore */
var JXG = require('JXGUtil');

/** @namespace */
var base64 = {
    /**
     * Decode a base64 encoded string into a binary string
     *
     * @param {String} input Base64 encoded data
     * @returns {String} Binary string
     */
    decode: function(input) {
        return JXG.Util.Base64.decode(input);
    },

    /**
     * Decode a base64 encoded string into a byte array
     *
     * @param {String} input Base64 encoded data
     * @returns {Integer[]} Array of bytes
     */
    decodeAsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = JXG.Util.Base64.decode(input),
            ar = [], i, j, len;

        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Encode a binary string into base64
     *
     * @param {String} input Binary string
     * @returns {String} Base64 encoded data
     */
    encode: function(input) {
        return JXG.Util.Base64.encode(input);
    }
};

module.exports = base64;

}};
__resources__["/__builtin__/libs/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_ropeJoint:
      joint = new b2RopeJoint(def);
      break;
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_ropeJoint= 10;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;

var b2RopeJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments);
};
extend(b2RopeJoint.prototype, b2Joint.prototype);
b2RopeJoint.prototype._super = b2Joint.prototype;
b2RopeJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_length = 0;
  this.m_maxLength = def.maxLength;
  this.m_mass = 0;
  this.m_impulse = 0;
  this.m_state = b2Joint.e_inactiveLimit;
};
b2RopeJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_u = new b2Vec2;
  this.m_rA = new b2Vec2;
  this.m_rB = new b2Vec2;
};
b2RopeJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  
  this.m_rA.x = r1X;
  this.m_rA.y = r1Y;
  this.m_rB.x = r2X;
  this.m_rB.y = r2Y;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(this.m_length > this.m_maxLength) {
	  this.m_state = b2Joint.e_atUpperLimit;
  }else {
	  this.m_state = b2Joint.e_inactiveLimit;
  }
  if(this.m_length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / this.m_length);
  }else {
	  this.m_u.SetZero();
	  this.m_mass = 0;
	  this.m_impulse = 0;
	  return;
  }
  
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
  }else {
    this.m_impulse = 0;
  }
};
b2RopeJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * this.m_rA.y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * this.m_rA.x;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * this.m_rB.y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * this.m_rB.x;
  
  var C = this.m_length - this.m_maxLength;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
//Predictive constraint.
  if (C < 0) {
	  Cdot += step.inv_dt * C;
  }
  var impulse = -this.m_mass * Cdot;
  var oldImpulse = this.m_impulse;
  this.m_impulse = (this.m_impulse + impulse <0) ? this.m_impulse + impulse : 0;
  impulse = this.m_impulse - oldImpulse;
  
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (this.m_rA.x * PY - this.m_rA.y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (this.m_rB.x * PY - this.m_rB.y * PX);
};
b2RopeJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_maxLength;
  C = b2Math.Clamp(C, 0, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return length - this.m_maxLength < b2Settings.b2_linearSlop; 
};
b2RopeJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
};
b2RopeJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
};
b2RopeJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
};
b2RopeJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0;
};
b2RopeJoint.prototype.GetMaxLength = function() {
  return this.m_maxLength;
};
b2RopeJoint.prototype.m_localAnchorA = new b2Vec2;
b2RopeJoint.prototype.m_localAnchorB = new b2Vec2;
b2RopeJoint.prototype.m_u = new b2Vec2;
b2RopeJoint.prototype.m_impulse = null;
b2RopeJoint.prototype.m_mass = null;
b2RopeJoint.prototype.m_length = null;

var b2RopeJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments);
};
extend(b2RopeJointDef.prototype, b2JointDef.prototype);
b2RopeJointDef.prototype._super = b2JointDef.prototype;
b2RopeJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_ropeJoint;
  this.maxLength = 0;
};
b2RopeJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2(-1,0);
  this.localAnchorB = new b2Vec2(1, 0);
};
b2RopeJointDef.prototype.localAnchorA = new b2Vec2;
b2RopeJointDef.prototype.localAnchorB = new b2Vec2;
b2RopeJointDef.prototype.maxLength = null;


var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
    case b2Joint.e_ropeJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2RopeJoint = b2RopeJoint;
  exports.b2RopeJointDef = b2RopeJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/__builtin__/libs/cocos2d/ActionManager.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Timer = require('./Scheduler').Timer,
    Scheduler = require('./Scheduler').Scheduler;

var ActionManager = BObject.extend(/** @lends cocos.ActionManager# */{
    targets: null,
    currentTarget: null,
    currentTargetSalvaged: null,

    /**
     * <p>A singleton that manages all the actions. Normally you
     * won't need to use this singleton directly. 99% of the cases you will use the
     * cocos.nodes.Node interface, which uses this singleton. But there are some cases where
     * you might need to use this singleton. Examples:</p>
     *
     * <ul>
     * <li>When you want to run an action where the target is different from a cocos.nodes.Node</li>
     * <li>When you want to pause / resume the actions</li>
     * </ul>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        ActionManager.superclass.init.call(this);

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: 0, paused: false});
        this.targets = [];
    },

    /**
     * Adds an action with a target. If the target is already present, then the
     * action will be added to the existing target. If the target is not
     * present, a new instance of this target will be created either paused or
     * paused, and the action will be added to the newly created target. When
     * the target is paused, the queued actions won't be 'ticked'.
     *
     * @opt {cocos.nodes.Node} target Node to run the action on
     */
    addAction: function (opts) {

        var targetID = opts.target.get('id');
        var element = this.targets[targetID];

        if (!element) {
            element = this.targets[targetID] = {
                paused: false,
                target: opts.target,
                actions: []
            };
        }

        element.actions.push(opts.action);

        opts.action.startWithTarget(opts.target);
    },

    /**
     * Remove an action
     *
     * @param {cocos.actions.Action} action Action to remove
     */
    removeAction: function (action) {
        var targetID = action.originalTarget.get('id'),
            element = this.targets[targetID];

        if (!element) {
            return;
        }

        var actionIndex = element.actions.indexOf(action);

        if (actionIndex == -1) {
            return;
        }

        if (this.currentTarget == element) {
            element.currentActionSalvaged = true;
        } 
        
        element.actions[actionIndex] = null;
        element.actions.splice(actionIndex, 1); // Delete array item

        if (element.actions.length === 0) {
            if (this.currentTarget == element) {
                this.set('currentTargetSalvaged', true);
            }
        }
            
    },

    /**
     * Remove all actions for a cocos.nodes.Node
     *
     * @param {cocos.nodes.Node} target Node to remove all actions for
     */
    removeAllActionsFromTarget: function (target) {
        var targetID = target.get('id');

        var element = this.targets[targetID];
        if (!element) {
            return;
        }

        // Delete everything in array but don't replace it incase something else has a reference
        element.actions.splice(0, element.actions.length - 1);
    },

    /**
     * @private
     */
    update: function (dt) {
        var self = this;
        util.each(this.targets, function (currentTarget, i) {

            if (!currentTarget) {
                return;
            }
            self.currentTarget = currentTarget;

            if (!currentTarget.paused) {
                util.each(currentTarget.actions, function (currentAction, j) {
                    if (!currentAction) {
                        return;
                    }

                    currentTarget.currentAction = currentAction;
                    currentTarget.currentActionSalvaged = false;

                    currentTarget.currentAction.step(dt);

                    if (currentTarget.currentAction.get('isDone')) {
                        currentTarget.currentAction.stop();

                        var a = currentTarget.currentAction;
                        currentTarget.currentAction = null;
                        self.removeAction(a);
                    }

                    currentTarget.currentAction = null;

                });
            }

            if (self.currentTargetSalvaged && currentTarget.actions.length === 0) {
                self.targets[i] = null;
                delete self.targets[i];
            }
        });
    },

    pauseTarget: function (target) {
    },

	resumeTarget: function (target) {
		// TODO
	}
});

util.extend(ActionManager, /** @lends cocos.ActionManager */{
    /**
     * Singleton instance of cocos.ActionManager
     * @getter sharedManager
     * @type cocos.ActionManager
     */
    get_sharedManager: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.ActionManager = ActionManager;

}};
__resources__["/__builtin__/libs/cocos2d/actions/Action.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console;

/** 
 * @memberOf cocos.actions
 * @class Base class for Actions
 * @extends BObject
 * @constructor
 */
var Action = BObject.extend(/** @lends cocos.actions.Action# */{
    /**
     * The Node the action is being performed on
     * @type cocos.nodes.Node
     */
    target: null,
    originalTarget: null,

    /**
     * Called every frame with it's delta time.
     *
     * @param {Float} dt The delta time
     */
    step: function (dt) {
        console.log('Action.step() Override me');
    },

    /**
     * Called once per frame.
     *
     * @param {Float} time How much of the animation has played. 0.0 = just started, 1.0 just finished.
     */
    update: function (time) {
        console.log('Action.update() Override me');
    },

    /**
     * Called before the action start. It will also set the target.
     *
     * @param {cocos.nodes.Node} target The Node to run the action on
     */
    startWithTarget: function (target) {
        this.target = this.originalTarget = target;
    },

    /**
     * Called after the action has finished. It will set the 'target' to nil.
     * <strong>Important</strong>: You should never call cocos.actions.Action#stop manually.
     * Instead, use cocos.nodes.Node#stopAction(action)
     */
    stop: function () {
        this.target = null;
    },

    /**
     * @getter isDone
     * @type {Boolean} 
     */
    get_isDone: function (key) {
        return true;
    },


    /**
     * Returns a copy of this Action but in reverse
     *
     * @returns {cocos.actions.Action} A new Action in reverse
     */
    reverse: function () {
    }
});

var RepeatForever = Action.extend(/** @lends cocos.actions.RepeatForever# */{
    other: null,

    /**
     * @memberOf cocos.actions
     * @class Repeats an action forever. To repeat the an action for a limited
     * number of times use the cocos.Repeat action.
     * @extends cocos.actions.Action
     * @param {cocos.actions.Action} action An action to repeat forever
     * @constructs
     */
    init: function (action) {
        RepeatForever.superclass.init(this, action);

        this.other = action;
    },

    startWithTarget: function (target) {
        RepeatForever.superclass.startWithTarget.call(this, target);

        this.other.startWithTarget(this.target);
    },

    step: function (dt) {
        this.other.step(dt);
        if (this.other.get('isDone')) {
            var diff = dt - this.other.get('duration') - this.other.get('elapsed');
            this.other.startWithTarget(this.target);

            this.other.step(diff);
        }
    },

    get_isDone: function () {
        return false;
    },

    reverse: function () {
        return RepeatForever.create(this.other.reverse());
    },

    copy: function () {
        return RepeatForever.create(this.other.copy());
    }
});

var FiniteTimeAction = Action.extend(/** @lends cocos.actions.FiniteTimeAction# */{
    /**
     * Number of seconds to run the Action for
     * @type Float
     */
    duration: 2,

    /** 
     * Repeats an action a number of times. To repeat an action forever use the
     * cocos.RepeatForever action.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.Action
     */
    init: function () {
        FiniteTimeAction.superclass.init.call(this);
    },

    /** @ignore */
    reverse: function () {
        console.log('FiniteTimeAction.reverse() Override me');
    }
});

exports.Action = Action;
exports.RepeatForever = RepeatForever;
exports.FiniteTimeAction = FiniteTimeAction;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInstant.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInstant = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInstant */{
    /**
     * @memberOf cocos.actions
     * @class Base class for actions that triggers instantly. They have no duration.
     * @extends cocos.actions.FiniteTimeAction
     * @constructs
     */
    init: function (opts) {
        ActionInstant.superclass.init.call(this, opts);

        this.duration = 0;
    },
    get_isDone: function () {
        return true;
    },
    step: function (dt) {
        this.update(1);
    },
    update: function (t) {
        // ignore
    },
    reverse: function () {
        return this.copy();
    }
});

var FlipX = ActionInstant.extend(/** @lends cocos.actions.FlipX# */{
    flipX: false,

    /**
     * @memberOf cocos.actions
     * @class Flips a sprite horizontally
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipX Should the sprite be flipped
     */
    init: function (opts) {
        FlipX.superclass.init.call(this, opts);

        this.flipX = opts.flipX;
    },
    startWithTarget: function (target) {
        FlipX.superclass.startWithTarget.call(this, target);

        target.set('flipX', this.flipX);
    },
    reverse: function () {
        return FlipX.create({flipX: !this.flipX});
    },
    copy: function () {
        return FlipX.create({flipX: this.flipX});
    }
});

var FlipY = ActionInstant.extend(/** @lends cocos.actions.FlipY# */{
    flipY: false,

    /**
     * @memberOf cocos.actions
     * @class Flips a sprite vertically
     * @extends cocos.actions.ActionInstant
     * @constructs
     *
     * @opt {Boolean} flipY Should the sprite be flipped
     */
    init: function (opts) {
        FlipY.superclass.init.call(this, opts);

        this.flipY = opts.flipY;
    },
    startWithTarget: function (target) {
        FlipY.superclass.startWithTarget.call(this, target);

        target.set('flipY', this.flipY);
    },
    reverse: function () {
        return FlipY.create({flipY: !this.flipY});
    },
    copy: function () {
        return FlipY.create({flipY: this.flipY});
    }
});

exports.ActionInstant = ActionInstant;
exports.FlipX = FlipX;
exports.FlipY = FlipY;

}};
__resources__["/__builtin__/libs/cocos2d/actions/ActionInterval.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    act = require('./Action'),
    ccp = require('geometry').ccp;

var ActionInterval = act.FiniteTimeAction.extend(/** @lends cocos.actions.ActionInterval# */{
    /**
     * Number of seconds that have elapsed
     * @type Float
     */
    elapsed: 0.0,

    _firstTick: true,

    /**
     * Base class actions that do have a finite time duration. 
     *
     * Possible actions:
     *
     * - An action with a duration of 0 seconds
     * - An action with a duration of 35.5 seconds Infinite time actions are valid
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.FiniteTimeAction
     *
     * @opt {Float} duration Number of seconds to run action for
     */
    init: function (opts) {
        ActionInterval.superclass.init.call(this, opts);

        var dur = opts.duration || 0;
        if (dur === 0) {
            dur = 0.0000001;
        }

        this.set('duration', dur);
        this.set('elapsed', 0);
        this._firstTick = true;
    },

    get_isDone: function () {
        return (this.elapsed >= this.duration);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.update(Math.min(1, this.elapsed / this.duration));
    },

    startWithTarget: function (target) {
        ActionInterval.superclass.startWithTarget.call(this, target);

        this.elapsed = 0.0;
        this._firstTick = true;
    },

    reverse: function () {
        throw "Reverse Action not implemented";
    }
});

var ScaleTo = ActionInterval.extend(/** @lends cocos.actions.ScaleTo# */{
    /**
     * Current X Scale
     * @type Float
     */
    scaleX: 1,

    /**
     * Current Y Scale
     * @type Float
     */
    scaleY: 1,

    /**
     * Initial X Scale
     * @type Float
     */
    startScaleX: 1,

    /**
     * Initial Y Scale
     * @type Float
     */
    startScaleY: 1,

    /**
     * Final X Scale
     * @type Float
     */
    endScaleX: 1,

    /**
     * Final Y Scale
     * @type Float
     */
    endScaleY: 1,

    /**
     * Delta X Scale
     * @type Float
     * @private
     */
    deltaX: 0.0,

    /**
     * Delta Y Scale
     * @type Float
     * @private
     */
    deltaY: 0.0,

    /**
     * Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node to
     * @opt {Float} [scaleX] Size to scale width of Node to
     * @opt {Float} [scaleY] Size to scale height of Node to
     */
    init: function (opts) {
        ScaleTo.superclass.init.call(this, opts);

        if (opts.scale !== undefined) {
            this.endScaleX = this.endScaleY = opts.scale;
        } else {
            this.endScaleX = opts.scaleX;
            this.endScaleY = opts.scaleY;
        }


    },

    startWithTarget: function (target) {
        ScaleTo.superclass.startWithTarget.call(this, target);

        this.startScaleX = this.target.get('scaleX');
        this.startScaleY = this.target.get('scaleY');
        this.deltaX = this.endScaleX - this.startScaleX;
        this.deltaY = this.endScaleY - this.startScaleY;
    },

    update: function (t) {
        if (!this.target) {
            return;
        }
        
        this.target.set('scaleX', this.startScaleX + this.deltaX * t);
        this.target.set('scaleY', this.startScaleY + this.deltaY * t);
    }
});

var ScaleBy = ScaleTo.extend(/** @lends cocos.actions.ScaleBy# */{
    /**
     * Scales a cocos.Node object to a zoom factor by modifying it's scale attribute.
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ScaleTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} [scale] Size to scale Node by
     * @opt {Float} [scaleX] Size to scale width of Node by
     * @opt {Float} [scaleY] Size to scale height of Node by
     */
    init: function (opts) {
        ScaleBy.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        ScaleBy.superclass.startWithTarget.call(this, target);

        this.deltaX = this.startScaleX * this.endScaleX - this.startScaleX;
        this.deltaY = this.startScaleY * this.endScaleY - this.startScaleY;
    },

    reverse: function () {
        return ScaleBy.create({duration: this.duration, scaleX: 1 / this.endScaleX, scaleY: 1 / this.endScaleY});
    }
});


var RotateTo = ActionInterval.extend(/** @lends cocos.actions.RotateTo# */{
    /**
     * Final angle
     * @type Float
     */
    dstAngle: 0,

    /**
     * Initial angle
     * @type Float
     */
    startAngle: 0,

    /**
     * Angle delta
     * @type Float
     */
    diffAngle: 0,

    /**
     * Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     * 
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate to
     */
    init: function (opts) {
        RotateTo.superclass.init.call(this, opts);

        this.dstAngle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateTo.superclass.startWithTarget.call(this, target);

        this.startAngle = target.get('rotation');

        if (this.startAngle > 0) {
            this.startAngle = (this.startAngle % 360);
        } else {
            this.startAngle = (this.startAngle % -360);
        }

        this.diffAngle = this.dstAngle - this.startAngle;
        if (this.diffAngle > 180) {
            this.diffAngle -= 360;
        } else if (this.diffAngle < -180) {
            this.diffAngle += 360;
        }
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.diffAngle * t);
    }
});

var RotateBy = RotateTo.extend(/** @lends cocos.actions.RotateBy# */{
    /**
     * Number of degrees to rotate by
     * @type Float
     */
    angle: 0,

    /**
     * Rotates a cocos.Node object to a certain angle by modifying its rotation
     * attribute. The direction will be decided by the shortest angle.
     *
     * @memberOf cocos.action
     * @constructs
     * @extends cocos.actions.RotateTo
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {Float} angle Angle in degrees to rotate by
     */
    init: function (opts) {
        RotateBy.superclass.init.call(this, opts);

        this.angle = opts.angle;
    },

    startWithTarget: function (target) {
        RotateBy.superclass.startWithTarget.call(this, target);

        this.startAngle = this.target.get('rotation');
    },

    update: function (t) {
        this.target.set('rotation', this.startAngle + this.angle * t);
    },

    reverse: function () {
        return RotateBy.create({duration: this.duration, angle: -this.angle});
    },

    copy: function () {
        return RotateBy.create({duration: this.duration, angle: this.angle});
    }
});



var Sequence = ActionInterval.extend(/** @lends cocos.actions.Sequence# */{
    /**
     * Array of actions to run
     * @type cocos.Node[]
     */
    actions: null,

    /**
     * The array index of the currently running action
     * @type Integer
     */
    currentActionIndex: 0,

    /**
     * The duration when the current action finishes
     * @type Float
     */
    currentActionEndDuration: 0,

    /**
     * Runs a number of actions sequentially, one after another
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.actions.Action[]} Array of actions to run in sequence
     */
    init: function (opts) {
        Sequence.superclass.init.call(this, opts);

        this.actions = util.copy(opts.actions);
        this.actionSequence = {};
        
        util.each(this.actions, util.callback(this, function (action) {
            this.duration += action.duration;
        }));
    },

    startWithTarget: function (target) {
        Sequence.superclass.startWithTarget.call(this, target);

        this.currentActionIndex = 0;
        this.currentActionEndDuration = this.actions[0].get('duration');
        this.actions[0].startWithTarget(this.target);
    },

    stop: function () {
        util.each(this.actions, function (action) {
            action.stop();
        });

        Sequence.superclass.stop.call(this);
    },

    step: function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        this.actions[this.currentActionIndex].step(dt);
        this.update(Math.min(1, this.elapsed / this.duration));
    },

    update: function (dt) {
        // Action finished onto the next one
        if (this.elapsed > this.currentActionEndDuration) {
            var previousAction = this.actions[this.currentActionIndex];
            previousAction.update(1.0);
            previousAction.stop();


            this.currentActionIndex++;

            if (this.currentActionIndex < this.actions.length) {
                var currentAction = this.actions[this.currentActionIndex];
                currentAction.startWithTarget(this.target);

                this.currentActionEndDuration += currentAction.duration;
            }
        }
    }
});

var Animate = ActionInterval.extend(/** @lends cocos.actions.Animate# */{
    animation: null,
    restoreOriginalFrame: true,
    origFrame: null,


    /**
     * Animates a sprite given the name of an Animation 
     *
     * @memberOf cocos.actions
     * @constructs
     * @extends cocos.actions.ActionInterval
     *
     * @opt {Float} duration Number of seconds to run action for
     * @opt {cocos.Animation} animation Animation to run
     * @opt {Boolean} [restoreOriginalFrame=true] Return to first frame when finished
     */
    init: function (opts) {
        this.animation = opts.animation;
        this.restoreOriginalFrame = opts.restoreOriginalFrame !== false;
        opts.duration = this.animation.frames.length * this.animation.delay;

        Animate.superclass.init.call(this, opts);
    },

    startWithTarget: function (target) {
        Animate.superclass.startWithTarget.call(this, target);

        if (this.restoreOriginalFrame) {
            this.set('origFrame', this.target.get('displayedFrame'));
        }
    },

    stop: function () {
        if (this.target && this.restoreOriginalFrame) {
            var sprite = this.target;
            sprite.set('displayFrame', this.origFrame);
        }

        Animate.superclass.stop.call(this);
    },

    update: function (t) {
        var frames = this.animation.get('frames'),
            numberOfFrames = frames.length,
            idx = Math.floor(t * numberOfFrames);

        if (idx >= numberOfFrames) {
            idx = numberOfFrames - 1;
        }

        var sprite = this.target;
        if (!sprite.isFrameDisplayed(frames[idx])) {
            sprite.set('displayFrame', frames[idx]);
        }
    },

    copy: function () {
        return Animate.create({animation: this.animation, restoreOriginalFrame: this.restoreOriginalFrame});
    }

});

exports.ActionInterval = ActionInterval;
exports.ScaleTo = ScaleTo;
exports.ScaleBy = ScaleBy;
exports.RotateTo = RotateTo;
exports.RotateBy = RotateBy;
exports.Sequence = Sequence;
exports.Animate = Animate;

}};
__resources__["/__builtin__/libs/cocos2d/actions/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Action ActionInterval ActionInstant'.w();

/**
 * @memberOf cocos
 * @namespace Actions used to animate or change a Node
 */
var actions = {};

util.each(modules, function (mod, i) {
    util.extend(actions, require('./' + mod));
});

module.exports = actions;

}};
__resources__["/__builtin__/libs/cocos2d/Animation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Animation = BObject.extend(/** @lends cocos.Animation# */{
    name: null,
    delay: 0.0,
    frames: null,

    /** 
     * A cocos.Animation object is used to perform animations on the Sprite objects.
     * 
     * The Animation object contains cocos.SpriteFrame objects, and a possible delay between the frames.
     * You can animate a cocos.Animation object by using the cocos.actions.Animate action.
     * 
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.SpriteFrame[]} frames Frames to animate
     * @opt {Float} [delay=0.0] Delay between each frame
     * 
     * @example
     * var animation = cocos.Animation.create({frames: [f1, f2, f3], delay: 0.1});
     * sprite.runAction(cocos.actions.Animate.create({animation: animation}));
     */
    init: function (opts) {
        Animation.superclass.init.call(this, opts);

        this.frames = opts.frames || [];
        this.delay  = opts.delay  || 0.0;
    }
});

exports.Animation = Animation;

}};
__resources__["/__builtin__/libs/cocos2d/AnimationCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Plist = require('Plist').Plist;

var AnimationCache = BObject.extend(/** @lends cocos.AnimationCache# */{
    /**
     * Cached animations
     * @type Object
     */
    animations: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        AnimationCache.superclass.init.call(this);

        this.set('animations', {});
    },

    /**
     * Add an animation to the cache
     *
     * @opt {String} name Unique name of the animation
     * @opt {cocos.Animcation} animation Animation to cache
     */
    addAnimation: function (opts) {
        var name = opts.name,
            animation = opts.animation;

        this.get('animations')[name] = animation;
    },

    /**
     * Remove an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     */
    removeAnimation: function (opts) {
        var name = opts.name;

        delete this.get('animations')[name];
    },

    /**
     * Get an animation from the cache
     *
     * @opt {String} name Unique name of the animation
     * @returns {cocos.Animation} Cached animation
     */
    getAnimation: function (opts) {
        var name = opts.name;

        return this.get('animations')[name];
    }
});

/**
 * Class methods
 */
util.extend(AnimationCache, /** @lends cocos.AnimationCache */{
    /**
     * @getter sharedAnimationCache
     * @type cocos.AnimationCache
     */
    get_sharedAnimationCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.AnimationCache = AnimationCache;

}};
__resources__["/__builtin__/libs/cocos2d/Director.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Scheduler = require('./Scheduler').Scheduler,
    EventDispatcher = require('./EventDispatcher').EventDispatcher,
    Scene = require('./nodes/Scene').Scene;

var Director = BObject.extend(/** @lends cocos.Director# */{
    backgroundColor: 'rgb(0, 0, 0)',
    canvas: null,
    context: null,
    sceneStack: null,
    winSize: null,
    isPaused: false,
    maxFrameRate: 30,
    displayFPS: false,

    // Time delta
    dt: 0,
    nextDeltaTimeZero: false,
    lastUpdate: 0,

    _nextScene: null,

    /**
     * <p>Creates and handles the main view and manages how and when to execute the
     * Scenes.</p>
     *
     * <p>This class is a singleton so don't instantiate it yourself, instead use
     * cocos.Director.get('sharedDirector') to return the instance.</p>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        Director.superclass.init.call(this);

        this.set('sceneStack', []);
    },

    /**
     * Append to a HTML element. It will create a canvas tag
     *
     * @param {HTMLElement} view Any HTML element to add the application to
     */
    attachInView: function (view) {
        if (!view.tagName) {
            throw "Director.attachInView must be given a HTML DOM Node";
        }

        while (view.firstChild) {
            view.removeChild(view.firstChild);
        }

        var canvas = document.createElement('canvas');
        this.set('canvas', canvas);
        canvas.setAttribute('width', view.clientWidth);
        canvas.setAttribute('height', view.clientHeight);

        var context = canvas.getContext('2d');
        this.set('context', context);

        if (FLIP_Y_AXIS) {
            context.translate(0, view.clientHeight);
            context.scale(1, -1);
        }

        view.appendChild(canvas);

        this.set('winSize', {width: view.clientWidth, height: view.clientHeight});


        // Setup event handling

        // Mouse events
        var eventDispatcher = EventDispatcher.get('sharedDispatcher');
        var self = this;
        function mouseDown(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            function mouseDragged(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                eventDispatcher.mouseDragged(evt);
            }
            function mouseUp(evt) {
                evt.locationInWindow = ccp(evt.clientX, evt.clientY);
                evt.locationInCanvas = self.convertEventToCanvas(evt);

                document.body.removeEventListener('mousemove', mouseDragged, false);
                document.body.removeEventListener('mouseup',   mouseUp,   false);


                eventDispatcher.mouseUp(evt);
            }

            document.body.addEventListener('mousemove', mouseDragged, false);
            document.body.addEventListener('mouseup',   mouseUp,   false);

            eventDispatcher.mouseDown(evt);
        }
        function mouseMoved(evt) {
            evt.locationInWindow = ccp(evt.clientX, evt.clientY);
            evt.locationInCanvas = self.convertEventToCanvas(evt);

            eventDispatcher.mouseMoved(evt);
        }
        canvas.addEventListener('mousedown', mouseDown, false);
        canvas.addEventListener('mousemove', mouseMoved, false);

        // Keyboard events
        function keyDown(evt) {
            this._keysDown = this._keysDown || {};
            eventDispatcher.keyDown(evt);
        }
        function keyUp(evt) {
            eventDispatcher.keyUp(evt);
        }
        /*
        function keyPress(evt) {
            eventDispatcher.keyPress(evt)
        }
        */
        document.documentElement.addEventListener('keydown', keyDown, false);
        document.documentElement.addEventListener('keyup', keyUp, false);
        /*
        document.documentElement.addEventListener('keypress', keyPress, false);
        */
    },

    /**
     * Enters the Director's main loop with the given Scene. Call it to run
     * only your FIRST scene. Don't call it if there is already a running
     * scene.
     *
     * @param {cocos.Scene} scene The scene to start
     */
    runWithScene: function (scene) {
        if (!(scene instanceof Scene)) {
            throw "Director.runWithScene must be given an instance of Scene";
        }

        if (this._runningScene) {
            throw "You can't run an scene if another Scene is running. Use replaceScene or pushScene instead";
        }

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * Replaces the running scene with a new one. The running scene is
     * terminated. ONLY call it if there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to replace with
     */
    replaceScene: function (scene) {
        var index = this.sceneStack.length;

        this._sendCleanupToScene = true;
        this.sceneStack.pop();
        this.sceneStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Pops out a scene from the queue. This scene will replace the running
     * one. The running scene will be deleted. If there are no more scenes in
     * the stack the execution is terminated. ONLY call it if there is a
     * running scene.
     */
    popScene: function () {
    },

    /**
     * Suspends the execution of the running scene, pushing it on the stack of
     * suspended scenes. The new scene will be executed. Try to avoid big
     * stacks of pushed scenes to reduce memory allocation. ONLY call it if
     * there is a running scene.
     *
     * @param {cocos.Scene} scene The scene to add to the stack
     */
    pushScene: function (scene) {
        this._nextScene = scene;
    },

    /**
     * The main loop is triggered again. Call this function only if
     * cocos.Directory#stopAnimation was called earlier.
     */
    startAnimation: function () {
        var animationInterval = 1.0 / this.get('maxFrameRate');
        this._animationTimer = setInterval(util.callback(this, 'drawScene'), animationInterval * 1000);
    },

    /**
     * Stops the animation. Nothing will be drawn. The main loop won't be
     * triggered anymore. If you want to pause your animation call
     * cocos.Directory#pause instead.
     */
    stopAnimation: function () {
    },

    /**
     * Calculate time since last call
     * @private
     */
    calculateDeltaTime: function () {
        var now = (new Date()).getTime() / 1000;

        if (this.nextDeltaTimeZero) {
            this.dt = 0;
            this.nextDeltaTimeZero = false;
        }

        this.dt = Math.max(0, now - this.lastUpdate);

        this.lastUpdate = now;
    },

    /**
     * The main run loop
     * @private
     */
    drawScene: function () {
        this.calculateDeltaTime();

        if (!this.isPaused) {
            Scheduler.get('sharedScheduler').tick(this.dt);
        }


        var context = this.get('context');
        context.fillStyle = this.get('backgroundColor');
        context.fillRect(0, 0, this.winSize.width, this.winSize.height);
        //this.canvas.width = this.canvas.width


        if (this._nextScene) {
            this.setNextScene();
        }

        var rect = new geo.Rect(0, 0, this.winSize.width, this.winSize.height);

        if (rect) {
            context.beginPath();
            context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            context.clip();
            context.closePath();
        }

        this._runningScene.visit(context, rect);

        if (SHOW_REDRAW_REGIONS) {
            if (rect) {
                context.beginPath();
                context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                context.fillStyle = "rgba(255, 0, 0, 0.5)";
                //context.fill();
                context.closePath();
            }
        }

        if (this.get('displayFPS')) {
            this.showFPS();
        }
    },

    /**
     * Initialises the next scene
     * @private
     */
    setNextScene: function () {
        // TODO transitions

        if (this._runningScene) {
            this._runningScene.onExit();
            if (this._sendCleanupToScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;

        this._runningScene.onEnter();
    },

    convertEventToCanvas: function (evt) {
        var x = this.canvas.offsetLeft - document.documentElement.scrollLeft,
            y = this.canvas.offsetTop - document.documentElement.scrollTop;

        var o = this.canvas;
        while ((o = o.offsetParent)) {
            x += o.offsetLeft - o.scrollLeft;
            y += o.offsetTop - o.scrollTop;
        }

        var p = geo.ccpSub(evt.locationInWindow, ccp(x, y));
        if (FLIP_Y_AXIS) {
            p.y = this.canvas.height - p.y;
        }

        return p;
    },

    showFPS: function () {
        if (!this._fpsLabel) {
            var Label = require('./nodes/Label').Label;
            this._fpsLabel = Label.create({string: '', fontSize: 16});
            this._fpsLabel.set('anchorPoint', ccp(0, 1));
            this._frames = 0;
            this._accumDt = 0;
        }


        this._frames++;
        this._accumDt += this.get('dt');
        
        if (this._accumDt > 1.0 / 3.0)  {
            var frameRate = this._frames / this._accumDt;
            this._frames = 0;
            this._accumDt = 0;

            this._fpsLabel.set('string', 'FPS: ' + (Math.round(frameRate * 100) / 100).toString());
        }
		

        var s = this.get('winSize');
        this._fpsLabel.set('position', ccp(10, s.height - 10));

        this._fpsLabel.visit(this.get('context'));
    }

});

/**
 * Class methods
 */
util.extend(Director, /** @lends cocos.Director */{
    /**
     * A shared singleton instance of cocos.Director
     *
     * @getter sharedDirector
     * @type cocos.Director
     */
    get_sharedDirector: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Director = Director;

}};
__resources__["/__builtin__/libs/cocos2d/EventDispatcher.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry');

var EventDispatcher = BObject.extend(/** @lends cocos.EventDispatcher# */{
    dispatchEvents: true,
    keyboardDelegates: null,
    mouseDelegates: null,
    _keysDown: null,
    
    /**
     * This singleton is responsible for dispatching Mouse and Keyboard events.
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     */
    init: function () {
        EventDispatcher.superclass.init.call(this);

        this.keyboardDelegates = [];
        this.mouseDelegates = [];

        this._keysDown = {};
    },

    addDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority,
            flags    = opts.flags,
            list     = opts.list;

        var listElement = {
            delegate: delegate,
            priority: priority,
            flags: flags
        };

        var added = false;
        for (var i = 0; i < list.length; i++) {
            var elem = list[i];
            if (priority < elem.priority) {
                // Priority is lower, so insert before elem
                list.splice(i, 0, listElement);
                added = true;
                break;
            }
        }

        // High priority; append to array
        if (!added) {
            list.push(listElement);
        }
    },

    removeDelegate: function (opts) {
        var delegate = opts.delegate,
            list = opts.list;

        var idx = -1,
            i;
        for (i = 0; i < list.length; i++) {
            var l = list[i];
            if (l.delegate == delegate) {
                idx = i;
                break;
            }
        }
        if (idx == -1) {
            return;
        }
        list.splice(idx, 1);
    },
    removeAllDelegates: function (opts) {
        var list = opts.list;

        list.splice(0, list.length - 1);
    },

    addMouseDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.mouseDelegates});
    },

    removeMouseDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.mouseDelegates});
    },

    removeAllMouseDelegate: function () {
        this.removeAllDelegates({list: this.mouseDelegates});
    },

    addKeyboardDelegate: function (opts) {
        var delegate = opts.delegate,
            priority = opts.priority;

        var flags = 0;

        // TODO flags

        this.addDelegate({delegate: delegate, priority: priority, flags: flags, list: this.keyboardDelegates});
    },

    removeKeyboardDelegate: function (opts) {
        var delegate = opts.delegate;

        this.removeDelegate({delegate: delegate, list: this.keyboardDelegates});
    },

    removeAllKeyboardDelegate: function () {
        this.removeAllDelegates({list: this.keyboardDelegates});
    },



    // Mouse Events

    mouseDown: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDown) {
                var swallows = entry.delegate.mouseDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseMoved: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseMovePosition) {
            evt.deltaX = evt.clientX - this._previousMouseMovePosition.x;
            evt.deltaY = evt.clientY - this._previousMouseMovePosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseMovePosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseMoved) {
                var swallows = entry.delegate.mouseMoved(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseDragged: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        if (this._previousMouseDragPosition) {
            evt.deltaX = evt.clientX - this._previousMouseDragPosition.x;
            evt.deltaY = evt.clientY - this._previousMouseDragPosition.y;
            if (FLIP_Y_AXIS) {
                evt.deltaY *= -1;
            }
        } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
        }
        this._previousMouseDragPosition = geo.ccp(evt.clientX, evt.clientY);

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseDragged) {
                var swallows = entry.delegate.mouseDragged(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },
    mouseUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        for (var i = 0; i < this.mouseDelegates.length; i++) {
            var entry = this.mouseDelegates[i];
            if (entry.delegate.mouseUp) {
                var swallows = entry.delegate.mouseUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    // Keyboard events
    keyDown: function (evt) {
        var kc = evt.keyCode;
        if (!this.dispatchEvents || this._keysDown[kc]) {
            return;
        }

        this._keysDown[kc] = true;

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyDown) {
                var swallows = entry.delegate.keyDown(evt);
                if (swallows) {
                    break;
                }
            }
        }
    },

    keyUp: function (evt) {
        if (!this.dispatchEvents) {
            return;
        }

        var kc = evt.keyCode;
        if (this._keysDown[kc]) {
            delete this._keysDown[kc];
        }

        for (var i = 0; i < this.keyboardDelegates.length; i++) {
            var entry = this.keyboardDelegates[i];
            if (entry.delegate.keyUp) {
                var swallows = entry.delegate.keyUp(evt);
                if (swallows) {
                    break;
                }
            }
        }
    }

});

/**
 * Class methods
 */
util.extend(EventDispatcher, /** @lends cocos.EventDispatcher */{
    /**
     * A shared singleton instance of cocos.EventDispatcher
     *
     * @getter sharedDispatcher
     * @type cocos.EventDispatcher
     */
    get_sharedDispatcher: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});
exports.EventDispatcher = EventDispatcher;

}};
__resources__["/__builtin__/libs/cocos2d/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'SpriteFrame SpriteFrameCache Director Animation AnimationCache Scheduler ActionManager TMXXMLParser'.w();

/**
 * @namespace All cocos2d objects live in this namespace
 */
var cocos = {
    nodes: require('./nodes'),
    actions: require('./actions')
};

util.each(modules, function (mod, i) {
    util.extend(cocos, require('./' + mod));
});

module.exports = cocos;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/BatchNode.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray SHOW_REDRAW_REGIONS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    geo = require('geometry'),
    ccp = geo.ccp,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    RenderTexture = require('./RenderTexture').RenderTexture,
	Node = require('./Node').Node;

var BatchNode = Node.extend(/** @lends cocos.nodes.BatchNode# */{
    partialDraw: false,
    contentRect: null,
    renderTexture: null,
    dirty: true,

    /**
     * Region to redraw
     * @type geometry.Rect
     */
    dirtyRegion: null,
    dynamicResize: false,

    /** @private
     * Areas that need redrawing
     *
     * Not implemented
     */
    _dirtyRects: null,


    /**
     * Draws all children to an in-memory canvas and only redraws when something changes
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {geometry.Size} size The size of the in-memory canvas used for drawing to
     * @opt {Boolean} [partialDraw=false] Draw only the area visible on screen. Small maps may be slower in some browsers if this is true.
     */
	init: function (opts) {
		BatchNode.superclass.init.call(this, opts);

        var size = opts.size || geo.sizeMake(1, 1);
        this.set('partialDraw', opts.partialDraw);

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));
        
		this._dirtyRects = [];
        this.set('contentRect', geo.rectMake(0, 0, size.width, size.height));
        this.renderTexture = RenderTexture.create(size);
        this.renderTexture.sprite.set('isRelativeAnchorPoint', false);
        this.addChild({child: this.renderTexture});
	},

    addChild: function (opts) {
        BatchNode.superclass.addChild.call(this, opts);

        var child = opts.child,
            z     = opts.z;

        if (child == this.renderTexture) {
            return;
        }

        // TODO handle texture resize

        // Watch for changes in child
        evt.addListener(child, 'istransformdirty_changed', util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));
        evt.addListener(child, 'visible_changed', util.callback(this, function () {
            this.addDirtyRegion(child.get('boundingBox'));
        }));

        this.addDirtyRegion(child.get('boundingBox'));
    },

    removeChild: function (opts) {
        BatchNode.superclass.removeChild.call(this, opts);

        // TODO remove istransformdirty_changed and visible_changed listeners

        this.set('dirty', true);
    },

    addDirtyRegion: function (rect) {
        var region = this.get('dirtyRegion');
        if (!region) {
            region = util.copy(rect);
        } else {
            region = geo.rectUnion(region, rect);
        }

        this.set('dirtyRegion', region);
        this.set('dirty', true);
    },

    _resizeCanvas: function (oldSize) {
        var size = this.get('contentSize');

        if (geo.sizeEqualToSize(size, oldSize)) {
            return; // No change
        }


        this.renderTexture.set('contentSize', size);
        this.set('dirty', true);
    },

    update: function () {

    },

    visit: function (context) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        var rect = this.get('dirtyRegion');
        // Only redraw if something changed
        if (this.dirty) {

            if (rect) {
                if (this.get('partialDraw')) {
                    // Clip region to visible area
                    var s = require('../Director').Director.get('sharedDirector').get('winSize'),
                        p = this.get('position');
                    var r = new geo.Rect(
                        0, 0,
                        s.width, s.height
                    );
                    r = geo.rectApplyAffineTransform(r, this.worldToNodeTransform());
                    rect = geo.rectIntersection(r, rect);
                }

                this.renderTexture.clear(rect);

                this.renderTexture.context.save();
                this.renderTexture.context.beginPath();
                this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                this.renderTexture.context.clip();
                this.renderTexture.context.closePath();
            } else {
                this.renderTexture.clear();
            }

            for (var i = 0, childLen = this.children.length; i < childLen; i++) {
                var c = this.children[i];
                if (c == this.renderTexture) {
                    continue;
                }

                // Draw children inside rect
                if (!rect || geo.rectOverlapsRect(c.get('boundingBox'), rect)) {
                    c.visit(this.renderTexture.context, rect);
                }
            }

            if (SHOW_REDRAW_REGIONS) {
                if (rect) {
                    this.renderTexture.context.beginPath();
                    this.renderTexture.context.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
                    this.renderTexture.context.fillStyle = "rgba(0, 0, 255, 0.5)";
                    this.renderTexture.context.fill();
                    this.renderTexture.context.closePath();
                }
            }

            if (rect) {
                this.renderTexture.context.restore();
            }

            this.set('dirty', false);
            this.set('dirtyRegion', null);
        }

        this.renderTexture.visit(context);

        context.restore();
	},

	draw: function (ctx) {
    },

    onEnter: function () {
        if (this.get('partialDraw')) {
            evt.addListener(this.get('parent'), 'istransformdirty_changed', util.callback(this, function () {
                var box = this.get('visibleRect');
                this.addDirtyRegion(box);
            }));
        }
    }
});

var SpriteBatchNode = BatchNode.extend(/** @lends cocos.nodes.SpriteBatchNode# */{
    textureAtlas: null,

    /**
     * @memberOf cocos.nodes
     * @class A BatchNode that accepts only Sprite using the same texture
     * @extends cocos.nodes.BatchNode
     * @constructs
     *
     * @opt {String} file (Optional) Path to image to use as sprite atlas
     * @opt {Texture2D} texture (Optional) Texture to use as sprite atlas
     * @opt {cocos.TextureAtlas} textureAtlas (Optional) TextureAtlas to use as sprite atlas
     */
    init: function (opts) {
        SpriteBatchNode.superclass.init.call(this, opts);

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture;

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        }

        this.set('textureAtlas', textureAtlas);
    },

    /**
     * @getter texture
     * @type cocos.Texture2D
     */
    get_texture: function () {
		return this.textureAtlas ? this.textureAtlas.texture : null;
	}

});

exports.BatchNode = BatchNode;
exports.SpriteBatchNode = SpriteBatchNode;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/index.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path');

var modules = 'Node Layer Scene Label Sprite TMXTiledMap BatchNode RenderTexture Menu MenuItem'.w();

/** 
 * @memberOf cocos
 * @namespace All cocos2d nodes. i.e. anything that can be added to a Scene
 */
var nodes = {};

util.each(modules, function (mod, i) {
    util.extend(nodes, require('./' + mod));
});

module.exports = nodes;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Label.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    console = require('system').console,
    Director = require('../Director').Director,
    Node = require('./Node').Node,
    ccp = require('geometry').ccp;

var Label = Node.extend(/** @lends cocos.nodes.Label# */{
    string:   '',
    fontName: 'Helvetica',
    fontSize: 16,
    fontColor: 'white',

    /**
     * Renders a simple text label
     *
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} [string=""] The text string to draw
     * @opt {Float} [fontSize=16] The size of the font
     * @opt {String} [fontName="Helvetica"] The name of the font to use
     * @opt {String} [fontColor="white"] The color of the text
     */
    init: function (opts) {
        Label.superclass.init.call(this, opts);

        util.each('fontSize fontName fontColor string'.w(), util.callback(this, function (name) {
            // Set property on init
            if (opts[name]) {
                this.set(name, opts[name]);
            }

            // Update content size
            this._updateLabelContentSize();
        }));
    },

    /** 
     * String of the font name and size to use in a format &lt;canvas&gt; understands
     *
     * @getter font
     * @type String
     */
    get_font: function (key) {
        return this.get('fontSize') + 'px ' + this.get('fontName');
    },

    draw: function (context) {
        if (FLIP_Y_AXIS) {
            context.save();

            // Flip Y axis
            context.scale(1, -1);
            context.translate(0, -this.get('fontSize'));
        }


        context.fillStyle = this.get('fontColor');
        context.font = this.get('font');
        context.textBaseline = 'top';
        if (context.fillText) {
            context.fillText(this.get('string'), 0, 0);
        } else if (context.mozDrawText) {
            context.mozDrawText(this.get('string'));
        }

        if (FLIP_Y_AXIS) {
            context.restore();
        }
    },

    /**
     * @private
     */
    _updateLabelContentSize: function () {
        var ctx = Director.get('sharedDirector').get('context');
        var size = {width: 0, height: this.get('fontSize')};

        var prevFont = ctx.font;
        ctx.font = this.get('font');

        if (ctx.measureText) {
            var txtSize = ctx.measureText(this.get('string'));
            size.width = txtSize.width;
        } else if (ctx.mozMeasureText) {
            size.width = ctx.mozMeasureText(this.get('string'));
        }

        ctx.font = prevFont;

        this.set('contentSize', size);
    }
});

module.exports.Label = Label;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Layer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node,
    util = require('util'),
    evt = require('event'),
    Director = require('../Director').Director,
    ccp    = require('geometry').ccp,
    EventDispatcher = require('../EventDispatcher').EventDispatcher;

var Layer = Node.extend(/** @lends cocos.nodes.Layer# */{
    isMouseEnabled: false,
    isKeyboardEnabled: false,
    mouseDelegatePriority: 0,
    keyboardDelegatePriority: 0,

    /** 
     * A fullscreen Node. You need at least 1 layer in your app to add other nodes to.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Layer.superclass.init.call(this);

        var s = Director.get('sharedDirector').get('winSize');

        this.set('isRelativeAnchorPoint', false);
        this.anchorPoint = ccp(0.5, 0.5);
        this.set('contentSize', s);

        evt.addListener(this, 'ismouseenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isMouseEnabled) {
                    EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
                }
            }
        }));


        evt.addListener(this, 'iskeyboardenabled_changed', util.callback(this, function () {
            if (this.isRunning) {
                if (this.isKeyboardEnabled) {
                    EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
                } else {
                    EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
                }
            }
        }));
    },

    onEnter: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').addMouseDelegate({delegate: this, priority: this.get('mouseDelegatePriority')});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').addKeyboardDelegate({delegate: this, priority: this.get('keyboardDelegatePriority')});
        }

        Layer.superclass.onEnter.call(this);
    },

    onExit: function () {
        if (this.isMouseEnabled) {
            EventDispatcher.get('sharedDispatcher').removeMouseDelegate({delegate: this});
        }
        if (this.isKeyboardEnabled) {
            EventDispatcher.get('sharedDispatcher').removeKeyboardDelegate({delegate: this});
        }

        Layer.superclass.onExit.call(this);
    }
});

module.exports.Layer = Layer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Menu.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Layer = require('./Layer').Layer,
    Director = require('../Director').Director,
    MenuItem = require('./MenuItem').MenuItem,
    geom = require('geometry'), ccp = geom.ccp;

/** @private
 * @constant */
var kMenuStateWaiting = 0;

/** @private
 * @constant */
var kMenuStateTrackingTouch = 1;
	

var Menu = Layer.extend(/** @lends cocos.nodes.Menu# */{
	mouseDelegatePriority: (-Number.MAX_VALUE + 1),
	state: kMenuStateWaiting,
	selectedItem: null,
	opacuty: 255,
	color: null,

    /**
     * A fullscreen node used to render a selection of menu options
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Layer
     *
     * @opt {cocos.nodes.MenuItem[]} items An array of MenuItems to draw on the menu
     */
	init: function (opts) {
		Menu.superclass.init.call(this, opts);

		var items = opts.items;

		this.set('isMouseEnabled', true);
		
        var s = Director.get('sharedDirector').get('winSize');

		this.set('isRelativeAnchorPoint', false);
		this.anchorPoint = ccp(0.5, 0.5);
		this.set('contentSize', s);

		this.set('position', ccp(s.width / 2, s.height / 2));


		if (items) {
			var z = 0;
			util.each(items, util.callback(this, function (item) {
				this.addChild({child: item, z: z++});
			}));
		}

        
	},

	addChild: function (opts) {
		if (!opts.child instanceof MenuItem) {
			throw "Menu only supports MenuItem objects as children";
		}

        Menu.superclass.addChild.call(this, opts);
    },

    itemForMouseEvent: function (event) {
        var location = event.locationInCanvas;

        var children = this.get('children');
        for (var i = 0, len = children.length; i < len; i++) {
            var item = children[i];

            if (item.get('visible') && item.get('isEnabled')) {
                var local = item.convertToNodeSpace(location);
                
                var r = item.get('rect');
                r.origin = ccp(0, 0);

                if (geom.rectContainsPoint(r, local)) {
                    return item;
                }

            }
        }

        return null;
    },

    mouseUp: function (event) {
        if (this.selectedItem) {
            this.selectedItem.set('isSelected', false);
            this.selectedItem.activate();

            return true;
        }

        if (this.state != kMenuStateWaiting) {
            this.set('state', kMenuStateWaiting);
        }

        return false;

    },
    mouseDown: function (event) {
        if (this.state != kMenuStateWaiting || !this.visible) {
            return false;
        }

        var selectedItem = this.itemForMouseEvent(event);
        this.set('selectedItem', selectedItem);
        if (selectedItem) {
            selectedItem.set('isSelected', true);
            this.set('state', kMenuStateTrackingTouch);

            return true;
        }

        return false;
    },

    mouseDragged: function (event) {
        var currentItem = this.itemForMouseEvent(event);

        if (currentItem != this.selectedItem) {
            if (this.selectedItem) {
                this.selectedItem.set('isSelected', false);
            }
            this.set('selectedItem', currentItem);
            if (this.selectedItem) {
                this.selectedItem.set('isSelected', true);
            }
        }

        if (currentItem && this.state == kMenuStateTrackingTouch) {
            return true;
        }

        return false;
        
    }

});

exports.Menu = Menu;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/MenuItem.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    Node = require('./Node').Node,
    Sprite = require('./Sprite').Sprite,
    rectMake = require('geometry').rectMake,
    ccp = require('geometry').ccp;

var MenuItem = Node.extend(/** @lends cocos.nodes.MenuItem# */{
	isEnabled: true,
	isSelected: false,
	callback: null,

    /**
     * Base class for any buttons or options in a menu
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Function} callback Function to call when menu item is activated
     */
	init: function (opts) {
		MenuItem.superclass.init.call(this, opts);

		var callback = opts.callback;

		this.set('anchorPoint', ccp(0.5, 0.5));
		this.set('callback', callback);
	},

	activate: function () {
		if (this.isEnabled && this.callback) {
			this.callback(this);
		}
	},

    /**
     * @getter rect
     * @type geometry.Rect
     */
	get_rect: function () {
		return rectMake(
			this.position.x - this.contentSize.width  * this.anchorPoint.x,
			this.position.y - this.contentSize.height * this.anchorPoint.y,
			this.contentSize.width,
			this.contentSize.height
		);
	}
});

var MenuItemSprite = MenuItem.extend(/** @lends cocos.nodes.MenuItemSprite# */{
	normalImage: null,
	selectedImage: null,
	disabledImage: null,

    /**
     * A menu item that accepts any cocos.nodes.Node
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItem
     *
     * @opt {cocos.nodes.Node} normalImage Main Node to draw
     * @opt {cocos.nodes.Node} selectedImage Node to draw when menu item is selected
     * @opt {cocos.nodes.Node} disabledImage Node to draw when menu item is disabled
     */
	init: function (opts) {
		MenuItemSprite.superclass.init.call(this, opts);

		var normalImage   = opts.normalImage,
			selectedImage = opts.selectedImage,
			disabledImage = opts.disabledImage;

		this.set('normalImage', normalImage);
		this.set('selectedImage', selectedImage);
		this.set('disabledImage', disabledImage);

		this.set('contentSize', normalImage.get('contentSize'));
	},

	draw: function (ctx) {
		if (this.isEnabled) {
			if (this.isSelected) {
				this.selectedImage.draw(ctx);
			} else {
				this.normalImage.draw(ctx);
			}
		} else {
			if (this.disabledImage) {
				this.disabledImage.draw(ctx);
			} else {
				this.normalImage.draw(ctx);
			}
		}
	}
});

var MenuItemImage = MenuItemSprite.extend(/** @lends cocos.nodes.MenuItemImage# */{

    /**
     * MenuItem that accepts image files
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.MenuItemSprite
     *
     * @opt {String} normalImage Main image file to draw
     * @opt {String} selectedImage Image file to draw when menu item is selected
     * @opt {String} disabledImage Image file to draw when menu item is disabled
     */
	init: function (opts) {
		var normalI   = opts.normalImage,
			selectedI = opts.selectedImage,
			disabledI = opts.disabledImage,
			callback  = opts.callback;

		var normalImage = Sprite.create({file: normalI}),
			selectedImage = Sprite.create({file: selectedI}),
			disabledImage = null;

		if (disabledI) {
			disabledImage = Sprite.create({file: disabledI});
		}

		return MenuItemImage.superclass.init.call(this, {normalImage: normalImage, selectedImage: selectedImage, disabledImage: disabledImage, callback: callback});
    }
});

exports.MenuItem = MenuItem;
exports.MenuItemImage = MenuItemImage;
exports.MenuItemSprite = MenuItemSprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Node.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Scheduler = require('../Scheduler').Scheduler,
    ActionManager = require('../ActionManager').ActionManager,
    geo = require('geometry'), ccp = geo.ccp;

var Node = BObject.extend(/** @lends cocos.nodes.Node# */{
    isCocosNode: true,

    /**
     * Is the node visible
     * @type boolean
     */
    visible: true,

    /**
     * Position relative to parent node
     * @type geometry.Point
     */
    position: null,

    /**
     * Parent node
     * @type cocos.nodes.Node
     */
    parent: null,

    /**
     * Unique tag to identify the node
     * @type *
     */
    tag: null,

    /**
     * Size of the node
     * @type geometry.Size
     */
    contentSize: null,

    /**
     * Nodes Z index. i.e. draw order
     * @type Integer
     */
    zOrder: 0,

    /**
     * Anchor point for scaling and rotation. 0x0 is top left and 1x1 is bottom right
     * @type geometry.Point
     */
    anchorPoint: null,

    /**
     * Anchor point for scaling and rotation in pixels from top left
     * @type geometry.Point
     */
    anchorPointInPixels: null,

    /**
     * Rotation angle in degrees
     * @type Float
     */
    rotation: 0,

    /**
     * X scale factor
     * @type Float
     */
    scaleX: 1,

    /**
     * Y scale factor
     * @type Float
     */
    scaleY: 1,
    isRunning: false,
    isRelativeAnchorPoint: true,

    isTransformDirty: true,
    isInverseDirty: true,
    inverse: null,
    transformMatrix: null,

    /**
     * The child Nodes
     * @type cocos.nodes.Node[]
     */
    children: null,

    /**
     * @memberOf cocos.nodes
     * @class The base class all visual elements extend from
     * @extends BObject
     * @constructs
     */
    init: function () {
        Node.superclass.init.call(this);
        this.set('contentSize', {width: 0, height: 0});
        this.anchorPoint = ccp(0.5, 0.5);
        this.anchorPointInPixels = ccp(0, 0);
        this.position = ccp(0, 0);
        this.children = [];

        util.each(['scaleX', 'scaleY', 'rotation', 'position', 'anchorPoint', 'contentSize', 'isRelativeAnchorPoint'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._dirtyTransform));
        }));
        evt.addListener(this, 'anchorpoint_changed', util.callback(this, this._updateAnchorPointInPixels));
        evt.addListener(this, 'contentsize_changed', util.callback(this, this._updateAnchorPointInPixels));
    },

    /**
     * Calculates the anchor point in pixels and updates the
     * anchorPointInPixels property
     * @private
     */
    _updateAnchorPointInPixels: function () {
        var ap = this.get('anchorPoint'),
            cs = this.get('contentSize');
        this.set('anchorPointInPixels', ccp(cs.width * ap.x, cs.height * ap.y));
    },

    /**
     * Add a child Node
     *
     * @opt {cocos.nodes.Node} child The child node to add
     * @opt {Integer} [z] Z Index for the child
     * @opt {Integer|String} [tag] A tag to reference the child with
     * @returns {cocos.nodes.Node} The node the child was added to. i.e. 'this'
     */
    addChild: function (opts) {
        if (opts.isCocosNode) {
            return this.addChild({child: opts});
        }

        var child = opts.child,
            z = opts.z,
            tag = opts.tag;

        if (z === undefined || z === null) {
            z = child.get('zOrder');
        }

        //this.insertChild({child: child, z:z});
        var added = false;

        
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }

        child.set('tag', tag);
        child.set('zOrder', z);
        child.set('parent', this);

        if (this.isRunning) {
            child.onEnter();
        }

        return this;
    },
    getChild: function (opts) {
        var tag = opts.tag;

        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].tag == tag) {
                return this.children[i];
            }
        }

        return null;
    },

    removeChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        if (!child) {
            return;
        }

        var children = this.get('children'),
            idx = children.indexOf(child);

        if (idx > -1) {
            this.detatchChild({child: child, cleanup: cleanup});
        }
    },

    detatchChild: function (opts) {
        var child = opts.child,
            cleanup = opts.cleanup;

        var children = this.get('children'),
            isRunning = this.get('isRunning'),
            idx = children.indexOf(child);

        if (isRunning) {
            child.onExit();
        }

        if (cleanup) {
            child.cleanup();
        }

        child.set('parent', null);
        children.splice(idx, 1);
    },

    reorderChild: function (opts) {
        var child = opts.child,
            z     = opts.z;

        var pos = this.children.indexOf(child);
        if (pos == -1) {
            throw "Node isn't a child of this node";
        }

        child.set('zOrder', z);

        // Remove child
        this.children.splice(pos, 1);

        // Add child back at correct location
        var added = false;
        for (var i = 0, childLen = this.children.length; i < childLen; i++) {
            var c = this.children[i];
            if (c.zOrder > z) {
                added = true;
                this.children.splice(i, 0, child);
                break;
            }
        }

        if (!added) {
            this.children.push(child);
        }
    },

    /**
     * Draws the node. Override to do custom drawing. If it's less efficient to
     * draw only the area inside the rect then don't bother. The result will be
     * clipped to that area anyway.
     *
     * @param {CanvasRenderingContext2D|WebGLRenderingContext} context Canvas rendering context
     * @param {geometry.Rect} rect Rectangular region that needs redrawing. Limit drawing to this area only if it's more efficient to do so.
     */
    draw: function (context, rect) {
        // All draw code goes here
    },

    /**
     * @getter scale
     * @type Float
     */
    get_scale: function () {
        if (this.scaleX != this.scaleY) {
            throw "scaleX and scaleY aren't identical";
        }

        return this.scaleX;
    },

    /**
     * @setter scale
     * @type Float
     */
    set_scale: function (val) {
        this.set('scaleX', val);
        this.set('scaleY', val);
    },

    scheduleUpdate: function (opts) {
        opts = opts || {};
        var priority = opts.priority || 0;

        Scheduler.get('sharedScheduler').scheduleUpdate({target: this, priority: priority, paused: !this.get('isRunning')});
    },

    /**
     * Triggered when the node is added to a scene
     *
     * @event
     */
    onEnter: function () {
        util.each(this.children, function (child) {
            child.onEnter();
        });

        this.resumeSchedulerAndActions();
        this.set('isRunning', true);
    },

    /**
     * Triggered when the node is removed from a scene
     *
     * @event
     */
    onExit: function () {
        this.pauseSchedulerAndActions();
        this.set('isRunning', false);

        util.each(this.children, function (child) {
            child.onExit();
        });
    },

    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllSelectors();
        util.each(this.children, function (child) {
            child.cleanup();
        });
    },

    resumeSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').resumeTarget(this);
        ActionManager.get('sharedManager').resumeTarget(this);
    },
    pauseSchedulerAndActions: function () {
        Scheduler.get('sharedScheduler').pauseTarget(this);
        ActionManager.get('sharedManager').pauseTarget(this);
    },
    unscheduleAllSelectors: function () {
        Scheduler.get('sharedScheduler').unscheduleAllSelectorsForTarget(this);
    },
    stopAllActions: function () {
        ActionManager.get('sharedManager').removeAllActionsFromTarget(this);
    },

    visit: function (context, rect) {
        if (!this.visible) {
            return;
        }

        context.save();

        this.transform(context);

        // Adjust redraw region by nodes position
        if (rect) {
            var pos = this.get('position');
            rect = new geo.Rect(rect.origin.x - pos.x, rect.origin.y - pos.y, rect.size.width, rect.size.height);
        }

        // Draw background nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder < 0) {
                child.visit(context, rect);
            }
        });

        this.draw(context, rect);

        // Draw foreground nodes
        util.each(this.children, function (child, i) {
            if (child.zOrder >= 0) {
                child.visit(context, rect);
            }
        });

        context.restore();
    },
    transform: function (context) {
        // Translate
        if (this.isRelativeAnchorPoint && (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0)) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }

        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0) {
            context.translate(Math.round(this.position.x + this.anchorPointInPixels.x), Math.round(this.position.y + this.anchorPointInPixels.y));
        } else {
            context.translate(Math.round(this.position.x), Math.round(this.position.y));
        }

        // Rotate
        context.rotate(geo.degreesToRadians(this.get('rotation')));

        // Scale
        context.scale(this.scaleX, this.scaleY);
 
        if (this.anchorPointInPixels.x !== 0 || this.anchorPointInPixels !== 0) {
            context.translate(Math.round(-this.anchorPointInPixels.x), Math.round(-this.anchorPointInPixels.y));
        }
    },

    runAction: function (action) {
        ActionManager.get('sharedManager').addAction({action: action, target: this, paused: this.get('isRunning')});
    },

    nodeToParentTransform: function () {
        if (this.isTransformDirty) {
            this.transformMatrix = geo.affineTransformIdentity();

            if (!this.isRelativeAnchorPoint && !geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.anchorPointInPixels.x, this.anchorPointInPixels.y);
            }
            
            if (!geo.pointEqualToPoint(this.position, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, this.position.x, this.position.y);
            }

            if (this.rotation !== 0) {
                this.transformMatrix = geo.affineTransformRotate(this.transformMatrix, -geo.degreesToRadians(this.rotation));
            }
            if (!(this.scaleX == 1 && this.scaleY == 1)) {
                this.transformMatrix = geo.affineTransformScale(this.transformMatrix, this.scaleX, this.scaleY);
            }
            
            if (!geo.pointEqualToPoint(this.anchorPointInPixels, ccp(0, 0))) {
                this.transformMatrix = geo.affineTransformTranslate(this.transformMatrix, -this.anchorPointInPixels.x, -this.anchorPointInPixels.y);
            }
            
            this.set('isTransformDirty', false);
                
        }

        return this.transformMatrix;
    },

    parentToNodeTransform: function () {
        // TODO
    },

    nodeToWorldTransform: function () {
        var t = this.nodeToParentTransform();

        var p;
        for (p = this.get('parent'); p; p = p.get('parent')) {
            t = geo.affineTransformConcat(t, p.nodeToParentTransform());
        }

        return t;
    },

    worldToNodeTransform: function () {
        return geo.affineTransformInvert(this.nodeToWorldTransform());
    },

    convertToNodeSpace: function (worldPoint) {
        return geo.pointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * @getter boundingBox
     * @type geometry.Rect
     */
    get_boundingBox: function () {
        var cs = this.get('contentSize');
        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToParentTransform());
        return rect;
    },

    /**
     * @getter worldBoundingBox
     * @type geometry.Rect
     */
    get_worldBoundingBox: function () {
        var cs = this.get('contentSize');

        var rect = geo.rectMake(0, 0, cs.width, cs.height);
        rect = geo.rectApplyAffineTransform(rect, this.nodeToWorldTransform());
        return rect;
    },

    /**
     * The area of the node currently visible on screen. Returns an rect even
     * if visible is false.
     *
     * @getter visibleRect
     * @type geometry.Rect
     */
    get_visibleRect: function () {
        var s = require('../Director').Director.get('sharedDirector').get('winSize');
        var rect = new geo.Rect(
            0, 0,
            s.width, s.height
        );

        return geo.rectApplyAffineTransform(rect, this.worldToNodeTransform());
    },

    /**
     * @private
     */
    _dirtyTransform: function () {
        this.set('isTransformDirty', true);
    }
});

module.exports.Node = Node;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/RenderTexture.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Node = require('./Node').Node,
    geo = require('geometry'),
    Sprite = require('./Sprite').Sprite,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    ccp = geo.ccp;

var RenderTexture = Node.extend(/** @lends cocos.nodes.RenderTexture# */{
    canvas: null,
    context: null,
    sprite: null,

    /** 
     * An in-memory canvas which can be drawn to in the background before drawing on screen
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {Integer} width The width of the canvas
     * @opt {Integer} height The height of the canvas
     */
    init: function (opts) {
        RenderTexture.superclass.init.call(this, opts);

        var width = opts.width,
            height = opts.height;

        evt.addListener(this, 'contentsize_changed', util.callback(this, this._resizeCanvas));

        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');

        var atlas = TextureAtlas.create({canvas: this.canvas});
        this.sprite = Sprite.create({textureAtlas: atlas, rect: {origin: ccp(0, 0), size: {width: width, height: height}}});

        this.set('contentSize', geo.sizeMake(width, height));
        this.addChild(this.sprite);
        this.set('anchorPoint', ccp(0, 0));
        this.sprite.set('anchorPoint', ccp(0, 0));

    },

    /**
     * @private
     */
    _resizeCanvas: function () {
        var size = this.get('contentSize'),
            canvas = this.get('canvas');

        canvas.width  = size.width;
        canvas.height = size.height;
        if (FLIP_Y_AXIS) {
            this.context.scale(1, -1);
            this.context.translate(0, -canvas.height);
        }

        var s = this.get('sprite');
        if (s) {
            s.set('textureRect', {rect: geo.rectMake(0, 0, size.width, size.height)});
        }
    },

    /**
     * Clear the canvas
     */
    clear: function (rect) {
        if (rect) {
            this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
        } else {
            this.canvas.width = this.canvas.width;
            if (FLIP_Y_AXIS) {
                this.context.scale(1, -1);
                this.context.translate(0, -this.canvas.height);
            }
        }
    }
});

module.exports.RenderTexture = RenderTexture;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Scene.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var Node = require('./Node').Node;

var Scene = Node.extend(/** @lends cocos.nodes.Scene */{
    /**
     * Everything in your view will be a child of this object. You need at least 1 scene per app.
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     */
    init: function () {
        Scene.superclass.init.call(this);
    }

});

module.exports.Scene = Scene;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/Sprite.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    evt = require('event'),
    Director = require('../Director').Director,
    TextureAtlas = require('../TextureAtlas').TextureAtlas,
    Node = require('./Node').Node,
    geo = require('geometry'),
    ccp = geo.ccp;

var Sprite = Node.extend(/** @lends cocos.nodes.Sprite# */{
    textureAtlas: null,
    rect: null,
    dirty: true,
    recursiveDirty: true,
    quad: null,
    flipX: false,
    flipY: false,
    offsetPosition: null,
    unflippedOffsetPositionFromCenter: null,
    untrimmedSize: null,

    /**
     * A small 2D graphics than can be animated
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file Path to image to use as sprite atlas
     * @opt {Rect} [rect] The rect in the sprite atlas image file to use as the sprite
     */
    init: function (opts) {
        Sprite.superclass.init.call(this, opts);

        opts = opts || {};

        var file         = opts.file,
            textureAtlas = opts.textureAtlas,
            texture      = opts.texture,
            frame        = opts.frame,
            spritesheet  = opts.spritesheet,
            rect         = opts.rect;

        this.set('offsetPosition', ccp(0, 0));
        this.set('unflippedOffsetPositionFromCenter', ccp(0, 0));


        if (frame) {
            texture = frame.get('texture');
            rect    = frame.get('rect');
        }

        util.each(['scale', 'scaleX', 'scaleY', 'rect', 'flipX', 'flipY'], util.callback(this, function (key) {
            evt.addListener(this, key.toLowerCase() + '_changed', util.callback(this, this._updateQuad));
        }));
        evt.addListener(this, 'textureatlas_changed', util.callback(this, this._updateTextureQuad));

        if (file || texture) {
            textureAtlas = TextureAtlas.create({file: file, texture: texture});
        } else if (spritesheet) {
            textureAtlas = spritesheet.get('textureAtlas');
            this.set('useSpriteSheet', true);
        } else if (!textureAtlas) {
            //throw "Sprite has no texture";
        }

        if (!rect && textureAtlas) {
            rect = {origin: ccp(0, 0), size: {width: textureAtlas.texture.size.width, height: textureAtlas.texture.size.height}};
        }

        if (rect) {
            this.set('rect', rect);
            this.set('contentSize', rect.size);

            this.quad = {
                drawRect: {origin: ccp(0, 0), size: rect.size},
                textureRect: rect
            };
        }

        this.set('textureAtlas', textureAtlas);

        if (frame) {
            this.set('displayFrame', frame);
        }
    },

    /**
     * @private
     */
    _updateTextureQuad: function (obj, key, texture, oldTexture) {
        if (oldTexture) {
            oldTexture.removeQuad({quad: this.get('quad')});
        }

        if (texture) {
            texture.insertQuad({quad: this.get('quad')});
        }
    },

    /**
     * @setter textureCoords
     * @type geometry.Rect
     */
    set_textureCoords: function (rect) {
        var quad = this.get('quad');
        if (!quad) {
            quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        quad.textureRect = util.copy(rect);

        this.set('quad', quad);
    },

    /**
     * @setter textureRect
     * @type geometry.Rect
     */
    set_textureRect: function (opts) {
        var rect = opts.rect,
            rotated = !!opts.rotated,
            untrimmedSize = opts.untrimmedSize || rect.size;

        this.set('contentSize', untrimmedSize);
        this.set('rect', util.copy(rect));
        this.set('textureCoords', rect);

        var quad = this.get('quad');

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = this.get('offsetPosition');
        offsetPosition.x =  relativeOffset.x + (this.get('contentSize').width  - rect.size.width) / 2;
        offsetPosition.y = -relativeOffset.y + (this.get('contentSize').height - rect.size.height) / 2;

        quad.drawRect.origin = util.copy(offsetPosition);
        quad.drawRect.size = util.copy(rect.size);
        if (this.flipX) {
            quad.drawRect.size.width *= -1;
            quad.drawRect.origin.x = -rect.size.width;
        }
        if (this.flipY) {
            quad.drawRect.size.height *= -1;
            quad.drawRect.origin.y = -rect.size.height;
        }

        this.set('quad', quad);
    },

    /**
     * @private
     */
    _updateQuad: function () {
        if (!this.quad) {
            this.quad = {
                drawRect: geo.rectMake(0, 0, 0, 0), 
                textureRect: geo.rectMake(0, 0, 0, 0)
            };
        }

        var relativeOffset = util.copy(this.get('unflippedOffsetPositionFromCenter'));

        if (this.get('flipX')) {
            relativeOffset.x = -relativeOffset.x;
        }
        if (this.get('flipY')) {
            relativeOffset.y = -relativeOffset.y;
        }

        var offsetPosition = this.get('offsetPosition');
        offsetPosition.x = relativeOffset.x + (this.get('contentSize').width  - this.get('rect').size.width) / 2;
        offsetPosition.y = relativeOffset.y + (this.get('contentSize').height - this.get('rect').size.height) / 2;

        this.quad.textureRect = util.copy(this.rect);
        this.quad.drawRect.origin = util.copy(offsetPosition);
        this.quad.drawRect.size = util.copy(this.rect.size);

        if (this.flipX) {
            this.quad.drawRect.size.width *= -1;
            this.quad.drawRect.origin.x = -this.rect.size.width;
        }
        if (this.flipY) {
            this.quad.drawRect.size.height *= -1;
            this.quad.drawRect.origin.y = -this.rect.size.height;
        }
    },

    updateTransform: function (ctx) {
        if (!this.useSpriteSheet) {
            throw "updateTransform is only valid when Sprite is being rendered using a SpriteSheet";
        }

        if (!this.visible) {
            this.set('dirty', false);
            this.set('recursiveDirty', false);
            return;
        }

        // TextureAtlas has hard reference to this quad so we can just update it directly
        this.quad.drawRect.origin = {
            x: this.position.x - this.anchorPointInPixels.x * this.scaleX,
            y: this.position.y - this.anchorPointInPixels.y * this.scaleY
        };
        this.quad.drawRect.size = {
            width: this.rect.size.width * this.scaleX,
            height: this.rect.size.height * this.scaleY
        };

        this.set('dirty', false);
        this.set('recursiveDirty', false);
    },

    draw: function (ctx) {
        if (!this.quad) {
            return;
        }
        this.get('textureAtlas').drawQuad(ctx, this.quad);
    },

    isFrameDisplayed: function (frame) {
        if (!this.rect || !this.textureAtlas) {
            return false;
        }
        return (frame.texture === this.textureAtlas.texture && geo.rectEqualToRect(frame.rect, this.rect));
    },


    /**
     * @setter displayFrame
     * @type cocos.SpriteFrame
     */
    set_displayFrame: function (frame) {
        if (!frame) {
            delete this.quad;
            return;
        }
        this.set('unflippedOffsetPositionFromCenter', util.copy(frame.offset));


        // change texture
        if (!this.textureAtlas || frame.texture !== this.textureAtlas.texture) {
            this.set('textureAtlas', TextureAtlas.create({texture: frame.texture}));
        }

        this.set('textureRect', {rect: frame.rect, rotated: frame.rotated, untrimmedSize: frame.originalSize});
    }
});

module.exports.Sprite = Sprite;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXLayer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    SpriteBatchNode = require('./BatchNode').SpriteBatchNode,
    Sprite = require('./Sprite').Sprite,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    geo    = require('geometry'),
    ccp    = geo.ccp,
    Node = require('./Node').Node;

var TMXLayer = SpriteBatchNode.extend(/** @lends cocos.nodes.TMXLayer# */{
    layerSize: null,
    layerName: '',
    tiles: null,
    tilset: null,
    layerOrientation: 0,
    mapTileSize: null,
    properties: null,

    /** 
     * A tile map layer loaded from a TMX file. This will probably automatically be made by cocos.TMXTiledMap
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.SpriteBatchNode
     *
     * @opt {cocos.TMXTilesetInfo} tilesetInfo
     * @opt {cocos.TMXLayerInfo} layerInfo
     * @opt {cocos.TMXMapInfo} mapInfo
     */
    init: function (opts) {
        var tilesetInfo = opts.tilesetInfo,
            layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo;

        var size = layerInfo.get('layerSize'),
            totalNumberOfTiles = size.width * size.height;

        var tex = null;
        if (tilesetInfo) {
            tex = tilesetInfo.sourceImage;
        }

        TMXLayer.superclass.init.call(this, {file: tex});

		this.set('anchorPoint', ccp(0, 0));

        this.layerName = layerInfo.get('name');
        this.layerSize = layerInfo.get('layerSize');
        this.tiles = layerInfo.get('tiles');
        this.minGID = layerInfo.get('minGID');
        this.maxGID = layerInfo.get('maxGID');
        this.opacity = layerInfo.get('opacity');
        this.properties = util.copy(layerInfo.properties);

        this.tileset = tilesetInfo;
        this.mapTileSize = mapInfo.get('tileSize');
        this.layerOrientation = mapInfo.get('orientation');

        var offset = this.calculateLayerOffset(layerInfo.get('offset'));
        this.set('position', offset);

        this.set('contentSize', geo.sizeMake(this.layerSize.width * this.mapTileSize.width, (this.layerSize.height * (this.mapTileSize.height - 1)) + this.tileset.tileSize.height));
    },

    calculateLayerOffset: function (pos) {
        var ret = ccp(0, 0);

        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            ret = ccp(pos.x * this.mapTileSize.width, pos.y * this.mapTileSize.height);
            break;
        case TMXOrientationIso:
            // TODO
            break;
        case TMXOrientationHex:
            // TODO
            break;
        }

        return ret;
    },

    setupTiles: function () {
        this.tileset.bindTo('imageSize', this.get('texture'), 'contentSize');


        for (var y = 0; y < this.layerSize.height; y++) {
            for (var x = 0; x < this.layerSize.width; x++) {
                
                var pos = x + this.layerSize.width * y,
                    gid = this.tiles[pos];
                
                if (gid !== 0) {
                    this.appendTile({gid: gid, position: ccp(x, y)});
                    
                    // Optimization: update min and max GID rendered by the layer
                    this.minGID = Math.min(gid, this.minGID);
                    this.maxGID = Math.max(gid, this.maxGID);
                }
            }
        }
    },
    appendTile: function (opts) {
        var gid = opts.gid,
            pos = opts.position;

        var z = pos.x + pos.y * this.layerSize.width;
            
        var rect = this.tileset.rectForGID(gid);
        var tile = Sprite.create({rect: rect, textureAtlas: this.textureAtlas});
        tile.set('position', this.positionAt(pos));
        tile.set('anchorPoint', ccp(0, 0));
        tile.set('opacity', this.get('opacity'));
        
        this.addChild({child: tile, z: 0, tag: z});
    },
    positionAt: function (pos) {
        switch (this.layerOrientation) {
        case TMXOrientationOrtho:
            return this.positionForOrthoAt(pos);
        case TMXOrientationIso:
            return this.positionForIsoAt(pos);
        /*
        case TMXOrientationHex:
            // TODO
        */
        default:
            return ccp(0, 0);
        }
    },
    positionForOrthoAt: function (pos) {
        var overlap = this.mapTileSize.height - this.tileset.tileSize.height;
        var x = Math.floor(pos.x * this.mapTileSize.width + 0.49);
        var y;
        if (FLIP_Y_AXIS) {
            y = Math.floor((this.get('layerSize').height - pos.y - 1) * this.mapTileSize.height + 0.49);
        } else {
            y = Math.floor(pos.y * this.mapTileSize.height + 0.49) + overlap;
        }
        return ccp(x, y);
    },

    positionForIsoAt: function (pos) {
        var mapTileSize = this.get('mapTileSize'),
            layerSize = this.get('layerSize');

        if (FLIP_Y_AXIS) {
            return ccp(
                mapTileSize.width  / 2 * (layerSize.width + pos.x - pos.y - 1),
                mapTileSize.height / 2 * ((layerSize.height * 2 - pos.x - pos.y) - 2)
            );
        } else {
            throw "Isometric tiles without FLIP_Y_AXIS is currently unsupported";
        }
    },


    tileGID: function (pos) {
        var tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);

        return this.tiles[tilePos];
    },
    removeTile: function (pos) {
        var gid = this.tileGID(pos);
        if (gid === 0) {
            // Tile is already blank
            return;
        }

        var tiles = this.get('tiles'),
            tilesPerRow = this.get('layerSize').width,
            tilePos = pos.x + (pos.y * tilesPerRow);


        tiles[tilePos] = 0;

        var sprite = this.getChild({tag: tilePos});
        if (sprite) {
            this.removeChild({child: sprite});
        }
    }
});

exports.TMXLayer = TMXLayer;

}};
__resources__["/__builtin__/libs/cocos2d/nodes/TMXTiledMap.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp,
    Node = require('./Node').Node,
    TMXOrientationOrtho = require('../TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex   = require('../TMXOrientation').TMXOrientationHex,
    TMXOrientationIso   = require('../TMXOrientation').TMXOrientationIso,
    TMXLayer   = require('./TMXLayer').TMXLayer,
    TMXMapInfo = require('../TMXXMLParser').TMXMapInfo;

var TMXTiledMap = Node.extend(/** @lends cocos.nodes.TMXTiledMap# */{
    mapSize: null,
    tileSize: null,
    mapOrientation: 0,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * A TMX Map loaded from a .tmx file
     *
     * @memberOf cocos.nodes
     * @constructs
     * @extends cocos.nodes.Node
     *
     * @opt {String} file The file path of the TMX map to load
     */
    init: function (opts) {
        TMXTiledMap.superclass.init.call(this, opts);

        this.set('anchorPoint', ccp(0, 0));

        var mapInfo = TMXMapInfo.create(opts.file);

        this.mapSize        = mapInfo.get('mapSize');
        this.tileSize       = mapInfo.get('tileSize');
        this.mapOrientation = mapInfo.get('orientation');
        this.objectGroups   = mapInfo.get('objectGroups');
        this.properties     = mapInfo.get('properties');
        this.tileProperties = mapInfo.get('tileProperties');

        // Add layers to map
        var idx = 0;
        util.each(mapInfo.layers, util.callback(this, function (layerInfo) {
            if (layerInfo.get('visible')) {
                var child = this.parseLayer({layerInfo: layerInfo, mapInfo: mapInfo});
                this.addChild({child: child, z: idx, tag: idx});

                var childSize   = child.get('contentSize');
                var currentSize = this.get('contentSize');
                currentSize.width  = Math.max(currentSize.width,  childSize.width);
                currentSize.height = Math.max(currentSize.height, childSize.height);
                this.set('contentSize', currentSize);

                idx++;
            }
        }));
    },
    
    parseLayer: function (opts) {
        var tileset = this.tilesetForLayer(opts);
        var layer = TMXLayer.create({tilesetInfo: tileset, layerInfo: opts.layerInfo, mapInfo: opts.mapInfo});

        layer.setupTiles();

        return layer;
    },

    tilesetForLayer: function (opts) {
        var layerInfo = opts.layerInfo,
            mapInfo = opts.mapInfo,
            size = layerInfo.get('layerSize');

        // Reverse loop
        var tileset;
        for (var i = mapInfo.tilesets.length - 1; i >= 0; i--) {
            tileset = mapInfo.tilesets[i];

            for (var y = 0; y < size.height; y++) {
                for (var x = 0; x < size.width; x++) {
                    var pos = x + size.width * y, 
                        gid = layerInfo.tiles[pos];

                    if (gid !== 0 && gid >= tileset.firstGID) {
                        return tileset;
                    }
                } // for (var x
            } // for (var y
        } // for (var i

        //console.log("cocos2d: Warning: TMX Layer '%s' has no tiles", layerInfo.name);
        return tileset;
    },
    
    /**
     * Return the ObjectGroup for the secific group
     *
     * @opt {String} name The object group name
     * @returns {cocos.TMXObjectGroup} The object group
     */
    objectGroupNamed: function(opts) {
        var objectGroupName = opts.name,
            objectGroup = null;

        this.objectGroups.forEach(function(item) {

            if(item.name == objectGroupName) {
                objectGroup = item;
            }
        });
        if(objectGroup != null) {
            return objectGroup;
        }
    }
});

exports.TMXTiledMap = TMXTiledMap;


}};
__resources__["/__builtin__/libs/cocos2d/Scheduler.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

/** @ignore */
function HashUpdateEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

/** @ignore */
function HashMethodEntry() {
    this.timers = [];
    this.timerIndex = 0;
    this.currentTimer = null;
    this.currentTimerSalvaged = false;
    this.paused = false;
}

var Timer = BObject.extend(/** @lends cocos.Timer# */{
    callback: null,
    interval: 0,
    elapsed: -1,

    /**
     * Runs a function repeatedly at a fixed interval
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {Function} callback The function to run at each interval
     * @opt {Float} interval Number of milliseconds to wait between each exectuion of callback
     */
    init: function (opts) {
        Timer.superclass.init(this, opts);

        this.set('callback', opts.callback);
        this.set('interval', opts.interval || 0);
        this.set('elapsed', -1);
    },

    /**
     * @private
     */
    update: function (dt) {
        if (this.elapsed == -1) {
            this.elapsed = 0;
        } else {
            this.elapsed += dt;
        }

        if (this.elapsed >= this.interval) {
            this.callback(this.elapsed);
            this.elapsed = 0;
        }
    }
});


var Scheduler = BObject.extend(/** @lends cocos.Scheduler# */{
    updates0: null,
    updatesNeg: null,
    updatesPos: null,
    hashForUpdates: null,
    hashForMethods: null,
    timeScale: 1.0,

    /**
     * Runs the timers
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     * @singleton
     * @private
     */
    init: function () {
        this.updates0 = [];
        this.updatesNeg = [];
        this.updatesPos = [];
        this.hashForUpdates = {};
        this.hashForMethods = {};
    },

    schedule: function (opts) {
        var target   = opts.target,
            method   = opts.method,
            interval = opts.interval,
            paused   = opts.paused || false;

        var element = this.hashForMethods[target.get('id')];

        if (!element) {
            element = new HashMethodEntry();
            this.hashForMethods[target.get('id')] = element;
            element.target = target;
            element.paused = paused;
        } else if (element.paused != paused) {
            throw "cocos.Scheduler. Trying to schedule a method with a pause value different than the target";
        }

        var timer = Timer.create({callback: util.callback(target, method), interval: interval});
        element.timers.push(timer);
    },

    scheduleUpdate: function (opts) {
        var target   = opts.target,
            priority = opts.priority,
            paused   = opts.paused;

        var i, len;
        var entry = {target: target, priority: priority, paused: paused};
        var added = false;

        if (priority === 0) {
            this.updates0.push(entry);
        } else if (priority < 0) {
            for (i = 0, len = this.updatesNeg.length; i < len; i++) {
                if (priority < this.updatesNeg[i].priority) {
                    this.updatesNeg.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesNeg.push(entry);
            }
        } else /* priority > 0 */{
            for (i = 0, len = this.updatesPos.length; i < len; i++) {
                if (priority < this.updatesPos[i].priority) {
                    this.updatesPos.splice(i, 0, entry);
                    added = true;
                    break;
                }
            }

            if (!added) {
                this.updatesPos.push(entry);
            }
        }

        this.hashForUpdates[target.get('id')] = entry;
    },

    tick: function (dt) {
        var i, len, x;
        if (this.timeScale != 1.0) {
            dt *= this.timeScale;
        }

        var entry;
        for (i = 0, len = this.updatesNeg.length; i < len; i++) {
            entry = this.updatesNeg[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updates0.length; i < len; i++) {
            entry = this.updates0[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (i = 0, len = this.updatesPos.length; i < len; i++) {
            entry = this.updatesPos[i];
            if (!entry.paused) {
                entry.target.update(dt);
            }
        }

        for (x in this.hashForMethods) {
            if (this.hashForMethods.hasOwnProperty(x)) {
                entry = this.hashForMethods[x];
                for (i = 0, len = entry.timers.length; i < len; i++) {
                    var timer = entry.timers[i];
                    timer.update(dt);
                }
            }
        }

	},

    unscheduleAllSelectorsForTarget: function (target) {
    },

    pauseTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = true;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        if (elementUpdate) {
            elementUpdate.paused = true;
        }
    },

	resumeTarget: function (target) {
        var element = this.hashForMethods[target.get('id')];
        if (element) {
            element.paused = false;
        }

        var elementUpdate = this.hashForUpdates[target.get('id')];
        //console.log('foo', target.get('id'), elementUpdate);
        if (elementUpdate) {
            elementUpdate.paused = false;
        }
	}
});

util.extend(Scheduler, /** @lends cocos.Scheduler */{
    /**
     * A shared singleton instance of cocos.Scheduler
     * @getter sharedScheduler 
     * @type cocos.Scheduler
     */
    get_sharedScheduler: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.Timer = Timer;
exports.Scheduler = Scheduler;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrame.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    ccp = geo.ccp;

var SpriteFrame = BObject.extend(/** @lends cocos.SpriteFrame# */{
    rect: null,
    rotated: false,
    offset: null,
    originalSize: null,
    texture: null,

    /**
     * Represents a single frame of animation for a cocos.Sprite
     *
     * <p>A SpriteFrame has:<br>
     * - texture: A Texture2D that will be used by the Sprite<br>
     * - rectangle: A rectangle of the texture</p>
     *
     * <p>You can modify the frame of a Sprite by doing:</p>
     * 
     * <code>var frame = SpriteFrame.create({texture: texture, rect: rect});
     * sprite.set('displayFrame', frame);</code>
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {cocos.Texture2D} texture The texture to draw this frame using
     * @opt {geometry.Rect} rect The rectangle inside the texture to draw
     */
    init: function (opts) {
        SpriteFrame.superclass.init(this, opts);

        this.texture      = opts.texture;
        this.rect         = opts.rect;
        this.rotated      = !!opts.rotate;
        this.offset       = opts.offset || ccp(0, 0);
        this.originalSize = opts.originalSize || util.copy(this.rect.size);
    },

    /**
     * @ignore
     */
    toString: function () {
        return "[object SpriteFrame | TextureName=" + this.texture.get('name') + ", Rect = (" + this.rect.origin.x + ", " + this.rect.origin.y + ", " + this.rect.size.width + ", " + this.rect.size.height + ")]";
    },

    /**
     * Make a copy of this frame
     *
     * @returns {cocos.SpriteFrame} Exact copy of this object
     */
    copy: function () {
        return SpriteFrame.create({rect: this.rect, rotated: this.rotated, offset: this.offset, originalSize: this.originalSize, texture: this.texture});
    }

});

exports.SpriteFrame = SpriteFrame;

}};
__resources__["/__builtin__/libs/cocos2d/SpriteFrameCache.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    geo = require('geometry'),
    Plist = require('Plist').Plist,
    SpriteFrame = require('./SpriteFrame').SpriteFrame,
    Texture2D = require('./Texture2D').Texture2D;

var SpriteFrameCache = BObject.extend(/** @lends cocos.SpriteFrameCache# */{
    /**
     * List of sprite frames
     * @type Object
     */
    spriteFrames: null,

    /**
     * List of sprite frame aliases
     * @type Object
     */
    spriteFrameAliases: null,


    /**
     * @memberOf cocos
     * @extends BObject
     * @constructs
     * @singleton
     */
    init: function () {
        SpriteFrameCache.superclass.init.call(this);

        this.set('spriteFrames', {});
        this.set('spriteFrameAliases', {});
    },

    /**
     * Add SpriteFrame(s) to the cache
     *
     * @param {String} opts.file The filename of a Zwoptex .plist containing the frame definiitons.
     */
    addSpriteFrames: function (opts) {
        var plistPath = opts.file,
            plist = Plist.create({file: plistPath}),
            plistData = plist.get('data');


        var metaDataDict = plistData.metadata,
            framesDict = plistData.frames;

        var format = 0,
            texturePath = null;

        if (metaDataDict) {
            format = metaDataDict.format;
            // Get texture path from meta data
            texturePath = metaDataDict.textureFileName;
        }

        if (!texturePath) {
            // No texture path so assuming it's the same name as the .plist but ending in .png
            texturePath = plistPath.replace(/\.plist$/i, '.png');
        }


        var texture = Texture2D.create({file: texturePath});

        // Add frames
        for (var frameDictKey in framesDict) {
            if (framesDict.hasOwnProperty(frameDictKey)) {
                var frameDict = framesDict[frameDictKey],
                    spriteFrame = null;

                switch (format) {
                case 0:
                    var x = frameDict.x,
                        y =  frameDict.y,
                        w =  frameDict.width,
                        h =  frameDict.height,
                        ox = frameDict.offsetX,
                        oy = frameDict.offsetY,
                        ow = frameDict.originalWidth,
                        oh = frameDict.originalHeight;

                    // check ow/oh
                    if (!ow || !oh) {
                        //console.log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenerate the .plist");
                    }

                    if (FLIP_Y_AXIS) {
                        oy *= -1;
                    }

                    // abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);

                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(x, y, w, h),
                                                       rotate: false,
                                                       offset: geo.ccp(ox, oy),
                                                 originalSize: geo.sizeMake(ow, oh)});
                    break;

                case 1:
                case 2:
                    var frame      = geo.rectFromString(frameDict.frame),
                        rotated    = !!frameDict.rotated,
                        offset     = geo.pointFromString(frameDict.offset),
                        sourceSize = geo.sizeFromString(frameDict.sourceSize);

                    if (FLIP_Y_AXIS) {
                        offset.y *= -1;
                    }


                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: frame,
                                                       rotate: rotated,
                                                       offset: offset,
                                                 originalSize: sourceSize});
                    break;

                case 3:
                    var spriteSize       = geo.sizeFromString(frameDict.spriteSize),
                        spriteOffset     = geo.pointFromString(frameDict.spriteOffset),
                        spriteSourceSize = geo.sizeFromString(frameDict.spriteSourceSize),
                        textureRect      = geo.rectFromString(frameDict.textureRect),
                        textureRotated   = frameDict.textureRotated;
                    

                    if (FLIP_Y_AXIS) {
                        spriteOffset.y *= -1;
                    }

                    // get aliases
                    var aliases = frameDict.aliases;
                    for (var i = 0, len = aliases.length; i < len; i++) {
                        var alias = aliases[i];
                        this.get('spriteFrameAliases')[frameDictKey] = alias;
                    }
                    
                    // create frame
                    spriteFrame = SpriteFrame.create({texture: texture,
                                                         rect: geo.rectMake(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                                                       rotate: textureRotated,
                                                       offset: spriteOffset,
                                                 originalSize: spriteSourceSize});
                    break;

                default:
                    throw "Unsupported Zwoptex format: " + format;
                }

                // Add sprite frame
                this.get('spriteFrames')[frameDictKey] = spriteFrame;
            }
        }
    },

    /**
     * Get a single SpriteFrame
     *
     * @param {String} opts.name The name of the sprite frame
     * @returns {cocos.SpriteFrame} The sprite frame
     */
    getSpriteFrame: function (opts) {
        var name = opts.name;

        var frame = this.get('spriteFrames')[name];

        if (!frame) {
            // No frame, look for an alias
            var key = this.get('spriteFrameAliases')[name];

            if (key) {
                frame = this.get('spriteFrames')[key];
            }

            if (!frame) {
                throw "Unable to find frame: " + name;
            }
        }

        return frame;
    }
});

/**
 * Class methods
 */
util.extend(SpriteFrameCache, /** @lends cocos.SpriteFrameCache */{
    /**
     * @field
     * @name cocos.SpriteFrameCache.sharedSpriteFrameCache
     * @type cocos.SpriteFrameCache
     */
    get_sharedSpriteFrameCache: function (key) {
        if (!this._instance) {
            this._instance = this.create();
        }

        return this._instance;
    }
});

exports.SpriteFrameCache = SpriteFrameCache;

}};
__resources__["/__builtin__/libs/cocos2d/Texture2D.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var Texture2D = BObject.extend(/** @lends cocos.Texture2D# */{
	imgElement: null,
	size: null,
    name: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} [file] The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     */
	init: function (opts) {
		var file = opts.file,
			data = opts.data,
			texture = opts.texture;

		if (file) {
            this.name = file;
			data = resource(file);
		} else if (texture) {
            this.name = texture.get('name');
			data = texture.get('imgElement');
		}

		this.size = {width: 0, height: 0};

		this.set('imgElement', data);
		this.set('size', {width: this.imgElement.width, height: this.imgElement.height});
	},

	drawAtPoint: function (ctx, point) {
		ctx.drawImage(this.imgElement, point.x, point.y);
	},
	drawInRect: function (ctx, rect) {
		ctx.drawImage(this.imgElement,
			rect.origin.x, rect.origin.y,
			rect.size.width, rect.size.height
		);
	},

    /**
     * @getter data
     * @type {String} Base64 encoded image data
     */
    get_data: function () {
        return this.imgElement ? this.imgElement.src : null;
	},

    /**
     * @getter contentSize
     * @type {geometry.Size} Size of the texture
     */
    get_contentSize: function () {
		return this.size;
    }
});

exports.Texture2D = Texture2D;

}};
__resources__["/__builtin__/libs/cocos2d/TextureAtlas.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray FLIP_Y_AXIS*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
	Texture2D = require('./Texture2D').Texture2D;


/* QUAD STRUCTURE
 quad = {
	 drawRect: <rect>, // Where the quad is drawn to
	 textureRect: <rect>  // The slice of the texture to draw in drawRect
 }
*/

var TextureAtlas = BObject.extend(/** @lends cocos.TextureAtlas# */{
	quads: null,
	imgElement: null,
	texture: null,

    /**
     * A single texture that can represent lots of smaller images
     *
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @opt {String} file The file path of the image to use as a texture
     * @opt {Texture2D|HTMLImageElement} [data] Image data to read from
     * @opt {CanvasElement} [canvas] A canvas to use as a texture
     */
	init: function (opts) {
		var file = opts.file,
			data = opts.data,
			texture = opts.texture,
			canvas = opts.canvas;

        if (canvas) {
            // If we've been given a canvas element then we'll use that for our image
            this.imgElement = canvas;
        } else {
            texture = Texture2D.create({texture: texture, file: file, data: data});
			this.set('texture', texture);
			this.imgElement = texture.get('imgElement');
        }

		this.quads = [];
	},

	insertQuad: function (opts) {
		var quad = opts.quad,
			index = opts.index || 0;

		this.quads.splice(index, 0, quad);
	},
	removeQuad: function (opts) {
		var index = opts.index;

		this.quads.splice(index, 1);
	},


	drawQuads: function (ctx) {
		util.each(this.quads, util.callback(this, function (quad) {
            if (!quad) {
                return;
            }

			this.drawQuad(ctx, quad);
		}));
	},

	drawQuad: function (ctx, quad) {
        var sx = quad.textureRect.origin.x,
            sy = quad.textureRect.origin.y,
            sw = quad.textureRect.size.width, 
            sh = quad.textureRect.size.height;

        var dx = quad.drawRect.origin.x,
            dy = quad.drawRect.origin.y,
            dw = quad.drawRect.size.width, 
            dh = quad.drawRect.size.height;


        var scaleX = 1;
        var scaleY = 1;

        if (FLIP_Y_AXIS) {
            dy -= dh;
            dh *= -1;
        }

            
        if (dw < 0) {
            dw *= -1;
            scaleX = -1;
        }
            
        if (dh < 0) {
            dh *= -1;
            scaleY = -1;
        }

        ctx.scale(scaleX, scaleY);

        var img = this.get('imgElement');
		ctx.drawImage(img, 
			sx, sy, // Draw slice from x,y
			sw, sh, // Draw slice size
			dx, dy, // Draw at 0, 0
			dw, dh  // Draw size
		);
        ctx.scale(1, 1);
	}
});

exports.TextureAtlas = TextureAtlas;

}};
__resources__["/__builtin__/libs/cocos2d/TMXOrientation.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

/**
 * @memberOf cocos
 * @namespace
 */
var TMXOrientation = /** @lends cocos.TMXOrientation */{
    /**
     * Orthogonal orientation
     * @constant
     */
	TMXOrientationOrtho: 1,

    /**
     * Hexagonal orientation
     * @constant
     */
	TMXOrientationHex: 2,

    /**
     * Isometric orientation
     * @constant
     */
	TMXOrientationIso: 3
};

module.exports = TMXOrientation;

}};
__resources__["/__builtin__/libs/cocos2d/TMXXMLParser.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray DOMParser*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util'),
    path = require('path'),
    ccp = require('geometry').ccp,
    base64 = require('base64'),
    gzip   = require('gzip'),
    TMXOrientationOrtho = require('./TMXOrientation').TMXOrientationOrtho,
    TMXOrientationHex = require('./TMXOrientation').TMXOrientationHex,
    TMXOrientationIso = require('./TMXOrientation').TMXOrientationIso;

var TMXTilesetInfo = BObject.extend(/** @lends cocos.TMXTilesetInfo# */{
    name: '',
    firstGID: 0,
    tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXTilesetInfo.superclass.init.call(this);
    },

    rectForGID: function (gid) {
        var rect = {size: {}, origin: ccp(0, 0)};
        rect.size = util.copy(this.tileSize);
        
        gid = gid - this.firstGID;

        var imgSize = this.get('imageSize');
        
        var maxX = Math.floor((imgSize.width - this.margin * 2 + this.spacing) / (this.tileSize.width + this.spacing));
        
        rect.origin.x = (gid % maxX) * (this.tileSize.width + this.spacing) + this.margin;
        rect.origin.y = Math.floor(gid / maxX) * (this.tileSize.height + this.spacing) + this.margin;
        
        return rect;
    }
});

var TMXLayerInfo = BObject.extend(/** @lends cocos.TMXLayerInfo# */{
    name: '',
    layerSize: null,
    tiles: null,
    visible: true,
    opacity: 255,
    minGID: 100000,
    maxGID: 0,
    properties: null,
    offset: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXLayerInfo.superclass.init.call(this);

        this.properties = {};
        this.offset = ccp(0, 0);
    }
});

var TMXObjectGroup = BObject.extend(/** @lends cocos.TMXObjectGroup# */{
    name: '',
    properties: null,
    offset: null,
    objects: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     */
    init: function () {
        TMXObjectGroup.superclass.init.call(this);

        this.properties = {};
        this.objects = {};
        this.offset = ccp(0, 0);
    },

    /**
     * return the value for the specific property name
     *
     * @opt {String} name Property name
     * @returns {String} Property value
     */
    propertyNamed: function(opts) {
        var propertyName = opts.name
        return this.properties[propertyName];
    },

    /**
     * Return the object for the specific object name. It will return the 1st
     * object found on the array for the given name.
     *
     * @opt {String} name Object name
     * @returns {Object} Object
     */
    objectNamed: function(opts) {
        var objectName = opts.name;
        var object = null;
        
        this.objects.forEach(function(item) {
         
            if(item.name == objectName) {
                object = item;
            }
        });
        if(object != null) {
            return object;
        }
    }
});

var TMXMapInfo = BObject.extend(/** @lends cocos.TMXMapInfo# */{
    filename: '',
    orientation: 0,
    mapSize: null,
    tileSize: null,
    layer: null,
    tilesets: null,
    objectGroups: null,
    properties: null,
    tileProperties: null,

    /**
     * @memberOf cocos
     * @constructs
     * @extends BObject
     *
     * @param {String} tmxFile The file path of the TMX file to load
     */
    init: function (tmxFile) {
        TMXMapInfo.superclass.init.call(this, tmxFile);

        this.tilesets = [];
        this.layers = [];
        this.objectGroups = [];
        this.properties = {};
        this.tileProperties = {};
        this.filename = tmxFile;

        this.parseXMLFile(tmxFile);
    },

    parseXMLFile: function (xmlFile) {
        var parser = new DOMParser(),
            doc = parser.parseFromString(resource(xmlFile), 'text/xml');

        // PARSE <map>
        var map = doc.documentElement;

        // Set Orientation
        switch (map.getAttribute('orientation')) {
        case 'orthogonal':
            this.orientation = TMXOrientationOrtho;
            break;
        case 'isometric':
            this.orientation = TMXOrientationIso;
            break;
        case 'hexagonal':
            this.orientation = TMXOrientationHex;
            break;
        default:
            throw "cocos2d: TMXFomat: Unsupported orientation: " + map.getAttribute('orientation');
        }
        this.mapSize = {width: parseInt(map.getAttribute('width'), 10), height: parseInt(map.getAttribute('height'), 10)};
        this.tileSize = {width: parseInt(map.getAttribute('tilewidth'), 10), height: parseInt(map.getAttribute('tileheight'), 10)};


        // PARSE <tilesets>
        var tilesets = map.getElementsByTagName('tileset');
        var i, len, s;
        for (i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];

            var tileset = TMXTilesetInfo.create();
            tileset.set('name', t.getAttribute('name'));
            tileset.set('firstGID', parseInt(t.getAttribute('firstgid'), 10));
            if (t.getAttribute('spacing')) {
                tileset.set('spacing', parseInt(t.getAttribute('spacing'), 10));
            }
            if (t.getAttribute('margin')) {
                tileset.set('margin', parseInt(t.getAttribute('margin'), 10));
            }

            s = {};
            s.width = parseInt(t.getAttribute('tilewidth'), 10);
            s.height = parseInt(t.getAttribute('tileheight'), 10);
            tileset.set('tileSize', s);

            // PARSE <image> We assume there's only 1
            var image = t.getElementsByTagName('image')[0];
            tileset.set('sourceImage', path.join(path.dirname(this.filename), image.getAttribute('source')));

            this.tilesets.push(tileset);
        }

        // PARSE <layers>
        var layers = map.getElementsByTagName('layer');
        for (i = 0, len = layers.length; i < len; i++) {
            var l = layers[i];
            var data = l.getElementsByTagName('data')[0];
            var layer = TMXLayerInfo.create();

            layer.set('name', l.getAttribute('name'));
            if (l.getAttribute('visible') !== false) {
                layer.set('visible', true);
            } else {
                layer.set('visible', !!parseInt(l.getAttribute('visible'), 10));
            }

            s = {};
            s.width = parseInt(l.getAttribute('width'), 10);
            s.height = parseInt(l.getAttribute('height'), 10);
            layer.set('layerSize', s);

            var opacity = l.getAttribute('opacity');
            if (opacity === undefined) {
                layer.set('opacity', 255);
            } else {
                layer.set('opacity', 255 * parseFloat(opacity));
            }

            var x = parseInt(l.getAttribute('x'), 10),
                y = parseInt(l.getAttribute('y'), 10);
            if (isNaN(x)) {
                x = 0;
            }
            if (isNaN(y)) {
                y = 0;
            }
            layer.set('offset', ccp(x, y));


            // Firefox has a 4KB limit on node values. It will split larger
            // nodes up into multiple nodes. So, we'll stitch them back
            // together.
            var nodeValue = '';
            for (var j = 0, jen = data.childNodes.length; j < jen; j++) {
                nodeValue += data.childNodes[j].nodeValue;
            }

            // Unpack the tilemap data
            var compression = data.getAttribute('compression');
            switch (compression) {
            case 'gzip':
                layer.set('tiles', gzip.unzipBase64AsArray(nodeValue, 4));
                break;
                
            // Uncompressed
            case null:
            case '': 
                layer.set('tiles', base64.decodeAsArray(nodeValue, 4));
                break;

            default: 
                throw "Unsupported TMX Tile Map compression: " + compression;
            }

            this.layers.push(layer);
        }

        // TODO PARSE <tile>

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        for (i = 0, len = objectgroups.length; i < len; i++) {
            var g = objectgroups[i],
                objectGroup = TMXObjectGroup.create();

            objectGroup.set('name', g.getAttribute('name'));
            
            var properties = g.querySelectorAll('objectgroup > properties property'),
                propertiesValue = {};
            
            for(j = 0; j < properties.length; j++) {
                var property = properties[j];
                if(property.getAttribute('name')) {
                    propertiesValue[property.getAttribute('name')] = property.getAttribute('value');
                }
            }
           
            objectGroup.set('properties', propertiesValue);

            var objectsArray = [],
                objects = g.querySelectorAll('object');

            for(j = 0; j < objects.length; j++) {
                var object = objects[j];
                var objectValue = {
                    x       : parseInt(object.getAttribute('x'), 10),
                    y       : parseInt(object.getAttribute('y'), 10),
                    width   : parseInt(object.getAttribute('width'), 10),
                    height  : parseInt(object.getAttribute('height'), 10)
                };
                if(object.getAttribute('name')) {
                    objectValue.name = object.getAttribute('name');
                }
                if(object.getAttribute('type')) {
                    objectValue.name = object.getAttribute('type');
                }
                properties = object.querySelectorAll('property');
                for(var k = 0; k < properties.length; k++) {
                    property = properties[k];
                    if(property.getAttribute('name')) {
                        objectValue[property.getAttribute('name')] = property.getAttribute('value');
                    }
                }
                objectsArray.push(objectValue);

            }
            objectGroup.set('objects', objectsArray);
            this.objectGroups.push(objectGroup);
        }
    }
});

exports.TMXMapInfo = TMXMapInfo;
exports.TMXLayerInfo = TMXLayerInfo;
exports.TMXTilesetInfo = TMXTilesetInfo;
exports.TMXObjectGroup = TMXObjectGroup;
}};
__resources__["/__builtin__/libs/geometry.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*globals module exports resource require BObject BArray*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

var util = require('util');

var RE_PAIR = /\{\s*([\d.\-]+)\s*,\s*([\d.\-]+)\s*\}/,
    RE_DOUBLE_PAIR = /\{\s*(\{[\s\d,.\-]+\})\s*,\s*(\{[\s\d,.\-]+\})\s*\}/;

/** @namespace */
var geometry = {
    /**
     * @class
     * A 2D point in space
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     */
    Point: function (x, y) {
        /**
         * X coordinate
         * @type Float
         */
        this.x = x;

        /**
         * Y coordinate
         * @type Float
         */
        this.y = y;
    },

    /**
     * @class
     * A 2D size
     *
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Size: function (w, h) {
        /**
         * Width
         * @type Float
         */
        this.width = w;

        /**
         * Height
         * @type Float
         */
        this.height = h;
    },

    /**
     * @class
     * A rectangle
     *
     * @param {Float} x X value
     * @param {Float} y Y value
     * @param {Float} w Width
     * @param {Float} h Height
     */
    Rect: function (x, y, w, h) {
        /**
         * Coordinate in 2D space
         * @type {geometry.Point}
         */
        this.origin = new geometry.Point(x, y);

        /**
         * Size in 2D space
         * @type {geometry.Size}
         */
        this.size   = new geometry.Size(w, h);
    },

    /**
     * @class
     * Transform matrix
     *
     * @param {Float} a
     * @param {Float} b
     * @param {Float} c
     * @param {Float} d
     * @param {Float} tx
     * @param {Float} ty
     */
    TransformMatrix: function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    },

    /**
     * Creates a geometry.Point instance
     *
     * @param {Float} x X coordinate
     * @param {Float} y Y coordinate
     * @returns {geometry.Point} 
     */
    ccp: function (x, y) {
        return module.exports.pointMake(x, y);
    },

    /**
     * Add the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpAdd: function (p1, p2) {
        return geometry.ccp(p1.x + p2.x, p1.y + p2.y);
    },

    /**
     * Subtract the values of two points
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpSub: function (p1, p2) {
        return geometry.ccp(p1.x - p2.x, p1.y - p2.y);
    },

    /**
     * Muliply the values of two points together
     *
     * @param {geometry.Point} p1 First point
     * @param {geometry.Point} p2 Second point
     * @returns {geometry.Point} New point
     */
    ccpMult: function (p1, p2) {
        return geometry.ccp(p1.x * p2.x, p1.y * p2.y);
    },


    /**
     * Invert the values of a geometry.Point
     *
     * @param {geometry.Point} p Point to invert
     * @returns {geometry.Point} New point
     */
    ccpNeg: function (p) {
        return geometry.ccp(-p.x, -p.y);
    },

    /**
     * Round values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpRound: function (p) {
        return geometry.ccp(Math.round(p.x), Math.round(p.y));
    },

    /**
     * Round up values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpCeil: function (p) {
        return geometry.ccp(Math.ceil(p.x), Math.ceil(p.y));
    },

    /**
     * Round down values on a geometry.Point to whole numbers
     *
     * @param {geometry.Point} p Point to round
     * @returns {geometry.Point} New point
     */
    ccpFloor: function (p) {
        return geometry.ccp(Math.floor(p.x), Math.floor(p.y));
    },

    /**
     * A point at 0x0
     *
     * @returns {geometry.Point} New point at 0x0
     */
    PointZero: function () {
        return geometry.ccp(0, 0);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectMake: function (x, y, w, h) {
        return new geometry.Rect(x, y, w, h);
    },

    /**
     * @returns {geometry.Rect}
     */
    rectFromString: function (str) {
        var matches = str.match(RE_DOUBLE_PAIR),
            p = geometry.pointFromString(matches[1]),
            s = geometry.sizeFromString(matches[2]);

        return geometry.rectMake(p.x, p.y, s.width, s.height);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeMake: function (w, h) {
        return new geometry.Size(w, h);
    },

    /**
     * @returns {geometry.Size}
     */
    sizeFromString: function (str) {
        var matches = str.match(RE_PAIR),
            w = parseFloat(matches[1]),
            h = parseFloat(matches[2]);

        return geometry.sizeMake(w, h);
    },

    /**
     * @returns {geometry.Point}
     */
    pointMake: function (x, y) {
        return new geometry.Point(x, y);
    },

    /**
     * @returns {geometry.Point}
     */
    pointFromString: function (str) {
        var matches = str.match(RE_PAIR),
            x = parseFloat(matches[1]),
            y = parseFloat(matches[2]);

        return geometry.pointMake(x, y);
    },

    /**
     * @returns {Boolean}
     */
    rectContainsPoint: function (r, p) {
        return ((p.x >= r.origin.x && p.x <= r.origin.x + r.size.width) &&
                (p.y >= r.origin.y && p.y <= r.origin.y + r.size.height));
    },

    /**
     * Returns the smallest rectangle that contains the two source rectangles.
     *
     * @param {geometry.Rect} r1
     * @param {geometry.Rect} r2
     * @returns {geometry.Rect}
     */
    rectUnion: function (r1, r2) {
        var rect = new geometry.Rect(0, 0, 0, 0);

        rect.origin.x = Math.min(r1.origin.x, r2.origin.x);
        rect.origin.y = Math.min(r1.origin.y, r2.origin.y);
        rect.size.width = Math.max(r1.origin.x + r1.size.width, r2.origin.x + r2.size.width) - rect.origin.x;
        rect.size.height = Math.max(r1.origin.y + r1.size.height, r2.origin.y + r2.size.height) - rect.origin.y;

        return rect;
    },

    /**
     * @returns {Boolean}
     */
    rectOverlapsRect: function (r1, r2) {
        if (r1.origin.x + r1.size.width < r2.origin.x) {
            return false;
        }
        if (r2.origin.x + r2.size.width < r1.origin.x) {
            return false;
        }
        if (r1.origin.y + r1.size.height < r2.origin.y) {
            return false;
        }
        if (r2.origin.y + r2.size.height < r1.origin.y) {
            return false;
        }

        return true;
    },

    /**
     * Returns the overlapping portion of 2 rectangles
     *
     * @param {geometry.Rect} lhsRect First rectangle
     * @param {geometry.Rect} rhsRect Second rectangle
     * @returns {geometry.Rect} The overlapping portion of the 2 rectangles
     */
    rectIntersection: function (lhsRect, rhsRect) {

        var intersection = new geometry.Rect(
            Math.max(geometry.rectGetMinX(lhsRect), geometry.rectGetMinX(rhsRect)),
            Math.max(geometry.rectGetMinY(lhsRect), geometry.rectGetMinY(rhsRect)),
            0,
            0
        );

        intersection.size.width = Math.min(geometry.rectGetMaxX(lhsRect), geometry.rectGetMaxX(rhsRect)) - geometry.rectGetMinX(intersection);
        intersection.size.height = Math.min(geometry.rectGetMaxY(lhsRect), geometry.rectGetMaxY(rhsRect)) - geometry.rectGetMinY(intersection);

        return intersection;
    },

    /**
     * @returns {Boolean}
     */
    pointEqualToPoint: function (point1, point2) {
        return (point1.x == point2.x && point1.y == point2.y);
    },

    /**
     * @returns {Boolean}
     */
    sizeEqualToSize: function (size1, size2) {
        return (size1.width == size2.width && size1.height == size2.height);
    },

    /**
     * @returns {Boolean}
     */
    rectEqualToRect: function (rect1, rect2) {
        return (module.exports.sizeEqualToSize(rect1.size, rect2.size) && module.exports.pointEqualToPoint(rect1.origin, rect2.origin));
    },

    /**
     * @returns {Float}
     */
    rectGetMinX: function (rect) {
        return rect.origin.x;
    },

    /**
     * @returns {Float}
     */
    rectGetMinY: function (rect) {
        return rect.origin.y;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxX: function (rect) {
        return rect.origin.x + rect.size.width;
    },

    /**
     * @returns {Float}
     */
    rectGetMaxY: function (rect) {
        return rect.origin.y + rect.size.height;
    },

    boundingRectMake: function (p1, p2, p3, p4) {
        var minX = Math.min(p1.x, p2.x, p3.x, p4.x);
        var minY = Math.min(p1.y, p2.y, p3.y, p4.y);
        var maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
        var maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

        return new geometry.Rect(minX, minY, (maxX - minX), (maxY - minY));
    },

    /**
     * @returns {geometry.Point}
     */
    pointApplyAffineTransform: function (point, t) {

        /*
        aPoint.x * aTransform.a + aPoint.y * aTransform.c + aTransform.tx,
        aPoint.x * aTransform.b + aPoint.y * aTransform.d + aTransform.ty
        */

        return new geometry.Point(t.a * point.x + t.c * point.y + t.tx, t.b * point.x + t.d * point.y + t.ty);

    },

    /**
     * Apply a transform matrix to a rectangle
     *
     * @param {geometry.Rect} rect Rectangle to transform
     * @param {geometry.TransformMatrix} trans TransformMatrix to apply to rectangle
     * @returns {geometry.Rect} A new transformed rectangle
     */
    rectApplyAffineTransform: function (rect, trans) {

        var p1 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMinY(rect));
        var p2 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMinY(rect));
        var p3 = geometry.ccp(geometry.rectGetMinX(rect), geometry.rectGetMaxY(rect));
        var p4 = geometry.ccp(geometry.rectGetMaxX(rect), geometry.rectGetMaxY(rect));

        p1 = geometry.pointApplyAffineTransform(p1, trans);
        p2 = geometry.pointApplyAffineTransform(p2, trans);
        p3 = geometry.pointApplyAffineTransform(p3, trans);
        p4 = geometry.pointApplyAffineTransform(p4, trans);

        return geometry.boundingRectMake(p1, p2, p3, p4);
    },

    /**
     * Inverts a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to invert
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformInvert: function (trans) {
        var determinant = 1 / (trans.a * trans.d - trans.b * trans.c);

        return new geometry.TransformMatrix(
            determinant * trans.d,
            -determinant * trans.b,
            -determinant * trans.c,
            determinant * trans.a,
            determinant * (trans.c * trans.ty - trans.d * trans.tx),
            determinant * (trans.b * trans.tx - trans.a * trans.ty)
        );
    },

    /**
     * Multiply 2 transform matrices together
     * @param {geometry.TransformMatrix} lhs Left matrix
     * @param {geometry.TransformMatrix} rhs Right matrix
     * @returns {geometry.TransformMatrix} New transform matrix
     */
    affineTransformConcat: function (lhs, rhs) {
        return new geometry.TransformMatrix(
            lhs.a * rhs.a + lhs.b * rhs.c,
            lhs.a * rhs.b + lhs.b * rhs.d,
            lhs.c * rhs.a + lhs.d * rhs.c,
            lhs.c * rhs.b + lhs.d * rhs.d,
            lhs.tx * rhs.a + lhs.ty * rhs.c + rhs.tx,
            lhs.tx * rhs.b + lhs.ty * rhs.d + rhs.ty
        );
    },

    /**
     * @returns {Float}
     */
    degreesToRadians: function (angle) {
        return angle / 180.0 * Math.PI;
    },

    /**
     * @returns {Float}
     */
    radiansToDegrees: function (angle) {
        return angle * (180.0 / Math.PI);
    },

    /**
     * Translate (move) a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to translate
     * @param {Float} tx Amount to translate along X axis
     * @param {Float} ty Amount to translate along Y axis
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformTranslate: function (trans, tx, ty) {
        var newTrans = util.copy(trans);
        newTrans.tx = trans.tx + trans.a * tx + trans.c * ty;
        newTrans.ty = trans.ty + trans.b * tx + trans.d * ty;
        return newTrans;
    },

    /**
     * Rotate a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to rotate
     * @param {Float} angle Angle in radians
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformRotate: function (trans, angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        return new geometry.TransformMatrix(
            trans.a * cos + trans.c * sin,
            trans.b * cos + trans.d * sin,
            trans.c * cos - trans.a * sin,
            trans.d * cos - trans.b * sin,
            trans.tx,
            trans.ty
        );
    },

    /**
     * Scale a transform matrix
     *
     * @param {geometry.TransformMatrix} trans TransformMatrix to scale
     * @param {Float} sx X scale factor
     * @param {Float} [sy=sx] Y scale factor
     * @returns {geometry.TransformMatrix} A new TransformMatrix
     */
    affineTransformScale: function (trans, sx, sy) {
        if (sy === undefined) {
            sy = sx;
        }

        return new geometry.TransformMatrix(trans.a * sx, trans.b * sx, trans.c * sy, trans.d * sy, trans.tx, trans.ty);
    },

    /**
     * @returns {geometry.TransformMatrix} identity matrix
     */
    affineTransformIdentity: function () {
        return new geometry.TransformMatrix(1, 0, 0, 1, 0, 0);
    }
};

module.exports = geometry;

}};
__resources__["/__builtin__/libs/gzip.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * @fileoverview 
 */

/** @ignore */
var JXG = require('./JXGUtil');

/**
 * @namespace
 * Wrappers around JXG's GZip utils
 * @see JXG.Util
 */
var gzip = {
    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @returns {String} Unpacked byte string
     */
    unzip: function(input) {
        return (new JXG.Util.Unzip(input)).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @returns {String} Unpacked byte string
     */
    unzipBase64: function(input) {
        return (new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(input))).unzip()[0][0];
    },

    /**
     * Unpack a gzipped byte string encoded as base64
     *
     * @param {String} input Byte string encoded as base64
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipBase64AsArray: function(input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzipBase64(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    },

    /**
     * Unpack a gzipped byte array
     *
     * @param {Integer[]} input Byte array
     * @param {Integer} bytes Bytes per array item
     * @returns {Integer[]} Unpacked byte array
     */
    unzipAsArray: function (input, bytes) {
        bytes = bytes || 1;

        var dec = this.unzip(input),
            ar = [], i, j, len;
        for (i = 0, len = dec.length/bytes; i < len; i++){
            ar[i] = 0;
            for (j = bytes-1; j >= 0; --j){
                ar[i] += dec.charCodeAt((i *bytes) +j) << (j *8);
            }
        }
        return ar;
    }

};

module.exports = gzip;

}};
__resources__["/__builtin__/libs/JXGUtil.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @fileoverview Utilities for uncompressing and base64 decoding
 */

/** @namespace */
var JXG = {};

/**
  * @class Util class
  * Class for gunzipping, unzipping and base64 decoding of files.
  * It is used for reading GEONExT, Geogebra and Intergeo files.
  *
  * Only Huffman codes are decoded in gunzip.
  * The code is based on the source code for gunzip.c by Pasi Ojala 
  * @see <a href="http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c">http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c</a>
  * @see <a href="http://www.cs.tut.fi/~albert">http://www.cs.tut.fi/~albert</a>
  */
JXG.Util = {};
                                 
/**
 * Unzip zip files
 */
JXG.Util.Unzip = function (barray){
    var outputArr = [],
        output = "",
        debug = false,
        gpflags,
        files = 0,
        unzipped = [],
        crc,
        buf32k = new Array(32768),
        bIdx = 0,
        modeZIP=false,

        CRC, SIZE,
    
        bitReverse = [
        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    ],
    
    cplens = [
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ],

    cplext = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
    ], /* 99==invalid */

    cpdist = [
        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
        0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
        0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
        0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
    ],

    cpdext = [
        0,  0,  0,  0,  1,  1,  2,  2,
        3,  3,  4,  4,  5,  5,  6,  6,
        7,  7,  8,  8,  9,  9, 10, 10,
        11, 11, 12, 12, 13, 13
    ],
    
    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    
    bA = barray,

    bytepos=0,
    bitpos=0,
    bb = 1,
    bits=0,
    
    NAMEMAX = 256,
    
    nameBuf = [],
    
    fileout;
    
    function readByte(){
        bits+=8;
        if (bytepos<bA.length){
            //if (debug)
            //    document.write(bytepos+": "+bA[bytepos]+"<br>");
            return bA[bytepos++];
        } else
            return -1;
    };

    function byteAlign(){
        bb = 1;
    };
    
    function readBit(){
        var carry;
        bits++;
        carry = (bb & 1);
        bb >>= 1;
        if (bb==0){
            bb = readByte();
            carry = (bb & 1);
            bb = (bb>>1) | 0x80;
        }
        return carry;
    };

    function readBits(a) {
        var res = 0,
            i = a;
    
        while(i--) {
            res = (res<<1) | readBit();
        }
        if(a) {
            res = bitReverse[res]>>(8-a);
        }
        return res;
    };
        
    function flushBuffer(){
        //document.write('FLUSHBUFFER:'+buf32k);
        bIdx = 0;
    };
    function addBuffer(a){
        SIZE++;
        //CRC=updcrc(a,crc);
        buf32k[bIdx++] = a;
        outputArr.push(String.fromCharCode(a));
        //output+=String.fromCharCode(a);
        if(bIdx==0x8000){
            //document.write('ADDBUFFER:'+buf32k);
            bIdx=0;
        }
    };
    
    function HufNode() {
        this.b0=0;
        this.b1=0;
        this.jump = null;
        this.jumppos = -1;
    };

    var LITERALS = 288;
    
    var literalTree = new Array(LITERALS);
    var distanceTree = new Array(32);
    var treepos=0;
    var Places = null;
    var Places2 = null;
    
    var impDistanceTree = new Array(64);
    var impLengthTree = new Array(64);
    
    var len = 0;
    var fpos = new Array(17);
    fpos[0]=0;
    var flens;
    var fmax;
    
    function IsPat() {
        while (1) {
            if (fpos[len] >= fmax)
                return -1;
            if (flens[fpos[len]] == len)
                return fpos[len]++;
            fpos[len]++;
        }
    };

    function Rec() {
        var curplace = Places[treepos];
        var tmp;
        if (debug)
    		document.write("<br>len:"+len+" treepos:"+treepos);
        if(len==17) { //war 17
            return -1;
        }
        treepos++;
        len++;
    	
        tmp = IsPat();
        if (debug)
        	document.write("<br>IsPat "+tmp);
        if(tmp >= 0) {
            curplace.b0 = tmp;    /* leaf cell for 0-bit */
            if (debug)
            	document.write("<br>b0 "+curplace.b0);
        } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        if (debug)
        	document.write("<br>b0 "+curplace.b0);
        if(Rec())
            return -1;
        }
        tmp = IsPat();
        if(tmp >= 0) {
            curplace.b1 = tmp;    /* leaf cell for 1-bit */
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = null;    /* Just for the display routine */
        } else {
            /* Not a Leaf cell */
            curplace.b1 = 0x8000;
            if (debug)
            	document.write("<br>b1 "+curplace.b1);
            curplace.jump = Places[treepos];
            curplace.jumppos = treepos;
            if(Rec())
                return -1;
        }
        len--;
        return 0;
    };

    function CreateTree(currentTree, numval, lengths, show) {
        var i;
        /* Create the Huffman decode tree/table */
        //document.write("<br>createtree<br>");
        if (debug)
        	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
        Places = currentTree;
        treepos=0;
        flens = lengths;
        fmax  = numval;
        for (i=0;i<17;i++)
            fpos[i] = 0;
        len = 0;
        if(Rec()) {
            //fprintf(stderr, "invalid huffman tree\n");
            if (debug)
            	alert("invalid huffman tree\n");
            return -1;
        }
        if (debug){
        	document.write('<br>Tree: '+Places.length);
        	for (var a=0;a<32;a++){
            	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
            	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
        	}
        }

        return 0;
    };
    
    function DecodeValue(currentTree) {
        var len, i,
            xtreepos=0,
            X = currentTree[xtreepos],
            b;

        /* decode one symbol of the data */
        while(1) {
            b=readBit();
            if (debug)
            	document.write("b="+b);
            if(b) {
                if(!(X.b1 & 0x8000)){
                	if (debug)
                    	document.write("ret1");
                    return X.b1;    /* If leaf node, return data */
                }
                X = X.jump;
                len = currentTree.length;
                for (i=0;i<len;i++){
                    if (currentTree[i]===X){
                        xtreepos=i;
                        break;
                    }
                }
                //xtreepos++;
            } else {
                if(!(X.b0 & 0x8000)){
                	if (debug)
                    	document.write("ret2");
                    return X.b0;    /* If leaf node, return data */
                }
                //X++; //??????????????????
                xtreepos++;
                X = currentTree[xtreepos];
            }
        }
        if (debug)
        	document.write("ret3");
        return -1;
    };
    
    function DeflateLoop() {
    var last, c, type, i, len;

    do {
        /*if((last = readBit())){
            fprintf(errfp, "Last Block: ");
        } else {
            fprintf(errfp, "Not Last Block: ");
        }*/
        last = readBit();
        type = readBits(2);
        switch(type) {
            case 0:
            	if (debug)
                	alert("Stored\n");
                break;
            case 1:
            	if (debug)
                	alert("Fixed Huffman codes\n");
                break;
            case 2:
            	if (debug)
                	alert("Dynamic Huffman codes\n");
                break;
            case 3:
            	if (debug)
                	alert("Reserved block type!!\n");
                break;
            default:
            	if (debug)
                	alert("Unexpected value %d!\n", type);
                break;
        }

        if(type==0) {
            var blockLen, cSum;

            // Stored 
            byteAlign();
            blockLen = readByte();
            blockLen |= (readByte()<<8);

            cSum = readByte();
            cSum |= (readByte()<<8);

            if(((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n");
            }
            while(blockLen--) {
                c = readByte();
                addBuffer(c);
            }
        } else if(type==1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while(1) {
            /*
                256    0000000        0
                :   :     :
                279    0010111        23
                0   00110000    48
                :    :      :
                143    10111111    191
                280 11000000    192
                :    :      :
                287 11000111    199
                144    110010000    400
                :    :       :
                255    111111111    511
    
                Note the bit order!
                */

            j = (bitReverse[readBits(7)]>>1);
            if(j > 23) {
                j = (j<<1) | readBit();    /* 48..255 */

                if(j > 199) {    /* 200..255 */
                    j -= 128;    /*  72..127 */
                    j = (j<<1) | readBit();        /* 144..255 << */
                } else {        /*  48..199 */
                    j -= 48;    /*   0..151 */
                    if(j > 143) {
                        j = j+136;    /* 280..287 << */
                        /*   0..143 << */
                    }
                }
            } else {    /*   0..23 */
                j += 256;    /* 256..279 << */
            }
            if(j < 256) {
                addBuffer(j);
                //document.write("out:"+String.fromCharCode(j));
                /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
            } else if(j == 256) {
                /* EOF */
                break;
            } else {
                var len, dist;

                j -= 256 + 1;    /* bytes + EOF */
                len = readBits(cplext[j]) + cplens[j];

                j = bitReverse[readBits(5)]>>3;
                if(cpdext[j] > 8) {
                    dist = readBits(8);
                    dist |= (readBits(cpdext[j]-8)<<8);
                } else {
                    dist = readBits(cpdext[j]);
                }
                dist += cpdist[j];

                /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
                for(j=0;j<len;j++) {
                    var c = buf32k[(bIdx - dist) & 0x7fff];
                    addBuffer(c);
                }
            }
            } // while
        } else if(type==2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288+32);    // "static" just to preserve stack
    
            // Dynamic Huffman tables 
    
            literalCodes = 257 + readBits(5);
            distCodes = 1 + readBits(5);
            lenCodes = 4 + readBits(4);
            //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
            for(j=0; j<19; j++) {
                ll[j] = 0;
            }
    
            // Get the decode tree code lengths
    
            //document.write("<br>");
            for(j=0; j<lenCodes; j++) {
                ll[border[j]] = readBits(3);
                //document.write(ll[border[j]]+" ");
            }
            //fprintf(errfp, "\n");
            //document.write('<br>ll:'+ll);
            len = distanceTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            if(CreateTree(distanceTree, 19, ll, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug){
            	document.write("<br>distanceTree");
            	for(var a=0;a<distanceTree.length;a++){
                	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
                	/*if (distanceTree[a].jumppos!=-1)
                    	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
                	*/
            	}
            }
            //document.write('<BR>tree created');
    
            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z=-1;
            if (debug)
            	document.write("<br>n="+n+" bits: "+bits+"<br>");
            while(i < n) {
                z++;
                j = DecodeValue(distanceTree);
                if (debug)
                	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
                if(j<16) {    // length of code in bits (0..15)
                       ll[i++] = j;
                } else if(j==16) {    // repeat last length 3 to 6 times 
                       var l;
                    j = 3 + readBits(2);
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i-1] : 0;
                    while(j--) {
                        ll[i++] = l;
                    }
                } else {
                    if(j==17) {        // 3 to 10 zero length codes
                        j = 3 + readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes 
                        j = 11 + readBits(7);
                    }
                    if(i+j > n) {
                        flushBuffer();
                        return 1;
                    }
                    while(j--) {
                        ll[i++] = 0;
                    }
                }
            }
            /*for(j=0; j<literalCodes+distCodes; j++) {
                //fprintf(errfp, "%d ", ll[j]);
                if ((j&7)==7)
                    fprintf(errfp, "\n");
            }
            fprintf(errfp, "\n");*/
            // Can overwrite tree decode tree as it is not used anymore
            len = literalTree.length;
            for (i=0; i<len; i++)
                literalTree[i]=new HufNode();
            if(CreateTree(literalTree, literalCodes, ll, 0)) {
                flushBuffer();
                return 1;
            }
            len = literalTree.length;
            for (i=0; i<len; i++)
                distanceTree[i]=new HufNode();
            var ll2 = new Array();
            for (i=literalCodes; i <ll.length; i++){
                ll2[i-literalCodes]=ll[i];
            }    
            if(CreateTree(distanceTree, distCodes, ll2, 0)) {
                flushBuffer();
                return 1;
            }
            if (debug)
           		document.write("<br>literalTree");
            while(1) {
                j = DecodeValue(literalTree);
                if(j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if(j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = readBits(cplext[j]) + cplens[j];
    
                    j = DecodeValue(distanceTree);
                    if(cpdext[j] > 8) {
                        dist = readBits(8);
                        dist |= (readBits(cpdext[j]-8)<<8);
                    } else {
                        dist = readBits(cpdext[j]);
                    }
                    dist += cpdist[j];
                    while(len--) {
                        var c = buf32k[(bIdx - dist) & 0x7fff];
                        addBuffer(c);
                    }
                } else {
                    addBuffer(j);
                }
            }
        }
    } while(!last);
    flushBuffer();

    byteAlign();
    return 0;
};

JXG.Util.Unzip.prototype.unzipFile = function(name) {
    var i;
	this.unzip();
	//alert(unzipped[0][1]);
	for (i=0;i<unzipped.length;i++){
		if(unzipped[i][1]==name) {
			return unzipped[i][0];
		}
	}
	
  };
    
    
JXG.Util.Unzip.prototype.unzip = function() {
	//convertToByteArray(input);
	if (debug)
		alert(bA);
	/*for (i=0;i<bA.length*8;i++){
		document.write(readBit());
		if ((i+1)%8==0)
			document.write(" ");
	}*/
	/*for (i=0;i<bA.length;i++){
		document.write(readByte()+" ");
		if ((i+1)%8==0)
			document.write(" ");
	}
	for (i=0;i<bA.length;i++){
		document.write(bA[i]+" ");
		if ((i+1)%16==0)
			document.write("<br>");
	}	
	*/
	//alert(bA);
	nextFile();
	return unzipped;
  };
    
 function nextFile(){
 	if (debug)
 		alert("NEXTFILE");
 	outputArr = [];
 	var tmp = [];
 	modeZIP = false;
	tmp[0] = readByte();
	tmp[1] = readByte();
	if (debug)
		alert("type: "+tmp[0]+" "+tmp[1]);
	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
		if (debug)
			alert("GEONExT-GZIP");
		DeflateLoop();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "geonext.gxt";
    	files++;
	}
	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
		if (debug)
			alert("GZIP");
		//DeflateLoop();
		skipdir();
		if (debug)
			alert(outputArr.join(''));
		unzipped[files] = new Array(2);
    	unzipped[files][0] = outputArr.join('');
    	unzipped[files][1] = "file";
    	files++;
	}
	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
		modeZIP = true;
		tmp[2] = readByte();
		tmp[3] = readByte();
		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
			//MODE_ZIP
			tmp[0] = readByte();
			tmp[1] = readByte();
			if (debug)
				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
			
			gpflags = readByte();
			gpflags |= (readByte()<<8);
			if (debug)
				alert("gpflags: "+gpflags);
			
			var method = readByte();
			method |= (readByte()<<8);
			if (debug)
				alert("method: "+method);
			
			readByte();
			readByte();
			readByte();
			readByte();
			
			var crc = readByte();
			crc |= (readByte()<<8);
			crc |= (readByte()<<16);
			crc |= (readByte()<<24);
			
			var compSize = readByte();
			compSize |= (readByte()<<8);
			compSize |= (readByte()<<16);
			compSize |= (readByte()<<24);
			
			var size = readByte();
			size |= (readByte()<<8);
			size |= (readByte()<<16);
			size |= (readByte()<<24);
			
			if (debug)
				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
			
			var filelen = readByte();
			filelen |= (readByte()<<8);
			
			var extralen = readByte();
			extralen |= (readByte()<<8);
			
			if (debug)
				alert("filelen "+filelen);
			i = 0;
			nameBuf = [];
			while (filelen--){ 
				var c = readByte();
				if (c == "/" | c ==":"){
					i = 0;
				} else if (i < NAMEMAX-1)
					nameBuf[i++] = String.fromCharCode(c);
			}
			if (debug)
				alert("nameBuf: "+nameBuf);
			
			//nameBuf[i] = "\0";
			if (!fileout)
				fileout = nameBuf;
			
			var i = 0;
			while (i < extralen){
				c = readByte();
				i++;
			}
				
			CRC = 0xffffffff;
			SIZE = 0;
			
			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
				//skipdir
				if (debug)
					alert("skipdir");
			}
			if (method == 8){
				DeflateLoop();
				if (debug)
					alert(outputArr.join(''));
				unzipped[files] = new Array(2);
				unzipped[files][0] = outputArr.join('');
    			unzipped[files][1] = nameBuf.join('');
    			files++;
				//return outputArr.join('');
			}
			skipdir();
		}
	}
 };
	
function skipdir(){
    var crc, 
        tmp = [],
        compSize, size, os, i, c;
    
	if ((gpflags & 8)) {
		tmp[0] = readByte();
		tmp[1] = readByte();
		tmp[2] = readByte();
		tmp[3] = readByte();
		
		if (tmp[0] == parseInt("50",16) && 
            tmp[1] == parseInt("4b",16) && 
            tmp[2] == parseInt("07",16) && 
            tmp[3] == parseInt("08",16))
        {
            crc = readByte();
            crc |= (readByte()<<8);
            crc |= (readByte()<<16);
            crc |= (readByte()<<24);
		} else {
			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
		}
		
		compSize = readByte();
		compSize |= (readByte()<<8);
		compSize |= (readByte()<<16);
		compSize |= (readByte()<<24);
		
		size = readByte();
		size |= (readByte()<<8);
		size |= (readByte()<<16);
		size |= (readByte()<<24);
		
		if (debug)
			alert("CRC:");
	}

	if (modeZIP)
		nextFile();
	
	tmp[0] = readByte();
	if (tmp[0] != 8) {
		if (debug)
			alert("Unknown compression method!");
        return 0;	
	}
	
	gpflags = readByte();
	if (debug){
		if ((gpflags & ~(parseInt("1f",16))))
			alert("Unknown flags set!");
	}
	
	readByte();
	readByte();
	readByte();
	readByte();
	
	readByte();
	os = readByte();
	
	if ((gpflags & 4)){
		tmp[0] = readByte();
		tmp[2] = readByte();
		len = tmp[0] + 256*tmp[1];
		if (debug)
			alert("Extra field size: "+len);
		for (i=0;i<len;i++)
			readByte();
	}
	
	if ((gpflags & 8)){
		i=0;
		nameBuf=[];
		while (c=readByte()){
			if(c == "7" || c == ":")
				i=0;
			if (i<NAMEMAX-1)
				nameBuf[i++] = c;
		}
		//nameBuf[i] = "\0";
		if (debug)
			alert("original file name: "+nameBuf);
	}
		
	if ((gpflags & 16)){
		while (c=readByte()){
			//FILE COMMENT
		}
	}
	
	if ((gpflags & 2)){
		readByte();
		readByte();
	}
	
	DeflateLoop();
	
	crc = readByte();
	crc |= (readByte()<<8);
	crc |= (readByte()<<16);
	crc |= (readByte()<<24);
	
	size = readByte();
	size |= (readByte()<<8);
	size |= (readByte()<<16);
	size |= (readByte()<<24);
	
	if (modeZIP)
		nextFile();
	
};

};

/**
*  Base64 encoding / decoding
*  @see <a href="http://www.webtoolkit.info/">http://www.webtoolkit.info/</A>
*/
JXG.Util.Base64 = {

    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode : function (input) {
        var output = [],
            chr1, chr2, chr3, enc1, enc2, enc3, enc4,
            i = 0;

        input = JXG.Util.Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output.push([this._keyStr.charAt(enc1),
                         this._keyStr.charAt(enc2),
                         this._keyStr.charAt(enc3),
                         this._keyStr.charAt(enc4)].join(''));
        }

        return output.join('');
    },

    // public method for decoding
    decode : function (input, utf8) {
        var output = [],
            chr1, chr2, chr3,
            enc1, enc2, enc3, enc4,
            i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));

            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;

            output.push(String.fromCharCode(chr1));

            if (enc3 != 64) {
                output.push(String.fromCharCode(chr2));
            }
            if (enc4 != 64) {
                output.push(String.fromCharCode(chr3));
            }
        }
        
        output = output.join(''); 
        
        if (utf8) {
            output = JXG.Util.Base64._utf8_decode(output);
        }
        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = [],
            i = 0,
            c = 0, c2 = 0, c3 = 0;

        while ( i < utftext.length ) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string.push(String.fromCharCode(c));
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                i += 3;
            }
        }
        return string.join('');
    },
    
    _destrip: function (stripped, wrap){
        var lines = [], lineno, i,
            destripped = [];
        
        if (wrap==null) 
            wrap = 76;
            
        stripped.replace(/ /g, "");
        lineno = stripped.length / wrap;
        for (i = 0; i < lineno; i++)
            lines[i]=stripped.substr(i * wrap, wrap);
        if (lineno != stripped.length / wrap)
            lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
            
        for (i = 0; i < lines.length; i++)
            destripped.push(lines[i]);
        return destripped.join('\n');
    },
    
    decodeAsArray: function (input){
        var dec = this.decode(input),
            ar = [], i;
        for (i=0;i<dec.length;i++){
            ar[i]=dec.charCodeAt(i);
        }
        return ar;
    },
    
    decodeGEONExT : function (input) {
        return decodeAsArray(destrip(input),false);
    }
};

/**
 * @private
 */
JXG.Util.asciiCharCodeAt = function(str,i){
	var c = str.charCodeAt(i);
	if (c>255){
    	switch (c) {
			case 8364: c=128;
	    	break;
	    	case 8218: c=130;
	    	break;
	    	case 402: c=131;
	    	break;
	    	case 8222: c=132;
	    	break;
	    	case 8230: c=133;
	    	break;
	    	case 8224: c=134;
	    	break;
	    	case 8225: c=135;
	    	break;
	    	case 710: c=136;
	    	break;
	    	case 8240: c=137;
	    	break;
	    	case 352: c=138;
	    	break;
	    	case 8249: c=139;
	    	break;
	    	case 338: c=140;
	    	break;
	    	case 381: c=142;
	    	break;
	    	case 8216: c=145;
	    	break;
	    	case 8217: c=146;
	    	break;
	    	case 8220: c=147;
	    	break;
	    	case 8221: c=148;
	    	break;
	    	case 8226: c=149;
	    	break;
	    	case 8211: c=150;
	    	break;
	    	case 8212: c=151;
	    	break;
	    	case 732: c=152;
	    	break;
	    	case 8482: c=153;
	    	break;
	    	case 353: c=154;
	    	break;
	    	case 8250: c=155;
	    	break;
	    	case 339: c=156;
	    	break;
	    	case 382: c=158;
	    	break;
	    	case 376: c=159;
	    	break;
	    	default:
	    	break;
	    }
	}
	return c;
};

/**
 * Decoding string into utf-8
 * @param {String} string to decode
 * @return {String} utf8 decoded string
 */
JXG.Util.utf8Decode = function(utftext) {
  var string = [];
  var i = 0;
  var c = 0, c1 = 0, c2 = 0;

  while ( i < utftext.length ) {
    c = utftext.charCodeAt(i);

    if (c < 128) {
      string.push(String.fromCharCode(c));
      i++;
    } else if((c > 191) && (c < 224)) {
      c2 = utftext.charCodeAt(i+1);
      string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
      i += 2;
    } else {
      c2 = utftext.charCodeAt(i+1);
      c3 = utftext.charCodeAt(i+2);
      string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
      i += 3;
    }
  };
  return string.join('');
};

// Added to exports for Cocos2d
module.exports = JXG;

}};
__resources__["/__builtin__/libs/Plist.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/**
 * XML Node types
 */
var ELEMENT_NODE                = 1,
    ATTRIBUTE_NODE              = 2,
    TEXT_NODE                   = 3,
    CDATA_SECTION_NODE          = 4,
    ENTITY_REFERENCE_NODE       = 5,
    ENTITY_NODE                 = 6,
    PROCESSING_INSTRUCTION_NODE = 7,
    COMMENT_NODE                = 8,
    DOCUMENT_NODE               = 9,
    DOCUMENT_TYPE_NODE          = 10,
    DOCUMENT_FRAGMENT_NODE      = 11,
    NOTATION_NODE               = 12;


var Plist = BObject.extend (/** @lends Plist# */{
    /**
     * The unserialized data inside the Plist file
     * @type Object
     */
    data: null,

    /**
     * An object representation of an XML Property List file
     *
     * @constructs
     * @extends BObject
     * @param {Options} opts Options
     * @config {String} [file] The path to a .plist file
     * @config {String} [data] The contents of a .plist file
     */
    init: function(opts) {
        var file = opts['file'],
            data = opts['data'];

        if (file && !data) {
            data = resource(file);
        }


        var parser = new DOMParser(),
            doc = parser.parseFromString(data, 'text/xml'),
            plist = doc.documentElement;

        if (plist.tagName != 'plist') {
            throw "Not a plist file";
        }


        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == ELEMENT_NODE) {
                break;
            }
        }

        this.set('data', this.parseNode_(node));
    },


    /**
     * @private
     * Parses an XML node inside the Plist file
     * @returns {Object/Array/String/Integer/Float} A JS representation of the node value
     */
    parseNode_: function(node) {
        var data = null;
        switch(node.tagName) {
        case 'dict':
            data = this.parseDict_(node); 
            break;
        case 'array':
            data = this.parseArray_(node); 
            break;
        case 'string':
            // FIXME - This needs to handle Firefox's 4KB nodeValue limit
            data = node.firstChild.nodeValue;
            break
        case 'false':
            data = false;
            break
        case 'true':
            data = true;
            break
        case 'real':
            data = parseFloat(node.firstChild.nodeValue);
            break
        case 'integer':
            data = parseInt(node.firstChild.nodeValue, 10);
            break
        }

        return data;
    },

    /**
     * @private
     * Parses a <dict> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Object} A simple key/value JS Object representing the <dict>
     */
    parseDict_: function(node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this.parseNode_(child);
            }
        }


        return data;
    },

    /**
     * @private
     * Parses an <array> node in a plist file
     *
     * @param {XMLElement}
     * @returns {Array} A simple JS Array representing the <array>
     */
    parseArray_: function(node) {
        var data = [];

        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != ELEMENT_NODE) {
                continue;
            }

            data.push(this.parseNode_(child));
        }

        return data;
    }
});


exports.Plist = Plist;

}};
__resources__["/__builtin__/libs/qunit.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2011 John Resig, Jrn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== "undefined",
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e){
			return false;
		}
  })()
}

var testId = 0;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id("qunit-tests");
		if (tests) {
			var b = document.createElement("strong");
				b.innerHTML = "Running " + this.name;
			var li = document.createElement("li");
				li.appendChild( b );
				li.id = this.id = "test-output" + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				QUnit.moduleDone( {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			QUnit.moduleStart( {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		QUnit.testStart( {
			name: this.testName
		} );

		// allow utility functions to access the current test environment
		// TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;
		
		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Setup failed on " + this.testName + ": " + e.message );
		}
	},
	run: function() {
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
			QUnit.ok( false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				start();
			}
		}
	},
	teardown: function() {
		try {
			checkPollution();
			this.testEnvironment.teardown.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, "Teardown failed on " + this.testName + ": " + e.message );
		}
	},
	finish: function() {
		if ( this.expected && this.expected != this.assertions.length ) {
			QUnit.ok( false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run" );
		}
		
		var good = 0, bad = 0,
			tests = id("qunit-tests");

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol  = document.createElement("ol");

			for ( var i = 0; i < this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement("li");
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			defined.sessionStorage && sessionStorage.setItem("qunit-" + this.testName, bad);

			if (bad == 0) {
				ol.style.display = "none";
			}

			var b = document.createElement("strong");
			b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";
			
			addEvent(b, "click", function() {
				var next = b.nextSibling, display = next.style.display;
				next.style.display = display === "none" ? "block" : "none";
			});
			
			addEvent(b, "dblclick", function(e) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location.search = "?" + encodeURIComponent(getText([target]).replace(/\(.+\)$/, "").replace(/(^\s*|\s*$)/g, ""));
				}
			});

			var li = id(this.id);
			li.className = bad ? "fail" : "pass";
			li.style.display = resultDisplayStyle(!bad);
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
		}

		QUnit.testDone( {
			name: this.testName,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},
	
	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		// defer when previous test run passed, if storage is available
		var bad = defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run);
		};
	}
	
}

var QUnit = {

	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = 0;
		}

		QUnit.test(testName, expected, callback, true);
	},
	
	test: function(testName, expected, callback, async) {
		var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') {
			testEnvironmentArg =  expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
		}

		if ( !validTest(config.currentModule + ": " + testName) ) {
			return;
		}
		
		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeHtml(msg);
		QUnit.log(details);
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},
	
	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;
	
		if (typeof expected === 'string') {
			message = expected;
			expected = null;
		}
	
		try {
			block();
		} catch (e) {
			actual = e;
		}
	
		if (actual) {
			// we don't want to validate thrown error
			if (!expected) {
				ok = true;
			// expected is a regexp	
			} else if (QUnit.objectType(expected) === "regexp") {
				ok = expected.test(actual);
			// expected is a constructor	
			} else if (actual instanceof expected) {
				ok = true;
			// expected is a validation function which returns true is validation passed	
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}
			
		QUnit.ok(ok, message);
	},

	start: function() {
		config.semaphore--;
		if (config.semaphore > 0) {
			// don't start until equal number of stop-calls
			return;
		}
		if (config.semaphore < 0) {
			// ignore if start is called more often then stop
			config.semaphore = 0;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process();
			}, 13);
		} else {
			config.blocking = false;
			process();
		}
	},
	
	stop: function(timeout) {
		config.semaphore++;
		config.blocking = true;

		if ( timeout && defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			}, timeout);
		}
	}

};

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
};

// Load paramaters
(function() {
	var location = window.location || { search: "", protocol: "file:" },
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) {
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) {
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		} else if ( GETParams[i] === "notrycatch" ) {
			GETParams.splice( i, 1 );
			i--;
			config.notrycatch = true;
		} else if ( GETParams[i].search('=') > -1 ) {
			GETParams.splice( i, 1 );
			i--;
		}
	}
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
})();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

// define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	// Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filters: [],
			queue: [],
			semaphore: 0
		});

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}
	},
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 * 
	 * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
	 */
	reset: function() {
		if ( window.jQuery ) {
			jQuery( "#main, #qunit-fixture" ).html( config.fixture );
		} else {
			var main = id( 'main' ) || id( 'qunit-fixture' );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent("on"+type);
		}
	},
	
	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},
	
	objectType: function( obj ) {
		if (typeof obj === "undefined") {
				return "undefined";

		// consider: typeof null === object
		}
		if (obj === null) {
				return "null";
		}

		var type = Object.prototype.toString.call( obj )
			.match(/^\[object\s(.*)\]$/)[1] || '';

		switch (type) {
				case 'Number':
						if (isNaN(obj)) {
								return "nan";
						} else {
								return "number";
						}
				case 'String':
				case 'Boolean':
				case 'Array':
				case 'Date':
				case 'RegExp':
				case 'Function':
						return type.toLowerCase();
		}
		if (typeof obj === "object") {
				return "object";
		}
		return undefined;
	},
	
	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};
		
		message = escapeHtml(message) || (result ? "okay" : "failed");
		message = '<span class="test-message">' + message + "</span>";
		expected = escapeHtml(QUnit.jsDump.parse(expected));
		actual = escapeHtml(QUnit.jsDump.parse(actual));
		var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
		if (actual != expected) {
			output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
			output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) +'</pre></td></tr>';
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += '<tr class="test-source"><th>Source: </th><td><pre>' + source +'</pre></td></tr>';
			}
		}
		output += "</table>";
		
		QUnit.log(details);
		
		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},
	
	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: function() {},
	// done: { failed, passed, total, runtime }
	done: function() {},
	// log: { result, actual, expected, message }
	log: function() {},
	// testStart: { name }
	testStart: function() {},
	// testDone: { name, failed, passed, total }
	testDone: function() {},
	// moduleStart: { name }
	moduleStart: function() {},
	// moduleDone: { name, failed, passed, total }
	moduleDone: function() {}
});

if ( typeof document === "undefined" || document.readyState === "complete" ) {
	config.autorun = true;
}

addEvent(window, "load", function() {
	QUnit.begin({});
	
	// Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id("qunit-header");
	if ( banner ) {
		var paramsIndex = location.href.lastIndexOf(location.search);
		if ( paramsIndex > -1 ) {
			var mainPageLocation = location.href.slice(0, paramsIndex);
			if ( mainPageLocation == location.href ) {
				banner.innerHTML = '<a href=""> ' + banner.innerHTML + '</a> ';
			} else {
				var testName = decodeURIComponent(location.search.slice(1));
				banner.innerHTML = '<a href="' + mainPageLocation + '">' + banner.innerHTML + '</a> &#8250; <a href="">' + testName + '</a>';
			}
		}
	}
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) {
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		addEvent( filter, "click", function() {
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) {
				if ( li[i].className.indexOf("pass") > -1 ) {
					li[i].style.display = filter.checked ? "none" : "";
				}
			}
			if ( defined.sessionStorage ) {
				sessionStorage.setItem("qunit-filter-passed-tests", filter.checked ? "true" : "");
			}
		});
		if ( defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests") ) {
			filter.checked = true;
		}
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );
	}

	var main = id('main') || id('qunit-fixture');
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
});

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) {
		QUnit.moduleDone( {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			'Tests completed in ',
			runtime,
			' milliseconds.<br/>',
			'<span class="passed">',
			passed,
			'</span> tests of <span class="total">',
			config.stats.all,
			'</span> passed, <span class="failed">',
			config.stats.bad,
			'</span> failed.'
		].join('');

	if ( banner ) {
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	}

	if ( tests ) {	
		var result = id("qunit-testresult");

		if ( !result ) {
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		}

		result.innerHTML = html;
	}

	QUnit.done( {
		failed: config.stats.bad,
		passed: passed, 
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var i = config.filters.length,
		run = false;

	if ( !i ) {
		return true;
	}
	
	while ( i-- ) {
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) {
			filter = filter.slice(1);
		}

		if ( name.indexOf(filter) !== -1 ) {
			return !not;
		}

		if ( not ) {
			run = true;
		}
	}

	return run;
}

// so far supports only Firefox, Chrome and Opera (buggy)
// could be extended in the future to use something like https://github.com/csnover/TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			// Opera
			return e.stacktrace.split("\n")[6];
		} else if (e.stack) {
			// Firefox, Chrome
			return e.stack.split("\n")[4];
		}
	}
}

function resultDisplayStyle(passed) {
	return passed && id("qunit-filter-pass") && id("qunit-filter-pass").checked ? 'none' : '';
}

function escapeHtml(s) {
	if (!s) {
		return "";
	}
	s = s + "";
	return s.replace(/[\&"<>\\]/g, function(s) {
		switch(s) {
			case "&": return "&amp;";
			case "\\": return "\\\\";
			case '"': return '\"';
			case "<": return "&lt;";
			case ">": return "&gt;";
			default: return s;
		}
	});
}

function synchronize( callback ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process();
	}
}

function process() {
	var start = (new Date()).getTime();

	while ( config.queue.length && !config.blocking ) {
		if ( config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( process, 13 );
			break;
		}
	}
  if (!config.blocking && !config.queue.length) {
    done();
  }
}

function saveGlobal() {
	config.pollution = [];
	
	if ( config.noglobals ) {
		for ( var key in window ) {
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) {
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.current.expected++;
	}

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) {
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.current.expected++;
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) {
		for ( var j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== "undefined" && console.error && console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera && opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		a[prop] = b[prop];
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( "on" + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
}

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rath <prathe@gmail.com>
QUnit.equiv = function () {

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions
    var parents = []; // stack to avoiding loops from circular referencing

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) {
        var prop = QUnit.objectType(o);
        if (prop) {
            if (QUnit.objectType(callbacks[prop]) === "function") {
                return callbacks[prop].apply(callbacks, args);
            } else {
                return callbacks[prop]; // or undefined
            }
        }
    }
    
    var callbacks = function () {

        // for string, boolean, number and null
        function useStrictEquality(b, a) {
            if (b instanceof a.constructor || a instanceof b.constructor) {
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            } else {
                return a === b;
            }
        }

        return {
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) {
                return isNaN(b);
            },

            "date": function (b, a) {
                return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
            },

            "regexp": function (b, a) {
                return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            },

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () {
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            },

            "array": function (b, a) {
                var i, j, loop;
                var len;

                // b could be an object literal here
                if ( ! (QUnit.objectType(b) === "array")) {
                    return false;
                }   
                
                len = a.length;
                if (len !== b.length) { // safe and faster
                    return false;
                }
                
                //track reference to avoid circular references
                parents.push(a);
                for (i = 0; i < len; i++) {
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i]){
                            loop = true;//dont rewalk array
                        }
                    }
                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        parents.pop();
                        return false;
                    }
                }
                parents.pop();
                return true;
            },

            "object": function (b, a) {
                var i, j, loop;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) {
                    return false;
                }

                // stack constructor before traversing properties
                callers.push(a.constructor);
                //track reference to avoid circular references
                parents.push(a);
                
                for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                    loop = false;
                    for(j=0;j<parents.length;j++){
                        if(parents[j] === a[i])
                            loop = true; //don't go down the same path twice
                    }
                    aProperties.push(i); // collect a's properties

                    if (!loop && ! innerEquiv(a[i], b[i])) {
                        eq = false;
                        break;
                    }
                }

                callers.pop(); // unstack, we are done
                parents.pop();

                for (i in b) {
                    bProperties.push(i); // collect b's properties
                }

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            }
        };
    }();

    innerEquiv = function () { // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) {
            return true; // end transition
        }

        return (function (a, b) {
            if (a === b) {
                return true; // catch the most you can
            } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                return false; // don't lose time with error prone cases
            } else {
                return bindCallbacks(a, callbacks, [b, a]);
            }

        // apply transition with (1..n) arguments
        })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    };

    return innerEquiv;

}();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	};
	function literal( o ) {
		return o + '';	
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr ) {
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	};
	
	var reName = /^function (\w+)/;
	
	var jsDump = {
		parse:function( obj, type ) { //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = "null";
			} else if (typeof obj === "undefined") {
				type = "undefined";
			} else if (QUnit.is("RegExp", obj)) {
				type = "regexp";
			} else if (QUnit.is("Date", obj)) {
				type = "date";
			} else if (QUnit.is("Function", obj)) {
				type = "function";
			} else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
				type = "window";
			} else if (obj.nodeType === 9) {
				type = "document";
			} else if (obj.nodeType) {
				type = "node";
			} else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
				type = "array";
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		},
		indent:function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) {
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, QUnit.jsDump.parse( fn, 'functionArgs' ), '){'].join('');
				return join( ret, QUnit.jsDump.parse(fn,'functionCode'), '}' );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map )
					ret.push( QUnit.jsDump.parse(key,'key') + ': ' + QUnit.jsDump.parse(map[key]) );
				QUnit.jsDump.down();
				return join( '{', ret, '}' );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? '&lt;' : '<',
					close = QUnit.jsDump.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + QUnit.jsDump.parse( val, 'attribute' );
				}
				return ret + close + open + '/' + tag + close;
			},
			functionArgs:function( fn ) {//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			},
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		},
		DOMAttrs:{//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		},
		HTML:false,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'  ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

// from Sizzle.js
function getText( elems ) {
	var ret = "", elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		// Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		// Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *  
 * Usage: QUnit.diff(expected, actual)
 * 
 * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	function diff(o, n){
		var ns = new Object();
		var os = new Object();
		
		for (var i = 0; i < n.length; i++) {
			if (ns[n[i]] == null) 
				ns[n[i]] = {
					rows: new Array(),
					o: null
				};
			ns[n[i]].rows.push(i);
		}
		
		for (var i = 0; i < o.length; i++) {
			if (os[o[i]] == null) 
				os[o[i]] = {
					rows: new Array(),
					n: null
				};
			os[o[i]].rows.push(i);
		}
		
		for (var i in ns) {
			if (ns[i].rows.length == 1 && typeof(os[i]) != "undefined" && os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}
		
		for (var i = 0; i < n.length - 1; i++) {
			if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}
		
		for (var i = n.length - 1; i > 0; i--) {
			if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}
		
		return {
			o: o,
			n: n
		};
	}
	
	return function(o, n){
		o = o.replace(/\s+$/, '');
		n = n.replace(/\s+$/, '');
		var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

		var str = "";
		
		var oSpace = o.match(/\s+/g);
		if (oSpace == null) {
			oSpace = [" "];
		}
		else {
			oSpace.push(" ");
		}
		var nSpace = n.match(/\s+/g);
		if (nSpace == null) {
			nSpace = [" "];
		}
		else {
			nSpace.push(" ");
		}
		
		if (out.n.length == 0) {
			for (var i = 0; i < out.o.length; i++) {
				str += '<del>' + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
					str += '<del>' + out.o[n] + oSpace[n] + "</del>";
				}
			}
			
			for (var i = 0; i < out.n.length; i++) {
				if (out.n[i].text == null) {
					str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					var pre = "";
					
					for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
						pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}
		
		return str;
	};
})();

})(this);

}};
__resources__["/__builtin__/libs/util.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var path = require('path');

/**
 * @namespace
 * Useful utility functions
 */
var util = {
    /**
     * Merge two or more objects and return the result.
     *
     * @param {Object} firstObject First object to merge with
     * @param {Object} secondObject Second object to merge with
     * @param {Object} [...] More objects to merge
     * @returns {Object} A new object containing the properties of all the objects passed in
     */
    merge: function(firstObject, secondObject) {
        var result = {};

        for (var i = 0; i < arguments.length; i++) {
            var obj = arguments[i];

            for (var x in obj) {
                if (!obj.hasOwnProperty(x)) {
                    continue;
                }

                result[x] = obj[x];
            }
        };

        return result;
    },

    /**
     * Creates a deep copy of an object
     *
     * @param {Object} obj The Object to copy
     * @returns {Object} A copy of the original Object
     */
    copy: function(obj) {
        if (obj === null) {
            return null;
        }

        var copy;

        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = arguments.callee(obj[i]);
            }
        } else if (typeof(obj) == 'object') {
            if (typeof(obj.copy) == 'function') {
                copy = obj.copy();
            } else {
                copy = {};

                var o, x;
                for (x in obj) {
                    copy[x] = arguments.callee(obj[x]);
                }
            }
        } else {
            // Primative type. Doesn't need copying
            copy = obj;
        }

        return copy;
    },

    /**
     * Iterates over an array and calls a function for each item.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The original array
     */
    each: function(arr, func) {
        var i = 0,
            len = arr.length;
        for (i = 0; i < len; i++) {
            func(arr[i], i);
        }

        return arr;
    },

    /**
     * Iterates over an array, calls a function for each item and returns the results.
     *
     * @param {Array} arr An Array to iterate over
     * @param {Function} func A function to call for each item in the array
     * @returns {Array} The return values from each function call
     */
    map: function(arr, func) {
        var i = 0,
            len = arr.length,
            result = [];

        for (i = 0; i < len; i++) {
            result.push(func(arr[i], i));
        }

        return result;
    },

    extend: function(target, ext) {
        if (arguments.length < 2) {
            throw "You must provide at least a target and 1 object to extend from"
        }

        var i, j, obj, key, val;

        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            for (key in obj) {
                // Don't copy built-ins
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                val = obj[key];
                // Don't copy undefineds or references to target (would cause infinite loop)
                if (val === undefined || val === target) {
                    continue;
                }

                // Replace existing function and store reference to it in .base
                if (val instanceof Function && target[key] && val !== target[key]) {
                    val.base = target[key];
                    val._isProperty = val.base._isProperty;
                }
                target[key] = val;

                if (val instanceof Function) {
                    // If this function observes make a reference to it so we can set
                    // them up when this get instantiated
                    if (val._observing) {
                        // Force a COPY of the array or we will probably end up with various
                        // classes sharing the same one.
                        if (!target._observingFunctions) {
                            target._observingFunctions = [];
                        } else {
                            target._observingFunctions = target._observingFunctions.slice(0);
                        }


                        for (j = 0; j<val._observing.length; j++) {
                            target._observingFunctions.push({property:val._observing[j], method: key});
                        }
                    } // if (val._observing)

                    // If this is a computer property then add it to the list so get/set know where to look
                    if (val._isProperty) {
                        if (!target._computedProperties) {
                            target._computedProperties = [];
                        } else {
                            target._computedProperties = target._computedProperties.slice(0);
                        }

                        target._computedProperties.push(key)
                    }
                }
        
            }
        }


        return target;
    },

    beget: function(o) {
        var F = function(){};
        F.prototype = o;
        var ret  = new F();
        F.prototype = null;
        return ret;
    },

    callback: function(target, method) {
        if (typeof(method) == 'string') {
            method = target[method];
        }

        return function() {
            method.apply(target, arguments);
        }
    },

    domReady: function() {
        if (this._isReady) {
            return;
        }

        if (!document.body) {
            setTimeout(function() { util.domReady(); }, 13);
        }

        window.__isReady = true;

        if (window.__readyList) {
            var fn, i = 0;
            while ( (fn = window.__readyList[ i++ ]) ) {
                fn.call(document);
            }

            window.__readyList = null;
            delete window.__readyList;
        }
    },


    /**
     * Adapted from jQuery
     * @ignore
     */
    bindReady: function() {

        if (window.__readyBound) {
            return;
        }

        window.__readyBound = true;

        // Catch cases where $(document).ready() is called after the
        // browser event has already occurred.
        if ( document.readyState === "complete" ) {
            return util.domReady();
        }

        // Mozilla, Opera and webkit nightlies currently support this event
        if ( document.addEventListener ) {
            // Use the handy event callback
            //document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
            
            // A fallback to window.onload, that will always work
            window.addEventListener( "load", util.domReady, false );

        // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload,
            // maybe late but safe also for iframes
            //document.attachEvent("onreadystatechange", DOMContentLoaded);
            
            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", util.domReady );

            // If IE and not a frame
            /*
            // continually check to see if the document is ready
            var toplevel = false;

            try {
                toplevel = window.frameElement == null;
            } catch(e) {}

            if ( document.documentElement.doScroll && toplevel ) {
                doScrollCheck();
            }
            */
        }
    },



    ready: function(func) {
        if (window.__isReady) {
            func()
        } else {
            if (!window.__readyList) {
                window.__readyList = [];
            }
            window.__readyList.push(func);
        }

        util.bindReady();
    },


    /**
     * Tests if a given object is an Array
     *
     * @param {Array} ar The object to test
     *
     * @returns {Boolean} True if it is an Array, otherwise false
     */
    isArray: function(ar) {
      return ar instanceof Array
          || (ar && ar !== Object.prototype && util.isArray(ar.__proto__));
    },


    /**
     * Tests if a given object is a RegExp
     *
     * @param {RegExp} ar The object to test
     *
     * @returns {Boolean} True if it is an RegExp, otherwise false
     */
    isRegExp: function(re) {
      var s = ""+re;
      return re instanceof RegExp // easy case
          || typeof(re) === "function" // duck-type for context-switching evalcx case
          && re.constructor.name === "RegExp"
          && re.compile
          && re.test
          && re.exec
          && s.charAt(0) === "/"
          && s.substr(-1) === "/";
    },


    /**
     * Tests if a given object is a Date
     *
     * @param {Date} ar The object to test
     *
     * @returns {Boolean} True if it is an Date, otherwise false
     */
    isDate: function(d) {
        if (d instanceof Date) return true;
        if (typeof d !== "object") return false;
        var properties = Date.prototype && Object.getOwnPropertyNames(Date.prototype);
        var proto = d.__proto__ && Object.getOwnPropertyNames(d.__proto__);
        return JSON.stringify(proto) === JSON.stringify(properties);
    },

    /**
     * Utility to populate a namespace's index with its modules
     *
     * @param {Object} parent The module the namespace lives in. parent.exports will be populated automatically
     * @param {String} modules A space separated string of all the module names
     *
     * @returns {Object} The index namespace
     */
    populateIndex: function(parent, modules) {
        var namespace = {};
        modules = modules.split(' ');

        util.each(modules, function(mod, i) {
            // Use the global 'require' which allows overriding the parent module
            util.extend(namespace, window.require('./' + mod, parent));
        });

        parent.exports = namespace;

        return namespace;
    }


}

util.extend(String.prototype, /** @scope String.prototype */ {
    /**
     * Create an array of words from a string
     *
     * @returns {String[]} Array of the words in the string
     */
    w: function() {
        return this.split(' ');
    }
});




module.exports = util;

}};
__resources__["/__builtin__/path.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var path = {
    /**
     * Returns full directory path for the filename given. The path must be formed using forward slashes '/'.
     *
     * @param {String} path Path to return the directory name of
     * @returns {String} Directory name
     */
    dirname: function(path) {
        var tokens = path.split('/');
        tokens.pop();
        return tokens.join('/');
    },

    /**
     * Returns just the filename portion of a path.
     *
     * @param {String} path Path to return the filename portion of
     * @returns {String} Filename
     */
    basename: function(path) {
        var tokens = path.split('/');
        return tokens[tokens.length-1];
    },

    /**
     * Joins multiple paths together to form a single path
     * @param {String} ... Any number of string arguments to join together
     * @returns {String} The joined path
     */
    join: function () {
        return module.exports.normalize(Array.prototype.join.call(arguments, "/"));
    },

    /**
     * Tests if a path exists
     *
     * @param {String} path Path to test
     * @returns {Boolean} True if the path exists, false if not
     */
    exists: function(path) {
        return (__resources__[path] !== undefined);
    },

    /**
     * @private
     */
    normalizeArray: function (parts, keepBlanks) {
      var directories = [], prev;
      for (var i = 0, l = parts.length - 1; i <= l; i++) {
        var directory = parts[i];

        // if it's blank, but it's not the first thing, and not the last thing, skip it.
        if (directory === "" && i !== 0 && i !== l && !keepBlanks) continue;

        // if it's a dot, and there was some previous dir already, then skip it.
        if (directory === "." && prev !== undefined) continue;

        // if it starts with "", and is a . or .., then skip it.
        if (directories.length === 1 && directories[0] === "" && (
            directory === "." || directory === "..")) continue;

        if (
          directory === ".."
          && directories.length
          && prev !== ".."
          && prev !== "."
          && prev !== undefined
          && (prev !== "" || keepBlanks)
        ) {
          directories.pop();
          prev = directories.slice(-1)[0]
        } else {
          if (prev === ".") directories.pop();
          directories.push(directory);
          prev = directory;
        }
      }
      return directories;
    },

    /**
     * Returns the real path by expanding any '.' and '..' portions
     *
     * @param {String} path Path to normalize
     * @param {Boolean} [keepBlanks=false] Whether to keep blanks. i.e. double slashes in a path
     * @returns {String} Normalized path
     */
    normalize: function (path, keepBlanks) {
      return module.exports.normalizeArray(path.split("/"), keepBlanks).join("/");
    }
};

module.exports = path;

}};
__resources__["/__builtin__/system.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
/** @namespace */
var system = {
    /** @namespace */
    stdio: {
        /**
         * Print text and objects to the debug console if the browser has one
         * 
         * @param {*} Any value to output
         */
        print: function() {
            if (console) {
                console.log.apply(console, arguments);
            } else {
                // TODO
            }
        }
    }
};

if (window.console) {
    system.console = window.console
} else {
    system.console = {
        log: function(){}
    }
}

}};
__resources__["/box2d_promote/box2d.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
function extend(a, b) {
  for(var c in b) {
    a[c] = b[c]
  }
}
function isInstanceOf(obj, _constructor) {
  while(typeof obj === "object") {
    if(obj.constructor === _constructor) {
      return true
    }
    obj = obj._super
  }
  return false
}
;var b2BoundValues = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BoundValues.prototype.__constructor = function() {
  this.lowerValues = new Array;
  this.lowerValues[0] = 0;
  this.lowerValues[1] = 0;
  this.upperValues = new Array;
  this.upperValues[0] = 0;
  this.upperValues[1] = 0
};
b2BoundValues.prototype.__varz = function() {
};
b2BoundValues.prototype.lowerValues = null;
b2BoundValues.prototype.upperValues = null;var b2PairManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PairManager.prototype.__constructor = function() {
  this.m_pairs = new Array;
  this.m_pairBuffer = new Array;
  this.m_pairCount = 0;
  this.m_pairBufferCount = 0;
  this.m_freePair = null
};
b2PairManager.prototype.__varz = function() {
};
b2PairManager.prototype.AddPair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair != null) {
    return pair
  }
  if(this.m_freePair == null) {
    this.m_freePair = new b2Pair;
    this.m_pairs.push(this.m_freePair)
  }
  pair = this.m_freePair;
  this.m_freePair = pair.next;
  pair.proxy1 = proxy1;
  pair.proxy2 = proxy2;
  pair.status = 0;
  pair.userData = null;
  pair.next = null;
  proxy1.pairs[proxy2] = pair;
  proxy2.pairs[proxy1] = pair;
  ++this.m_pairCount;
  return pair
};
b2PairManager.prototype.RemovePair = function(proxy1, proxy2) {
  var pair = proxy1.pairs[proxy2];
  if(pair == null) {
    return null
  }
  var userData = pair.userData;
  delete proxy1.pairs[proxy2];
  delete proxy2.pairs[proxy1];
  pair.next = this.m_freePair;
  pair.proxy1 = null;
  pair.proxy2 = null;
  pair.userData = null;
  pair.status = 0;
  this.m_freePair = pair;
  --this.m_pairCount;
  return userData
};
b2PairManager.prototype.Find = function(proxy1, proxy2) {
  return proxy1.pairs[proxy2]
};
b2PairManager.prototype.ValidateBuffer = function() {
};
b2PairManager.prototype.ValidateTable = function() {
};
b2PairManager.prototype.Initialize = function(broadPhase) {
  this.m_broadPhase = broadPhase
};
b2PairManager.prototype.AddBufferedPair = function(proxy1, proxy2) {
  var pair = this.AddPair(proxy1, proxy2);
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.ClearRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.RemoveBufferedPair = function(proxy1, proxy2) {
  var pair = this.Find(proxy1, proxy2);
  if(pair == null) {
    return
  }
  if(pair.IsBuffered() == false) {
    pair.SetBuffered();
    this.m_pairBuffer[this.m_pairBufferCount] = pair;
    ++this.m_pairBufferCount
  }
  pair.SetRemoved();
  if(b2BroadPhase.s_validate) {
    this.ValidateBuffer()
  }
};
b2PairManager.prototype.Commit = function(callback) {
  var i = 0;
  var removeCount = 0;
  for(i = 0;i < this.m_pairBufferCount;++i) {
    var pair = this.m_pairBuffer[i];
    pair.ClearBuffered();
    var proxy1 = pair.proxy1;
    var proxy2 = pair.proxy2;
    if(pair.IsRemoved()) {
    }else {
      if(pair.IsFinal() == false) {
        callback(proxy1.userData, proxy2.userData)
      }
    }
  }
  this.m_pairBufferCount = 0;
  if(b2BroadPhase.s_validate) {
    this.ValidateTable()
  }
};
b2PairManager.prototype.m_broadPhase = null;
b2PairManager.prototype.m_pairs = null;
b2PairManager.prototype.m_freePair = null;
b2PairManager.prototype.m_pairCount = 0;
b2PairManager.prototype.m_pairBuffer = null;
b2PairManager.prototype.m_pairBufferCount = 0;var b2TimeStep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeStep.prototype.__constructor = function() {
};
b2TimeStep.prototype.__varz = function() {
};
b2TimeStep.prototype.Set = function(step) {
  this.dt = step.dt;
  this.inv_dt = step.inv_dt;
  this.positionIterations = step.positionIterations;
  this.velocityIterations = step.velocityIterations;
  this.warmStarting = step.warmStarting
};
b2TimeStep.prototype.dt = null;
b2TimeStep.prototype.inv_dt = null;
b2TimeStep.prototype.dtRatio = null;
b2TimeStep.prototype.velocityIterations = 0;
b2TimeStep.prototype.positionIterations = 0;
b2TimeStep.prototype.warmStarting = null;var b2Controller = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Controller.prototype.__constructor = function() {
};
b2Controller.prototype.__varz = function() {
};
b2Controller.prototype.Step = function(step) {
};
b2Controller.prototype.Draw = function(debugDraw) {
};
b2Controller.prototype.AddBody = function(body) {
  var edge = new b2ControllerEdge;
  edge.controller = this;
  edge.body = body;
  edge.nextBody = m_bodyList;
  edge.prevBody = null;
  m_bodyList = edge;
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge
  }
  m_bodyCount++;
  edge.nextController = body.m_controllerList;
  edge.prevController = null;
  body.m_controllerList = edge;
  if(edge.nextController) {
    edge.nextController.prevController = edge
  }
  body.m_controllerCount++
};
b2Controller.prototype.RemoveBody = function(body) {
  var edge = body.m_controllerList;
  while(edge && edge.controller != this) {
    edge = edge.nextController
  }
  if(edge.prevBody) {
    edge.prevBody.nextBody = edge.nextBody
  }
  if(edge.nextBody) {
    edge.nextBody.prevBody = edge.prevBody
  }
  if(edge.nextController) {
    edge.nextController.prevController = edge.prevController
  }
  if(edge.prevController) {
    edge.prevController.nextController = edge.nextController
  }
  if(m_bodyList == edge) {
    m_bodyList = edge.nextBody
  }
  if(body.m_controllerList == edge) {
    body.m_controllerList = edge.nextController
  }
  body.m_controllerCount--;
  m_bodyCount--
};
b2Controller.prototype.Clear = function() {
  while(m_bodyList) {
    this.RemoveBody(m_bodyList.body)
  }
};
b2Controller.prototype.GetNext = function() {
  return this.m_next
};
b2Controller.prototype.GetWorld = function() {
  return this.m_world
};
b2Controller.prototype.GetBodyList = function() {
  return m_bodyList
};
b2Controller.prototype.m_next = null;
b2Controller.prototype.m_prev = null;
b2Controller.prototype.m_world = null;var b2GravityController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GravityController.prototype, b2Controller.prototype);
b2GravityController.prototype._super = b2Controller.prototype;
b2GravityController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2GravityController.prototype.__varz = function() {
};
b2GravityController.prototype.Step = function(step) {
  var i = null;
  var body1 = null;
  var p1 = null;
  var mass1 = 0;
  var j = null;
  var body2 = null;
  var p2 = null;
  var dx = 0;
  var dy = 0;
  var r2 = 0;
  var f = null;
  if(this.invSqr) {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }else {
    for(i = m_bodyList;i;i = i.nextBody) {
      body1 = i.body;
      p1 = body1.GetWorldCenter();
      mass1 = body1.GetMass();
      for(j = m_bodyList;j != i;j = j.nextBody) {
        body2 = j.body;
        p2 = body2.GetWorldCenter();
        dx = p2.x - p1.x;
        dy = p2.y - p1.y;
        r2 = dx * dx + dy * dy;
        if(r2 < Number.MIN_VALUE) {
          continue
        }
        f = new b2Vec2(dx, dy);
        f.Multiply(this.G / r2 * mass1 * body2.GetMass());
        if(body1.IsAwake()) {
          body1.ApplyForce(f, p1)
        }
        f.Multiply(-1);
        if(body2.IsAwake()) {
          body2.ApplyForce(f, p2)
        }
      }
    }
  }
};
b2GravityController.prototype.G = 1;
b2GravityController.prototype.invSqr = true;var b2DestructionListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DestructionListener.prototype.__constructor = function() {
};
b2DestructionListener.prototype.__varz = function() {
};
b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {
};
b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {
};var b2ContactEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactEdge.prototype.__constructor = function() {
};
b2ContactEdge.prototype.__varz = function() {
};
b2ContactEdge.prototype.other = null;
b2ContactEdge.prototype.contact = null;
b2ContactEdge.prototype.prev = null;
b2ContactEdge.prototype.next = null;var b2EdgeChainDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2EdgeChainDef.prototype.__constructor = function() {
  this.vertexCount = 0;
  this.isALoop = true;
  this.vertices = []
};
b2EdgeChainDef.prototype.__varz = function() {
};
b2EdgeChainDef.prototype.vertices = null;
b2EdgeChainDef.prototype.vertexCount = null;
b2EdgeChainDef.prototype.isALoop = null;var b2Vec2 = function(x_, y_) {
  if(arguments.length == 2) {
    this.x = x_;
    this.y = y_
  }
};
b2Vec2.Make = function(x_, y_) {
  return new b2Vec2(x_, y_)
};
b2Vec2.prototype.SetZero = function() {
  this.x = 0;
  this.y = 0
};
b2Vec2.prototype.Set = function(x_, y_) {
  this.x = x_;
  this.y = y_
};
b2Vec2.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y
};
b2Vec2.prototype.GetNegative = function() {
  return new b2Vec2(-this.x, -this.y)
};
b2Vec2.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y
};
b2Vec2.prototype.Copy = function() {
  return new b2Vec2(this.x, this.y)
};
b2Vec2.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y
};
b2Vec2.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y
};
b2Vec2.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a
};
b2Vec2.prototype.MulM = function(A) {
  var tX = this.x;
  this.x = A.col1.x * tX + A.col2.x * this.y;
  this.y = A.col1.y * tX + A.col2.y * this.y
};
b2Vec2.prototype.MulTM = function(A) {
  var tX = b2Math.Dot(this, A.col1);
  this.y = b2Math.Dot(this, A.col2);
  this.x = tX
};
b2Vec2.prototype.CrossVF = function(s) {
  var tX = this.x;
  this.x = s * this.y;
  this.y = -s * tX
};
b2Vec2.prototype.CrossFV = function(s) {
  var tX = this.x;
  this.x = -s * this.y;
  this.y = s * tX
};
b2Vec2.prototype.MinV = function(b) {
  this.x = this.x < b.x ? this.x : b.x;
  this.y = this.y < b.y ? this.y : b.y
};
b2Vec2.prototype.MaxV = function(b) {
  this.x = this.x > b.x ? this.x : b.x;
  this.y = this.y > b.y ? this.y : b.y
};
b2Vec2.prototype.Abs = function() {
  if(this.x < 0) {
    this.x = -this.x
  }
  if(this.y < 0) {
    this.y = -this.y
  }
};
b2Vec2.prototype.Length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y)
};
b2Vec2.prototype.LengthSquared = function() {
  return this.x * this.x + this.y * this.y
};
b2Vec2.prototype.Normalize = function() {
  var length = Math.sqrt(this.x * this.x + this.y * this.y);
  if(length < Number.MIN_VALUE) {
    return 0
  }
  var invLength = 1 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length
};
b2Vec2.prototype.IsValid = function() {
  return b2Math.IsValid(this.x) && b2Math.IsValid(this.y)
};
b2Vec2.prototype.x = 0;
b2Vec2.prototype.y = 0;var b2Vec3 = function(x, y, z) {
  if(arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z
  }
};
b2Vec3.prototype.SetZero = function() {
  this.x = this.y = this.z = 0
};
b2Vec3.prototype.Set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z
};
b2Vec3.prototype.SetV = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z
};
b2Vec3.prototype.GetNegative = function() {
  return new b2Vec3(-this.x, -this.y, -this.z)
};
b2Vec3.prototype.NegativeSelf = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z
};
b2Vec3.prototype.Copy = function() {
  return new b2Vec3(this.x, this.y, this.z)
};
b2Vec3.prototype.Add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z
};
b2Vec3.prototype.Subtract = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z
};
b2Vec3.prototype.Multiply = function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a
};
b2Vec3.prototype.x = 0;
b2Vec3.prototype.y = 0;
b2Vec3.prototype.z = 0;var b2DistanceProxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceProxy.prototype.__constructor = function() {
};
b2DistanceProxy.prototype.__varz = function() {
};
b2DistanceProxy.prototype.Set = function(shape) {
  switch(shape.GetType()) {
    case b2Shape.e_circleShape:
      var circle = shape;
      this.m_vertices = new Array(1);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case b2Shape.e_polygonShape:
      var polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      b2Settings.b2Assert(false)
  }
};
b2DistanceProxy.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_count;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count
};
b2DistanceProxy.prototype.GetVertex = function(index) {
  b2Settings.b2Assert(0 <= index && index < this.m_count);
  return this.m_vertices[index]
};
b2DistanceProxy.prototype.m_vertices = null;
b2DistanceProxy.prototype.m_count = 0;
b2DistanceProxy.prototype.m_radius = null;var b2ContactFactory = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFactory.prototype.__constructor = function() {
};
b2ContactFactory.prototype.__varz = function() {
  this.InitializeRegisters()
};
b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
  this.m_registers[type1][type2].createFcn = createFcn;
  this.m_registers[type1][type2].destroyFcn = destroyFcn;
  this.m_registers[type1][type2].primary = true;
  if(type1 != type2) {
    this.m_registers[type2][type1].createFcn = createFcn;
    this.m_registers[type2][type1].destroyFcn = destroyFcn;
    this.m_registers[type2][type1].primary = false
  }
};
b2ContactFactory.prototype.InitializeRegisters = function() {
  this.m_registers = new Array(b2Shape.e_shapeTypeCount);
  for(var i = 0;i < b2Shape.e_shapeTypeCount;i++) {
    this.m_registers[i] = new Array(b2Shape.e_shapeTypeCount);
    for(var j = 0;j < b2Shape.e_shapeTypeCount;j++) {
      this.m_registers[i][j] = new b2ContactRegister
    }
  }
  this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
  this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
  this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
  this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape)
};
b2ContactFactory.prototype.Create = function(fixtureA, fixtureB) {
  var type1 = fixtureA.GetType();
  var type2 = fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  var c;
  if(reg.pool) {
    c = reg.pool;
    reg.pool = c.m_next;
    reg.poolCount--;
    c.Reset(fixtureA, fixtureB);
    return c
  }
  var createFcn = reg.createFcn;
  if(createFcn != null) {
    if(reg.primary) {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureA, fixtureB);
      return c
    }else {
      c = createFcn(this.m_allocator);
      c.Reset(fixtureB, fixtureA);
      return c
    }
  }else {
    return null
  }
};
b2ContactFactory.prototype.Destroy = function(contact) {
  if(contact.m_manifold.m_pointCount > 0) {
    contact.m_fixtureA.m_body.SetAwake(true);
    contact.m_fixtureB.m_body.SetAwake(true)
  }
  var type1 = contact.m_fixtureA.GetType();
  var type2 = contact.m_fixtureB.GetType();
  var reg = this.m_registers[type1][type2];
  if(true) {
    reg.poolCount++;
    contact.m_next = reg.pool;
    reg.pool = contact
  }
  var destroyFcn = reg.destroyFcn;
  destroyFcn(contact, this.m_allocator)
};
b2ContactFactory.prototype.m_registers = null;
b2ContactFactory.prototype.m_allocator = null;var b2ConstantAccelController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantAccelController.prototype, b2Controller.prototype);
b2ConstantAccelController.prototype._super = b2Controller.prototype;
b2ConstantAccelController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantAccelController.prototype.__varz = function() {
  this.A = new b2Vec2(0, 0)
};
b2ConstantAccelController.prototype.Step = function(step) {
  var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y))
  }
};
b2ConstantAccelController.prototype.A = new b2Vec2(0, 0);var b2SeparationFunction = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SeparationFunction.prototype.__constructor = function() {
};
b2SeparationFunction.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_axis = new b2Vec2
};
b2SeparationFunction.e_points = 1;
b2SeparationFunction.e_faceA = 2;
b2SeparationFunction.e_faceB = 4;
b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  b2Settings.b2Assert(0 < count && count < 3);
  var localPointA;
  var localPointA1;
  var localPointA2;
  var localPointB;
  var localPointB1;
  var localPointB2;
  var pointAX;
  var pointAY;
  var pointBX;
  var pointBY;
  var normalX;
  var normalY;
  var tMat;
  var tVec;
  var s;
  var sgn;
  if(count == 1) {
    this.m_type = b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
    localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize()
  }else {
    if(cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if(s < 0) {
        this.m_axis.NegativeSelf()
      }
    }else {
      if(cache.indexA[0] == cache.indexA[0]) {
        this.m_type = b2SeparationFunction.e_faceB;
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
        this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
        this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
        this.m_axis.Normalize();
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
        if(s < 0) {
          this.m_axis.NegativeSelf()
        }
      }else {
        localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
        localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
        localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
        localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
        var pA = b2Math.MulX(transformA, localPointA);
        var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
        var pB = b2Math.MulX(transformB, localPointB);
        var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
        var a = dA.x * dA.x + dA.y * dA.y;
        var e = dB.x * dB.x + dB.y * dB.y;
        var r = b2Math.SubtractVV(dB, dA);
        var c = dA.x * r.x + dA.y * r.y;
        var f = dB.x * r.x + dB.y * r.y;
        var b = dA.x * dB.x + dA.y * dB.y;
        var denom = a * e - b * b;
        s = 0;
        if(denom != 0) {
          s = b2Math.Clamp((b * f - c * e) / denom, 0, 1)
        }
        var t = (b * s + f) / e;
        if(t < 0) {
          t = 0;
          s = b2Math.Clamp((b - c) / a, 0, 1)
        }
        localPointA = new b2Vec2;
        localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
        localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
        localPointB = new b2Vec2;
        localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
        localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
        if(s == 0 || s == 1) {
          this.m_type = b2SeparationFunction.e_faceB;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1);
          this.m_axis.Normalize();
          this.m_localPoint = localPointB;
          tVec = this.m_axis;
          tMat = transformB.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointA;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }else {
          this.m_type = b2SeparationFunction.e_faceA;
          this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1);
          this.m_localPoint = localPointA;
          tVec = this.m_axis;
          tMat = transformA.R;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tVec = this.m_localPoint;
          tMat = transformA.R;
          pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tVec = localPointB;
          tMat = transformB.R;
          pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
          if(s < 0) {
            this.m_axis.NegativeSelf()
          }
        }
      }
    }
  }
};
b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var axisA;
  var axisB;
  var localPointA;
  var localPointB;
  var pointA;
  var pointB;
  var seperation;
  var normal;
  switch(this.m_type) {
    case b2SeparationFunction.e_points:
      axisA = b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = b2Math.MulX(transformA, localPointA);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case b2SeparationFunction.e_faceA:
      normal = b2Math.MulMV(transformA.R, this.m_axis);
      pointA = b2Math.MulX(transformA, this.m_localPoint);
      axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case b2SeparationFunction.e_faceB:
      normal = b2Math.MulMV(transformB.R, this.m_axis);
      pointB = b2Math.MulX(transformB, this.m_localPoint);
      axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2SeparationFunction.prototype.m_proxyA = null;
b2SeparationFunction.prototype.m_proxyB = null;
b2SeparationFunction.prototype.m_type = 0;
b2SeparationFunction.prototype.m_localPoint = new b2Vec2;
b2SeparationFunction.prototype.m_axis = new b2Vec2;var b2DynamicTreePair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreePair.prototype.__constructor = function() {
};
b2DynamicTreePair.prototype.__varz = function() {
};
b2DynamicTreePair.prototype.proxyA = null;
b2DynamicTreePair.prototype.proxyB = null;var b2ContactConstraintPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraintPoint.prototype.__constructor = function() {
};
b2ContactConstraintPoint.prototype.__varz = function() {
  this.localPoint = new b2Vec2;
  this.rA = new b2Vec2;
  this.rB = new b2Vec2
};
b2ContactConstraintPoint.prototype.localPoint = new b2Vec2;
b2ContactConstraintPoint.prototype.rA = new b2Vec2;
b2ContactConstraintPoint.prototype.rB = new b2Vec2;
b2ContactConstraintPoint.prototype.normalImpulse = null;
b2ContactConstraintPoint.prototype.tangentImpulse = null;
b2ContactConstraintPoint.prototype.normalMass = null;
b2ContactConstraintPoint.prototype.tangentMass = null;
b2ContactConstraintPoint.prototype.equalizedMass = null;
b2ContactConstraintPoint.prototype.velocityBias = null;var b2ControllerEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ControllerEdge.prototype.__constructor = function() {
};
b2ControllerEdge.prototype.__varz = function() {
};
b2ControllerEdge.prototype.controller = null;
b2ControllerEdge.prototype.body = null;
b2ControllerEdge.prototype.prevBody = null;
b2ControllerEdge.prototype.nextBody = null;
b2ControllerEdge.prototype.prevController = null;
b2ControllerEdge.prototype.nextController = null;var b2DistanceInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceInput.prototype.__constructor = function() {
};
b2DistanceInput.prototype.__varz = function() {
};
b2DistanceInput.prototype.proxyA = null;
b2DistanceInput.prototype.proxyB = null;
b2DistanceInput.prototype.transformA = null;
b2DistanceInput.prototype.transformB = null;
b2DistanceInput.prototype.useRadii = null;var b2Settings = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Settings.prototype.__constructor = function() {
};
b2Settings.prototype.__varz = function() {
};
b2Settings.b2MixFriction = function(friction1, friction2) {
  return Math.sqrt(friction1 * friction2)
};
b2Settings.b2MixRestitution = function(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2
};
b2Settings.b2Assert = function(a) {
  if(!a) {
    throw"Assertion Failed";
  }
};
b2Settings.VERSION = "2.1alpha";
b2Settings.USHRT_MAX = 65535;
b2Settings.b2_pi = Math.PI;
b2Settings.b2_maxManifoldPoints = 2;
b2Settings.b2_aabbExtension = 0.1;
b2Settings.b2_aabbMultiplier = 2;
b2Settings.b2_polygonRadius = 2 * b2Settings.b2_linearSlop;
b2Settings.b2_linearSlop = 0.0050;
b2Settings.b2_angularSlop = 2 / 180 * b2Settings.b2_pi;
b2Settings.b2_toiSlop = 8 * b2Settings.b2_linearSlop;
b2Settings.b2_maxTOIContactsPerIsland = 32;
b2Settings.b2_maxTOIJointsPerIsland = 32;
b2Settings.b2_velocityThreshold = 1;
b2Settings.b2_maxLinearCorrection = 0.2;
b2Settings.b2_maxAngularCorrection = 8 / 180 * b2Settings.b2_pi;
b2Settings.b2_maxTranslation = 2;
b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
b2Settings.b2_contactBaumgarte = 0.2;
b2Settings.b2_timeToSleep = 0.5;
b2Settings.b2_linearSleepTolerance = 0.01;
b2Settings.b2_angularSleepTolerance = 2 / 180 * b2Settings.b2_pi;var b2Proxy = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Proxy.prototype.__constructor = function() {
};
b2Proxy.prototype.__varz = function() {
  this.lowerBounds = new Array(2);
  this.upperBounds = new Array(2);
  this.pairs = new Object
};
b2Proxy.prototype.IsValid = function() {
  return this.overlapCount != b2BroadPhase.b2_invalid
};
b2Proxy.prototype.lowerBounds = new Array(2);
b2Proxy.prototype.upperBounds = new Array(2);
b2Proxy.prototype.overlapCount = 0;
b2Proxy.prototype.timeStamp = 0;
b2Proxy.prototype.pairs = new Object;
b2Proxy.prototype.next = null;
b2Proxy.prototype.userData = null;var b2Point = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Point.prototype.__constructor = function() {
};
b2Point.prototype.__varz = function() {
  this.p = new b2Vec2
};
b2Point.prototype.Support = function(xf, vX, vY) {
  return this.p
};
b2Point.prototype.GetFirstVertex = function(xf) {
  return this.p
};
b2Point.prototype.p = new b2Vec2;var b2WorldManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2WorldManifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2WorldManifold.prototype.__varz = function() {
  this.m_normal = new b2Vec2
};
b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  if(manifold.m_pointCount == 0) {
    return
  }
  var i = 0;
  var tVec;
  var tMat;
  var normalX;
  var normalY;
  var planePointX;
  var planePointY;
  var clipPointX;
  var clipPointY;
  switch(manifold.m_type) {
    case b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      var cAX = pointAX + radiusA * this.m_normal.x;
      var cAY = pointAY + radiusA * this.m_normal.y;
      var cBX = pointBX - radiusB * this.m_normal.x;
      var cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for(i = 0;i < manifold.m_pointCount;i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY
      }
      break
  }
};
b2WorldManifold.prototype.m_normal = new b2Vec2;
b2WorldManifold.prototype.m_points = null;var b2RayCastOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastOutput.prototype.__constructor = function() {
};
b2RayCastOutput.prototype.__varz = function() {
  this.normal = new b2Vec2
};
b2RayCastOutput.prototype.normal = new b2Vec2;
b2RayCastOutput.prototype.fraction = null;var b2ConstantForceController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2ConstantForceController.prototype, b2Controller.prototype);
b2ConstantForceController.prototype._super = b2Controller.prototype;
b2ConstantForceController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2ConstantForceController.prototype.__varz = function() {
  this.F = new b2Vec2(0, 0)
};
b2ConstantForceController.prototype.Step = function(step) {
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    body.ApplyForce(this.F, body.GetWorldCenter())
  }
};
b2ConstantForceController.prototype.F = new b2Vec2(0, 0);var b2MassData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2MassData.prototype.__constructor = function() {
};
b2MassData.prototype.__varz = function() {
  this.center = new b2Vec2(0, 0)
};
b2MassData.prototype.mass = 0;
b2MassData.prototype.center = new b2Vec2(0, 0);
b2MassData.prototype.I = 0;var b2DynamicTree = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTree.prototype.__constructor = function() {
  this.m_root = null;
  this.m_freeList = null;
  this.m_path = 0;
  this.m_insertionCount = 0
};
b2DynamicTree.prototype.__varz = function() {
};
b2DynamicTree.prototype.AllocateNode = function() {
  if(this.m_freeList) {
    var node = this.m_freeList;
    this.m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node
  }
  return new b2DynamicTreeNode
};
b2DynamicTree.prototype.FreeNode = function(node) {
  node.parent = this.m_freeList;
  this.m_freeList = node
};
b2DynamicTree.prototype.InsertLeaf = function(leaf) {
  ++this.m_insertionCount;
  if(this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return
  }
  var center = leaf.aabb.GetCenter();
  var sibling = this.m_root;
  if(sibling.IsLeaf() == false) {
    do {
      var child1 = sibling.child1;
      var child2 = sibling.child2;
      var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if(norm1 < norm2) {
        sibling = child1
      }else {
        sibling = child2
      }
    }while(sibling.IsLeaf() == false)
  }
  var node1 = sibling.parent;
  var node2 = this.AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if(node1) {
    if(sibling.parent.child1 == sibling) {
      node1.child1 = node2
    }else {
      node1.child2 = node2
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if(node1.aabb.Contains(node2.aabb)) {
        break
      }
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent
    }while(node1)
  }else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.m_root = node2
  }
};
b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
  if(leaf == this.m_root) {
    this.m_root = null;
    return
  }
  var node2 = leaf.parent;
  var node1 = node2.parent;
  var sibling;
  if(node2.child1 == leaf) {
    sibling = node2.child2
  }else {
    sibling = node2.child1
  }
  if(node1) {
    if(node1.child1 == node2) {
      node1.child1 = sibling
    }else {
      node1.child2 = sibling
    }
    sibling.parent = node1;
    this.FreeNode(node2);
    while(node1) {
      var oldAABB = node1.aabb;
      node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
      if(oldAABB.Contains(node1.aabb)) {
        break
      }
      node1 = node1.parent
    }
  }else {
    this.m_root = sibling;
    sibling.parent = null;
    this.FreeNode(node2)
  }
};
b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var node = this.AllocateNode();
  var extendX = b2Settings.b2_aabbExtension;
  var extendY = b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.InsertLeaf(node);
  return node
};
b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.RemoveLeaf(proxy);
  this.FreeNode(proxy)
};
b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  b2Settings.b2Assert(proxy.IsLeaf());
  if(proxy.aabb.Contains(aabb)) {
    return false
  }
  this.RemoveLeaf(proxy);
  var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.InsertLeaf(proxy);
  return true
};
b2DynamicTree.prototype.Rebalance = function(iterations) {
  if(this.m_root == null) {
    return
  }
  for(var i = 0;i < iterations;i++) {
    var node = this.m_root;
    var bit = 0;
    while(node.IsLeaf() == false) {
      node = this.m_path >> bit & 1 ? node.child2 : node.child1;
      bit = bit + 1 & 31
    }
    ++this.m_path;
    this.RemoveLeaf(node);
    this.InsertLeaf(node)
  }
};
b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb
};
b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2DynamicTree.prototype.Query = function(callback, aabb) {
  if(this.m_root == null) {
    return
  }
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(aabb)) {
      if(node.IsLeaf()) {
        var proceed = callback(node);
        if(!proceed) {
          return
        }
      }else {
        stack[count++] = node.child1;
        stack[count++] = node.child2
      }
    }
  }
};
b2DynamicTree.prototype.RayCast = function(callback, input) {
  if(this.m_root == null) {
    return
  }
  var p1 = input.p1;
  var p2 = input.p2;
  var r = b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var v = b2Math.CrossFV(1, r);
  var abs_v = b2Math.AbsV(v);
  var maxFraction = input.maxFraction;
  var segmentAABB = new b2AABB;
  var tX;
  var tY;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var stack = new Array;
  var count = 0;
  stack[count++] = this.m_root;
  while(count > 0) {
    var node = stack[--count];
    if(node.aabb.TestOverlap(segmentAABB) == false) {
      continue
    }
    var c = node.aabb.GetCenter();
    var h = node.aabb.GetExtents();
    var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if(separation > 0) {
      continue
    }
    if(node.IsLeaf()) {
      var subInput = new b2RayCastInput;
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = callback(subInput, node);
      if(maxFraction == 0) {
        return
      }
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY)
    }else {
      stack[count++] = node.child1;
      stack[count++] = node.child2
    }
  }
};
b2DynamicTree.prototype.m_root = null;
b2DynamicTree.prototype.m_freeList = null;
b2DynamicTree.prototype.m_path = 0;
b2DynamicTree.prototype.m_insertionCount = 0;var b2JointEdge = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointEdge.prototype.__constructor = function() {
};
b2JointEdge.prototype.__varz = function() {
};
b2JointEdge.prototype.other = null;
b2JointEdge.prototype.joint = null;
b2JointEdge.prototype.prev = null;
b2JointEdge.prototype.next = null;var b2RayCastInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2RayCastInput.prototype.__constructor = function() {
};
b2RayCastInput.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2RayCastInput.prototype.p1 = new b2Vec2;
b2RayCastInput.prototype.p2 = new b2Vec2;
b2RayCastInput.prototype.maxFraction = null;var Features = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
Features.prototype.__constructor = function() {
};
Features.prototype.__varz = function() {
};
Features.prototype.__defineGetter__("referenceEdge", function() {
  return this._referenceEdge
});
Features.prototype.__defineSetter__("referenceEdge", function(value) {
  this._referenceEdge = value;
  this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
});
Features.prototype.__defineGetter__("incidentEdge", function() {
  return this._incidentEdge
});
Features.prototype.__defineSetter__("incidentEdge", function(value) {
  this._incidentEdge = value;
  this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
});
Features.prototype.__defineGetter__("incidentVertex", function() {
  return this._incidentVertex
});
Features.prototype.__defineSetter__("incidentVertex", function(value) {
  this._incidentVertex = value;
  this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
});
Features.prototype.__defineGetter__("flip", function() {
  return this._flip
});
Features.prototype.__defineSetter__("flip", function(value) {
  this._flip = value;
  this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
});
Features.prototype._referenceEdge = 0;
Features.prototype._incidentEdge = 0;
Features.prototype._incidentVertex = 0;
Features.prototype._flip = 0;
Features.prototype._m_id = null;var b2FilterData = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FilterData.prototype.__constructor = function() {
};
b2FilterData.prototype.__varz = function() {
  this.categoryBits = 1;
  this.maskBits = 65535
};
b2FilterData.prototype.Copy = function() {
  var copy = new b2FilterData;
  copy.categoryBits = this.categoryBits;
  copy.maskBits = this.maskBits;
  copy.groupIndex = this.groupIndex;
  return copy
};
b2FilterData.prototype.categoryBits = 1;
b2FilterData.prototype.maskBits = 65535;
b2FilterData.prototype.groupIndex = 0;var b2AABB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2AABB.prototype.__constructor = function() {
};
b2AABB.prototype.__varz = function() {
  this.lowerBound = new b2Vec2;
  this.upperBound = new b2Vec2
};
b2AABB.Combine = function(aabb1, aabb2) {
  var aabb = new b2AABB;
  aabb.Combine(aabb1, aabb2);
  return aabb
};
b2AABB.prototype.IsValid = function() {
  var dX = this.upperBound.x - this.lowerBound.x;
  var dY = this.upperBound.y - this.lowerBound.y;
  var valid = dX >= 0 && dY >= 0;
  valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
  return valid
};
b2AABB.prototype.GetCenter = function() {
  return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
};
b2AABB.prototype.GetExtents = function() {
  return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
};
b2AABB.prototype.Contains = function(aabb) {
  var result = true && this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
  return result
};
b2AABB.prototype.RayCast = function(output, input) {
  var tmin = -Number.MAX_VALUE;
  var tmax = Number.MAX_VALUE;
  var pX = input.p1.x;
  var pY = input.p1.y;
  var dX = input.p2.x - input.p1.x;
  var dY = input.p2.y - input.p1.y;
  var absDX = Math.abs(dX);
  var absDY = Math.abs(dY);
  var normal = output.normal;
  var inv_d;
  var t1;
  var t2;
  var t3;
  var s;
  if(absDX < Number.MIN_VALUE) {
    if(pX < this.lowerBound.x || this.upperBound.x < pX) {
      return false
    }
  }else {
    inv_d = 1 / dX;
    t1 = (this.lowerBound.x - pX) * inv_d;
    t2 = (this.upperBound.x - pX) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.x = s;
      normal.y = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  if(absDY < Number.MIN_VALUE) {
    if(pY < this.lowerBound.y || this.upperBound.y < pY) {
      return false
    }
  }else {
    inv_d = 1 / dY;
    t1 = (this.lowerBound.y - pY) * inv_d;
    t2 = (this.upperBound.y - pY) * inv_d;
    s = -1;
    if(t1 > t2) {
      t3 = t1;
      t1 = t2;
      t2 = t3;
      s = 1
    }
    if(t1 > tmin) {
      normal.y = s;
      normal.x = 0;
      tmin = t1
    }
    tmax = Math.min(tmax, t2);
    if(tmin > tmax) {
      return false
    }
  }
  output.fraction = tmin;
  return true
};
b2AABB.prototype.TestOverlap = function(other) {
  var d1X = other.lowerBound.x - this.upperBound.x;
  var d1Y = other.lowerBound.y - this.upperBound.y;
  var d2X = this.lowerBound.x - other.upperBound.x;
  var d2Y = this.lowerBound.y - other.upperBound.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2AABB.prototype.Combine = function(aabb1, aabb2) {
  this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
  this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
  this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
  this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y)
};
b2AABB.prototype.lowerBound = new b2Vec2;
b2AABB.prototype.upperBound = new b2Vec2;var b2Jacobian = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Jacobian.prototype.__constructor = function() {
};
b2Jacobian.prototype.__varz = function() {
  this.linearA = new b2Vec2;
  this.linearB = new b2Vec2
};
b2Jacobian.prototype.SetZero = function() {
  this.linearA.SetZero();
  this.angularA = 0;
  this.linearB.SetZero();
  this.angularB = 0
};
b2Jacobian.prototype.Set = function(x1, a1, x2, a2) {
  this.linearA.SetV(x1);
  this.angularA = a1;
  this.linearB.SetV(x2);
  this.angularB = a2
};
b2Jacobian.prototype.Compute = function(x1, a1, x2, a2) {
  return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2
};
b2Jacobian.prototype.linearA = new b2Vec2;
b2Jacobian.prototype.angularA = null;
b2Jacobian.prototype.linearB = new b2Vec2;
b2Jacobian.prototype.angularB = null;var b2Bound = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Bound.prototype.__constructor = function() {
};
b2Bound.prototype.__varz = function() {
};
b2Bound.prototype.IsLower = function() {
  return(this.value & 1) == 0
};
b2Bound.prototype.IsUpper = function() {
  return(this.value & 1) == 1
};
b2Bound.prototype.Swap = function(b) {
  var tempValue = this.value;
  var tempProxy = this.proxy;
  var tempStabbingCount = this.stabbingCount;
  this.value = b.value;
  this.proxy = b.proxy;
  this.stabbingCount = b.stabbingCount;
  b.value = tempValue;
  b.proxy = tempProxy;
  b.stabbingCount = tempStabbingCount
};
b2Bound.prototype.value = 0;
b2Bound.prototype.proxy = null;
b2Bound.prototype.stabbingCount = 0;var b2SimplexVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexVertex.prototype.__constructor = function() {
};
b2SimplexVertex.prototype.__varz = function() {
};
b2SimplexVertex.prototype.Set = function(other) {
  this.wA.SetV(other.wA);
  this.wB.SetV(other.wB);
  this.w.SetV(other.w);
  this.a = other.a;
  this.indexA = other.indexA;
  this.indexB = other.indexB
};
b2SimplexVertex.prototype.wA = null;
b2SimplexVertex.prototype.wB = null;
b2SimplexVertex.prototype.w = null;
b2SimplexVertex.prototype.a = null;
b2SimplexVertex.prototype.indexA = 0;
b2SimplexVertex.prototype.indexB = 0;var b2Mat22 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat22.prototype.__constructor = function() {
  this.col1.x = this.col2.y = 1
};
b2Mat22.prototype.__varz = function() {
  this.col1 = new b2Vec2;
  this.col2 = new b2Vec2
};
b2Mat22.FromAngle = function(angle) {
  var mat = new b2Mat22;
  mat.Set(angle);
  return mat
};
b2Mat22.FromVV = function(c1, c2) {
  var mat = new b2Mat22;
  mat.SetVV(c1, c2);
  return mat
};
b2Mat22.prototype.Set = function(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  this.col1.x = c;
  this.col2.x = -s;
  this.col1.y = s;
  this.col2.y = c
};
b2Mat22.prototype.SetVV = function(c1, c2) {
  this.col1.SetV(c1);
  this.col2.SetV(c2)
};
b2Mat22.prototype.Copy = function() {
  var mat = new b2Mat22;
  mat.SetM(this);
  return mat
};
b2Mat22.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2)
};
b2Mat22.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y
};
b2Mat22.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 1
};
b2Mat22.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col1.y = 0;
  this.col2.y = 0
};
b2Mat22.prototype.GetAngle = function() {
  return Math.atan2(this.col1.y, this.col1.x)
};
b2Mat22.prototype.GetInverse = function(out) {
  var a = this.col1.x;
  var b = this.col2.x;
  var c = this.col1.y;
  var d = this.col2.y;
  var det = a * d - b * c;
  if(det != 0) {
    det = 1 / det
  }
  out.col1.x = det * d;
  out.col2.x = -det * b;
  out.col1.y = -det * c;
  out.col2.y = det * a;
  return out
};
b2Mat22.prototype.Solve = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat22.prototype.Abs = function() {
  this.col1.Abs();
  this.col2.Abs()
};
b2Mat22.prototype.col1 = new b2Vec2;
b2Mat22.prototype.col2 = new b2Vec2;var b2SimplexCache = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2SimplexCache.prototype.__constructor = function() {
};
b2SimplexCache.prototype.__varz = function() {
  this.indexA = new Array(3);
  this.indexB = new Array(3)
};
b2SimplexCache.prototype.metric = null;
b2SimplexCache.prototype.count = 0;
b2SimplexCache.prototype.indexA = new Array(3);
b2SimplexCache.prototype.indexB = new Array(3);var b2Shape = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Shape.prototype.__constructor = function() {
  this.m_type = b2Shape.e_unknownShape;
  this.m_radius = b2Settings.b2_linearSlop
};
b2Shape.prototype.__varz = function() {
};
b2Shape.TestOverlap = function(shape1, transform1, shape2, transform2) {
  var input = new b2DistanceInput;
  input.proxyA = new b2DistanceProxy;
  input.proxyA.Set(shape1);
  input.proxyB = new b2DistanceProxy;
  input.proxyB.Set(shape2);
  input.transformA = transform1;
  input.transformB = transform2;
  input.useRadii = true;
  var simplexCache = new b2SimplexCache;
  simplexCache.count = 0;
  var output = new b2DistanceOutput;
  b2Distance.Distance(output, simplexCache, input);
  return output.distance < 10 * Number.MIN_VALUE
};
b2Shape.e_hitCollide = 1;
b2Shape.e_missCollide = 0;
b2Shape.e_startsInsideCollide = -1;
b2Shape.e_unknownShape = -1;
b2Shape.e_circleShape = 0;
b2Shape.e_polygonShape = 1;
b2Shape.e_edgeShape = 2;
b2Shape.e_shapeTypeCount = 3;
b2Shape.prototype.Copy = function() {
  return null
};
b2Shape.prototype.Set = function(other) {
  this.m_radius = other.m_radius
};
b2Shape.prototype.GetType = function() {
  return this.m_type
};
b2Shape.prototype.TestPoint = function(xf, p) {
  return false
};
b2Shape.prototype.RayCast = function(output, input, transform) {
  return false
};
b2Shape.prototype.ComputeAABB = function(aabb, xf) {
};
b2Shape.prototype.ComputeMass = function(massData, density) {
};
b2Shape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  return 0
};
b2Shape.prototype.m_type = 0;
b2Shape.prototype.m_radius = null;var b2Segment = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Segment.prototype.__constructor = function() {
};
b2Segment.prototype.__varz = function() {
  this.p1 = new b2Vec2;
  this.p2 = new b2Vec2
};
b2Segment.prototype.TestSegment = function(lambda, normal, segment, maxLambda) {
  var s = segment.p1;
  var rX = segment.p2.x - s.x;
  var rY = segment.p2.y - s.y;
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var nX = dY;
  var nY = -dX;
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = s.x - this.p1.x;
    var bY = s.y - this.p1.y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= maxLambda * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        nX /= nLen;
        nY /= nLen;
        lambda[0] = a;
        normal.Set(nX, nY);
        return true
      }
    }
  }
  return false
};
b2Segment.prototype.Extend = function(aabb) {
  this.ExtendForward(aabb);
  this.ExtendBackward(aabb)
};
b2Segment.prototype.ExtendForward = function(aabb) {
  var dX = this.p2.x - this.p1.x;
  var dY = this.p2.y - this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
  this.p2.x = this.p1.x + dX * lambda;
  this.p2.y = this.p1.y + dY * lambda
};
b2Segment.prototype.ExtendBackward = function(aabb) {
  var dX = -this.p2.x + this.p1.x;
  var dY = -this.p2.y + this.p1.y;
  var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
  this.p1.x = this.p2.x + dX * lambda;
  this.p1.y = this.p2.y + dY * lambda
};
b2Segment.prototype.p1 = new b2Vec2;
b2Segment.prototype.p2 = new b2Vec2;var b2ContactRegister = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactRegister.prototype.__constructor = function() {
};
b2ContactRegister.prototype.__varz = function() {
};
b2ContactRegister.prototype.createFcn = null;
b2ContactRegister.prototype.destroyFcn = null;
b2ContactRegister.prototype.primary = null;
b2ContactRegister.prototype.pool = null;
b2ContactRegister.prototype.poolCount = 0;var b2DebugDraw = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DebugDraw.prototype.__constructor = function() {
  this.m_drawFlags = 0
};
b2DebugDraw.prototype.__varz = function() {
};
b2DebugDraw.e_shapeBit = 1;
b2DebugDraw.e_jointBit = 2;
b2DebugDraw.e_aabbBit = 4;
b2DebugDraw.e_pairBit = 8;
b2DebugDraw.e_centerOfMassBit = 16;
b2DebugDraw.e_controllerBit = 32;
b2DebugDraw.prototype.SetFlags = function(flags) {
  this.m_drawFlags = flags
};
b2DebugDraw.prototype.GetFlags = function() {
  return this.m_drawFlags
};
b2DebugDraw.prototype.AppendFlags = function(flags) {
  this.m_drawFlags |= flags
};
b2DebugDraw.prototype.ClearFlags = function(flags) {
  this.m_drawFlags &= ~flags
};
b2DebugDraw.prototype.SetSprite = function(sprite) {
  this.m_sprite = sprite
};
b2DebugDraw.prototype.GetSprite = function() {
  return this.m_sprite
};
b2DebugDraw.prototype.SetDrawScale = function(drawScale) {
  this.m_drawScale = drawScale
};
b2DebugDraw.prototype.GetDrawScale = function() {
  return this.m_drawScale
};
b2DebugDraw.prototype.SetLineThickness = function(lineThickness) {
  this.m_lineThickness = lineThickness
};
b2DebugDraw.prototype.GetLineThickness = function() {
  return this.m_lineThickness
};
b2DebugDraw.prototype.SetAlpha = function(alpha) {
  this.m_alpha = alpha
};
b2DebugDraw.prototype.GetAlpha = function() {
  return this.m_alpha
};
b2DebugDraw.prototype.SetFillAlpha = function(alpha) {
  this.m_fillAlpha = alpha
};
b2DebugDraw.prototype.GetFillAlpha = function() {
  return this.m_fillAlpha
};
b2DebugDraw.prototype.SetXFormScale = function(xformScale) {
  this.m_xformScale = xformScale
};
b2DebugDraw.prototype.GetXFormScale = function() {
  return this.m_xformScale
};
b2DebugDraw.prototype.Clear = function() {
  this.m_sprite.clearRect(0, 0, this.m_sprite.canvas.width, this.m_sprite.canvas.height)
};
b2DebugDraw.prototype.Y = function(y) {
  return this.m_sprite.canvas.height - y
};
b2DebugDraw.prototype.ToWorldPoint = function(localPoint) {
  return new b2Vec2(localPoint.x / this.m_drawScale, this.Y(localPoint.y) / this.m_drawScale)
};
b2DebugDraw.prototype.ColorStyle = function(color, alpha) {
  return"rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + alpha + ")"
};
b2DebugDraw.prototype.DrawPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.moveTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale);
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.graphics.lineTo(vertices[i].x * this.m_drawScale, vertices[i].y * this.m_drawScale)
  }
  this.m_sprite.graphics.lineTo(vertices[0].x * this.m_drawScale, vertices[0].y * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidPolygon = function(vertices, vertexCount, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  for(var i = 1;i < vertexCount;i++) {
    this.m_sprite.lineTo(vertices[i].x * this.m_drawScale, this.Y(vertices[i].y * this.m_drawScale))
  }
  this.m_sprite.lineTo(vertices[0].x * this.m_drawScale, this.Y(vertices[0].y * this.m_drawScale));
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawCircle = function(center, radius, color) {
  this.m_sprite.graphics.lineStyle(this.m_lineThickness, color.color, this.m_alpha);
  this.m_sprite.graphics.drawCircle(center.x * this.m_drawScale, center.y * this.m_drawScale, radius * this.m_drawScale)
};
b2DebugDraw.prototype.DrawSolidCircle = function(center, radius, axis, color) {
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.fillStyle = this.ColorStyle(color, this.m_fillAlpha);
  this.m_sprite.beginPath();
  this.m_sprite.arc(center.x * this.m_drawScale, this.Y(center.y * this.m_drawScale), radius * this.m_drawScale, 0, Math.PI * 2, true);
  this.m_sprite.fill();
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawSegment = function(p1, p2, color) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(color, this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(p1.x * this.m_drawScale, this.Y(p1.y * this.m_drawScale));
  this.m_sprite.lineTo(p2.x * this.m_drawScale, this.Y(p2.y * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.DrawTransform = function(xf) {
  this.m_sprite.lineWidth = this.m_lineThickness;
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(255, 0, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col1.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath();
  this.m_sprite.strokeSyle = this.ColorStyle(new b2Color(0, 255, 0), this.m_alpha);
  this.m_sprite.beginPath();
  this.m_sprite.moveTo(xf.position.x * this.m_drawScale, this.Y(xf.position.y * this.m_drawScale));
  this.m_sprite.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * this.m_drawScale, this.Y((xf.position.y + this.m_xformScale * xf.R.col2.y) * this.m_drawScale));
  this.m_sprite.stroke();
  this.m_sprite.closePath()
};
b2DebugDraw.prototype.m_drawFlags = 0;
b2DebugDraw.prototype.m_sprite = null;
b2DebugDraw.prototype.m_drawScale = 1;
b2DebugDraw.prototype.m_lineThickness = 1;
b2DebugDraw.prototype.m_alpha = 1;
b2DebugDraw.prototype.m_fillAlpha = 1;
b2DebugDraw.prototype.m_xformScale = 1;var b2Sweep = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Sweep.prototype.__constructor = function() {
};
b2Sweep.prototype.__varz = function() {
  this.localCenter = new b2Vec2;
  this.c0 = new b2Vec2;
  this.c = new b2Vec2
};
b2Sweep.prototype.Set = function(other) {
  this.localCenter.SetV(other.localCenter);
  this.c0.SetV(other.c0);
  this.c.SetV(other.c);
  this.a0 = other.a0;
  this.a = other.a;
  this.t0 = other.t0
};
b2Sweep.prototype.Copy = function() {
  var copy = new b2Sweep;
  copy.localCenter.SetV(this.localCenter);
  copy.c0.SetV(this.c0);
  copy.c.SetV(this.c);
  copy.a0 = this.a0;
  copy.a = this.a;
  copy.t0 = this.t0;
  return copy
};
b2Sweep.prototype.GetTransform = function(xf, alpha) {
  xf.position.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
  xf.position.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
  var angle = (1 - alpha) * this.a0 + alpha * this.a;
  xf.R.Set(angle);
  var tMat = xf.R;
  xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
  xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y
};
b2Sweep.prototype.Advance = function(t) {
  if(this.t0 < t && 1 - this.t0 > Number.MIN_VALUE) {
    var alpha = (t - this.t0) / (1 - this.t0);
    this.c0.x = (1 - alpha) * this.c0.x + alpha * this.c.x;
    this.c0.y = (1 - alpha) * this.c0.y + alpha * this.c.y;
    this.a0 = (1 - alpha) * this.a0 + alpha * this.a;
    this.t0 = t
  }
};
b2Sweep.prototype.localCenter = new b2Vec2;
b2Sweep.prototype.c0 = new b2Vec2;
b2Sweep.prototype.c = new b2Vec2;
b2Sweep.prototype.a0 = null;
b2Sweep.prototype.a = null;
b2Sweep.prototype.t0 = null;var b2DistanceOutput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DistanceOutput.prototype.__constructor = function() {
};
b2DistanceOutput.prototype.__varz = function() {
  this.pointA = new b2Vec2;
  this.pointB = new b2Vec2
};
b2DistanceOutput.prototype.pointA = new b2Vec2;
b2DistanceOutput.prototype.pointB = new b2Vec2;
b2DistanceOutput.prototype.distance = null;
b2DistanceOutput.prototype.iterations = 0;var b2Mat33 = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Mat33.prototype.__constructor = function(c1, c2, c3) {
  if(!c1 && !c2 && !c3) {
    this.col1.SetZero();
    this.col2.SetZero();
    this.col3.SetZero()
  }else {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3)
  }
};
b2Mat33.prototype.__varz = function() {
  this.col1 = new b2Vec3;
  this.col2 = new b2Vec3;
  this.col3 = new b2Vec3
};
b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
  this.col1.SetV(c1);
  this.col2.SetV(c2);
  this.col3.SetV(c3)
};
b2Mat33.prototype.Copy = function() {
  return new b2Mat33(this.col1, this.col2, this.col3)
};
b2Mat33.prototype.SetM = function(m) {
  this.col1.SetV(m.col1);
  this.col2.SetV(m.col2);
  this.col3.SetV(m.col3)
};
b2Mat33.prototype.AddM = function(m) {
  this.col1.x += m.col1.x;
  this.col1.y += m.col1.y;
  this.col1.z += m.col1.z;
  this.col2.x += m.col2.x;
  this.col2.y += m.col2.y;
  this.col2.z += m.col2.z;
  this.col3.x += m.col3.x;
  this.col3.y += m.col3.y;
  this.col3.z += m.col3.z
};
b2Mat33.prototype.SetIdentity = function() {
  this.col1.x = 1;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 1;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 1
};
b2Mat33.prototype.SetZero = function() {
  this.col1.x = 0;
  this.col2.x = 0;
  this.col3.x = 0;
  this.col1.y = 0;
  this.col2.y = 0;
  this.col3.y = 0;
  this.col1.z = 0;
  this.col2.z = 0;
  this.col3.z = 0
};
b2Mat33.prototype.Solve22 = function(out, bX, bY) {
  var a11 = this.col1.x;
  var a12 = this.col2.x;
  var a21 = this.col1.y;
  var a22 = this.col2.y;
  var det = a11 * a22 - a12 * a21;
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (a22 * bX - a12 * bY);
  out.y = det * (a11 * bY - a21 * bX);
  return out
};
b2Mat33.prototype.Solve33 = function(out, bX, bY, bZ) {
  var a11 = this.col1.x;
  var a21 = this.col1.y;
  var a31 = this.col1.z;
  var a12 = this.col2.x;
  var a22 = this.col2.y;
  var a32 = this.col2.z;
  var a13 = this.col3.x;
  var a23 = this.col3.y;
  var a33 = this.col3.z;
  var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
  if(det != 0) {
    det = 1 / det
  }
  out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
  out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
  out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
  return out
};
b2Mat33.prototype.col1 = new b2Vec3;
b2Mat33.prototype.col2 = new b2Vec3;
b2Mat33.prototype.col3 = new b2Vec3;var b2PositionSolverManifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2PositionSolverManifold.prototype.__constructor = function() {
  this.m_normal = new b2Vec2;
  this.m_separations = new Array(b2Settings.b2_maxManifoldPoints);
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2Vec2
  }
};
b2PositionSolverManifold.prototype.__varz = function() {
};
b2PositionSolverManifold.circlePointA = new b2Vec2;
b2PositionSolverManifold.circlePointB = new b2Vec2;
b2PositionSolverManifold.prototype.Initialize = function(cc) {
  b2Settings.b2Assert(cc.pointCount > 0);
  var i = 0;
  var clipPointX;
  var clipPointY;
  var tMat;
  var tVec;
  var planePointX;
  var planePointY;
  switch(cc.type) {
    case b2Manifold.e_circles:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.points[0].localPoint;
      var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = pointBX - pointAX;
      var dY = pointBY - pointAY;
      var d2 = dX * dX + dY * dY;
      if(d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d
      }else {
        this.m_normal.x = 1;
        this.m_normal.y = 0
      }
      this.m_points[0].x = 0.5 * (pointAX + pointBX);
      this.m_points[0].y = 0.5 * (pointAY + pointBY);
      this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
      break;
    case b2Manifold.e_faceA:
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyA.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyB.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].x = clipPointX;
        this.m_points[i].y = clipPointY
      }
      break;
    case b2Manifold.e_faceB:
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPlaneNormal;
      this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = cc.bodyB.m_xf.R;
      tVec = cc.localPoint;
      planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = cc.bodyA.m_xf.R;
      for(i = 0;i < cc.pointCount;++i) {
        tVec = cc.points[i].localPoint;
        clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
        this.m_points[i].Set(clipPointX, clipPointY)
      }
      this.m_normal.x *= -1;
      this.m_normal.y *= -1;
      break
  }
};
b2PositionSolverManifold.prototype.m_normal = null;
b2PositionSolverManifold.prototype.m_points = null;
b2PositionSolverManifold.prototype.m_separations = null;var b2OBB = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2OBB.prototype.__constructor = function() {
};
b2OBB.prototype.__varz = function() {
  this.R = new b2Mat22;
  this.center = new b2Vec2;
  this.extents = new b2Vec2
};
b2OBB.prototype.R = new b2Mat22;
b2OBB.prototype.center = new b2Vec2;
b2OBB.prototype.extents = new b2Vec2;var b2Pair = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Pair.prototype.__constructor = function() {
};
b2Pair.prototype.__varz = function() {
};
b2Pair.b2_nullProxy = b2Settings.USHRT_MAX;
b2Pair.e_pairBuffered = 1;
b2Pair.e_pairRemoved = 2;
b2Pair.e_pairFinal = 4;
b2Pair.prototype.SetBuffered = function() {
  this.status |= b2Pair.e_pairBuffered
};
b2Pair.prototype.ClearBuffered = function() {
  this.status &= ~b2Pair.e_pairBuffered
};
b2Pair.prototype.IsBuffered = function() {
  return(this.status & b2Pair.e_pairBuffered) == b2Pair.e_pairBuffered
};
b2Pair.prototype.SetRemoved = function() {
  this.status |= b2Pair.e_pairRemoved
};
b2Pair.prototype.ClearRemoved = function() {
  this.status &= ~b2Pair.e_pairRemoved
};
b2Pair.prototype.IsRemoved = function() {
  return(this.status & b2Pair.e_pairRemoved) == b2Pair.e_pairRemoved
};
b2Pair.prototype.SetFinal = function() {
  this.status |= b2Pair.e_pairFinal
};
b2Pair.prototype.IsFinal = function() {
  return(this.status & b2Pair.e_pairFinal) == b2Pair.e_pairFinal
};
b2Pair.prototype.userData = null;
b2Pair.prototype.proxy1 = null;
b2Pair.prototype.proxy2 = null;
b2Pair.prototype.next = null;
b2Pair.prototype.status = 0;var b2FixtureDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2FixtureDef.prototype.__constructor = function() {
  this.shape = null;
  this.userData = null;
  this.friction = 0.2;
  this.restitution = 0;
  this.density = 0;
  this.filter.categoryBits = 1;
  this.filter.maskBits = 65535;
  this.filter.groupIndex = 0;
  this.isSensor = false
};
b2FixtureDef.prototype.__varz = function() {
  this.filter = new b2FilterData
};
b2FixtureDef.prototype.shape = null;
b2FixtureDef.prototype.userData = null;
b2FixtureDef.prototype.friction = null;
b2FixtureDef.prototype.restitution = null;
b2FixtureDef.prototype.density = null;
b2FixtureDef.prototype.isSensor = null;
b2FixtureDef.prototype.filter = new b2FilterData;var b2ContactID = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactID.prototype.__constructor = function() {
  this.features._m_id = this
};
b2ContactID.prototype.__varz = function() {
  this.features = new Features
};
b2ContactID.prototype.Set = function(id) {
  key = id._key
};
b2ContactID.prototype.Copy = function() {
  var id = new b2ContactID;
  id.key = key;
  return id
};
b2ContactID.prototype.__defineSetter__("key", function() {
  return this._key
});
b2ContactID.prototype.__defineSetter__("key", function(value) {
  this._key = value;
  this.features._referenceEdge = this._key & 255;
  this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
  this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
  this.features._flip = (this._key & 4278190080) >> 24 & 255
});
b2ContactID.prototype._key = 0;
b2ContactID.prototype.features = new Features;var b2Transform = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Transform.prototype.__constructor = function(pos, r) {
  if(pos) {
    this.position.SetV(pos);
    this.R.SetM(r)
  }
};
b2Transform.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.R = new b2Mat22
};
b2Transform.prototype.Initialize = function(pos, r) {
  this.position.SetV(pos);
  this.R.SetM(r)
};
b2Transform.prototype.SetIdentity = function() {
  this.position.SetZero();
  this.R.SetIdentity()
};
b2Transform.prototype.Set = function(x) {
  this.position.SetV(x.position);
  this.R.SetM(x.R)
};
b2Transform.prototype.GetAngle = function() {
  return Math.atan2(this.R.col1.y, this.R.col1.x)
};
b2Transform.prototype.position = new b2Vec2;
b2Transform.prototype.R = new b2Mat22;var b2EdgeShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeShape.prototype, b2Shape.prototype);
b2EdgeShape.prototype._super = b2Shape.prototype;
b2EdgeShape.prototype.__constructor = function(v1, v2) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
};
b2EdgeShape.prototype.__varz = function() {
  this.s_supportVec = new b2Vec2;
  this.m_v1 = new b2Vec2;
  this.m_v2 = new b2Vec2;
  this.m_coreV1 = new b2Vec2;
  this.m_coreV2 = new b2Vec2;
  this.m_normal = new b2Vec2;
  this.m_direction = new b2Vec2;
  this.m_cornerDir1 = new b2Vec2;
  this.m_cornerDir2 = new b2Vec2
};
b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex
};
b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex
};
b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false
};
b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var tMat;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var k_slop = 100 * Number.MIN_VALUE;
  var denom = -(rX * nX + rY * nY);
  if(denom > k_slop) {
    var bX = input.p1.x - v1X;
    var bY = input.p1.y - v1Y;
    var a = bX * nX + bY * nY;
    if(0 <= a && a <= input.maxFraction * denom) {
      var mu2 = -rX * bY + rY * bX;
      if(-k_slop * denom <= mu2 && mu2 <= denom * (1 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true
      }
    }
  }
  return false
};
b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if(v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X
  }else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X
  }
  if(v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y
  }else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y
  }
};
b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0
};
b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
  var v1 = b2Math.MulX(xf, this.m_v1);
  var v2 = b2Math.MulX(xf, this.m_v2);
  var d1 = b2Math.Dot(normal, v1) - offset;
  var d2 = b2Math.Dot(normal, v2) - offset;
  if(d1 > 0) {
    if(d2 > 0) {
      return 0
    }else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }
  }else {
    if(d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y
    }else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x))
};
b2EdgeShape.prototype.GetLength = function() {
  return this.m_length
};
b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1
};
b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2
};
b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1
};
b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2
};
b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal
};
b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction
};
b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1
};
b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2
};
b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1
};
b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2
};
b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var tMat = xf.R;
  return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y))
};
b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge
};
b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge
};
b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var tMat = xf.R;
  var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if(v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
    this.s_supportVec.x = v1X;
    this.s_supportVec.y = v1Y
  }else {
    this.s_supportVec.x = v2X;
    this.s_supportVec.y = v2Y
  }
  return this.s_supportVec
};
b2EdgeShape.prototype.s_supportVec = new b2Vec2;
b2EdgeShape.prototype.m_v1 = new b2Vec2;
b2EdgeShape.prototype.m_v2 = new b2Vec2;
b2EdgeShape.prototype.m_coreV1 = new b2Vec2;
b2EdgeShape.prototype.m_coreV2 = new b2Vec2;
b2EdgeShape.prototype.m_length = null;
b2EdgeShape.prototype.m_normal = new b2Vec2;
b2EdgeShape.prototype.m_direction = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir1 = new b2Vec2;
b2EdgeShape.prototype.m_cornerDir2 = new b2Vec2;
b2EdgeShape.prototype.m_cornerConvex1 = null;
b2EdgeShape.prototype.m_cornerConvex2 = null;
b2EdgeShape.prototype.m_nextEdge = null;
b2EdgeShape.prototype.m_prevEdge = null;var b2BuoyancyController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2BuoyancyController.prototype, b2Controller.prototype);
b2BuoyancyController.prototype._super = b2Controller.prototype;
b2BuoyancyController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2BuoyancyController.prototype.__varz = function() {
  this.normal = new b2Vec2(0, -1);
  this.velocity = new b2Vec2(0, 0)
};
b2BuoyancyController.prototype.Step = function(step) {
  if(!m_bodyList) {
    return
  }
  if(this.useWorldGravity) {
    this.gravity = this.GetWorld().GetGravity().Copy()
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(body.IsAwake() == false) {
      continue
    }
    var areac = new b2Vec2;
    var massc = new b2Vec2;
    var area = 0;
    var mass = 0;
    for(var fixture = body.GetFixtureList();fixture;fixture = fixture.GetNext()) {
      var sc = new b2Vec2;
      var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
      area += sarea;
      areac.x += sarea * sc.x;
      areac.y += sarea * sc.y;
      var shapeDensity;
      if(this.useDensity) {
        shapeDensity = 1
      }else {
        shapeDensity = 1
      }
      mass += sarea * shapeDensity;
      massc.x += sarea * sc.x * shapeDensity;
      massc.y += sarea * sc.y * shapeDensity
    }
    areac.x /= area;
    areac.y /= area;
    massc.x /= mass;
    massc.y /= mass;
    if(area < Number.MIN_VALUE) {
      continue
    }
    var buoyancyForce = this.gravity.GetNegative();
    buoyancyForce.Multiply(this.density * area);
    body.ApplyForce(buoyancyForce, massc);
    var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
    dragForce.Subtract(this.velocity);
    dragForce.Multiply(-this.linearDrag * area);
    body.ApplyForce(dragForce, areac);
    body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag)
  }
};
b2BuoyancyController.prototype.Draw = function(debugDraw) {
  var r = 1E3;
  var p1 = new b2Vec2;
  var p2 = new b2Vec2;
  p1.x = this.normal.x * this.offset + this.normal.y * r;
  p1.y = this.normal.y * this.offset - this.normal.x * r;
  p2.x = this.normal.x * this.offset - this.normal.y * r;
  p2.y = this.normal.y * this.offset + this.normal.x * r;
  var color = new b2Color(0, 0, 1);
  debugDraw.DrawSegment(p1, p2, color)
};
b2BuoyancyController.prototype.normal = new b2Vec2(0, -1);
b2BuoyancyController.prototype.offset = 0;
b2BuoyancyController.prototype.density = 0;
b2BuoyancyController.prototype.velocity = new b2Vec2(0, 0);
b2BuoyancyController.prototype.linearDrag = 2;
b2BuoyancyController.prototype.angularDrag = 1;
b2BuoyancyController.prototype.useDensity = false;
b2BuoyancyController.prototype.useWorldGravity = true;
b2BuoyancyController.prototype.gravity = null;var b2Body = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Body.prototype.__constructor = function(bd, world) {
  this.m_flags = 0;
  if(bd.bullet) {
    this.m_flags |= b2Body.e_bulletFlag
  }
  if(bd.fixedRotation) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }
  if(bd.allowSleep) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }
  if(bd.awake) {
    this.m_flags |= b2Body.e_awakeFlag
  }
  if(bd.active) {
    this.m_flags |= b2Body.e_activeFlag
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0, 0);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type;
  if(this.m_type == b2Body.b2_dynamicBody) {
    this.m_mass = 1;
    this.m_invMass = 1
  }else {
    this.m_mass = 0;
    this.m_invMass = 0
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_inertiaScale = bd.inertiaScale;
  this.m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0
};
b2Body.prototype.__varz = function() {
  this.m_xf = new b2Transform;
  this.m_sweep = new b2Sweep;
  this.m_linearVelocity = new b2Vec2;
  this.m_force = new b2Vec2
};
b2Body.b2_staticBody = 0;
b2Body.b2_kinematicBody = 1;
b2Body.b2_dynamicBody = 2;
b2Body.s_xf1 = new b2Transform;
b2Body.e_islandFlag = 1;
b2Body.e_awakeFlag = 2;
b2Body.e_allowSleepFlag = 4;
b2Body.e_bulletFlag = 8;
b2Body.e_fixedRotationFlag = 16;
b2Body.e_activeFlag = 32;
b2Body.prototype.connectEdges = function(s1, s2, angle1) {
  var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = b2Math.SubtractVV(core, s2.GetNormalVector());
  core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
  core = b2Math.AddVV(core, s2.GetVertex1());
  var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2
};
b2Body.prototype.SynchronizeFixtures = function() {
  var xf1 = b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var tMat = xf1.R;
  var tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var f;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf)
  }
};
b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
};
b2Body.prototype.ShouldCollide = function(other) {
  if(this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
    return false
  }
  for(var jn = this.m_jointList;jn;jn = jn.next) {
    if(jn.other == other) {
      if(jn.joint.m_collideConnected == false) {
        return false
      }
    }
  }
  return true
};
b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform()
};
b2Body.prototype.CreateFixture = function(def) {
  if(this.m_world.IsLocked() == true) {
    return null
  }
  var fixture = new b2Fixture;
  fixture.Create(this, this.m_xf, def);
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf)
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if(fixture.m_density > 0) {
    this.ResetMassData()
  }
  this.m_world.m_flags |= b2World.e_newFixture;
  return fixture
};
b2Body.prototype.CreateFixture2 = function(shape, density) {
  var def = new b2FixtureDef;
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def)
};
b2Body.prototype.DestroyFixture = function(fixture) {
  if(this.m_world.IsLocked() == true) {
    return
  }
  var node = this.m_fixtureList;
  var ppF = null;
  var found = false;
  while(node != null) {
    if(node == fixture) {
      if(ppF) {
        ppF.m_next = fixture.m_next
      }else {
        this.m_fixtureList = fixture.m_next
      }
      found = true;
      break
    }
    ppF = node;
    node = node.m_next
  }
  var edge = this.m_contactList;
  while(edge) {
    var c = edge.contact;
    edge = edge.next;
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    if(fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c)
    }
  }
  if(this.m_flags & b2Body.e_activeFlag) {
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase)
  }else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData()
};
b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var f;
  if(this.m_world.IsLocked() == true) {
    return
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var tMat = this.m_xf.R;
  var tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for(f = this.m_fixtureList;f;f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf)
  }
  this.m_world.m_contactManager.FindNewContacts()
};
b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle())
};
b2Body.prototype.GetTransform = function() {
  return this.m_xf
};
b2Body.prototype.GetPosition = function() {
  return this.m_xf.position
};
b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle())
};
b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a
};
b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle)
};
b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c
};
b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter
};
b2Body.prototype.SetLinearVelocity = function(v) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_linearVelocity.SetV(v)
};
b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity
};
b2Body.prototype.SetAngularVelocity = function(omega) {
  if(this.m_type == b2Body.b2_staticBody) {
    return
  }
  this.m_angularVelocity = omega
};
b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity
};
b2Body.prototype.GetDefinition = function() {
  var bd = new b2BodyDef;
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd
};
b2Body.prototype.ApplyForce = function(force, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x
};
b2Body.prototype.ApplyTorque = function(torque) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_torque += torque
};
b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  if(this.IsAwake() == false) {
    this.SetAwake(true)
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x)
};
b2Body.prototype.Split = function(callback) {
  var linearVelocity = this.GetLinearVelocity().Copy();
  var angularVelocity = this.GetAngularVelocity();
  var center = this.GetWorldCenter();
  var body1 = this;
  var body2 = this.m_world.CreateBody(this.GetDefinition());
  var prev;
  for(var f = body1.m_fixtureList;f;) {
    if(callback(f)) {
      var next = f.m_next;
      if(prev) {
        prev.m_next = next
      }else {
        body1.m_fixtureList = next
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next
    }else {
      prev = f;
      f = f.m_next
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
  var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2
};
b2Body.prototype.Merge = function(other) {
  var f;
  for(f = other.m_fixtureList;f;) {
    var next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = body2;
    f = next
  }
  body1.m_fixtureCount = 0;
  var body1 = this;
  var body2 = other;
  var center1 = body1.GetWorldCenter();
  var center2 = body2.GetWorldCenter();
  var velocity1 = body1.GetLinearVelocity().Copy();
  var velocity2 = body2.GetLinearVelocity().Copy();
  var angular1 = body1.GetAngularVelocity();
  var angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures()
};
b2Body.prototype.GetMass = function() {
  return this.m_mass
};
b2Body.prototype.GetInertia = function() {
  return this.m_I
};
b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter)
};
b2Body.prototype.SetMassData = function(massData) {
  b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if(this.m_world.IsLocked() == true) {
    return
  }
  if(this.m_type != b2Body.b2_dynamicBody) {
    return
  }
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_mass = massData.mass;
  if(this.m_mass <= 0) {
    this.m_mass = 1
  }
  this.m_invMass = 1 / this.m_mass;
  if(massData.I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1 / this.m_I
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0;
  this.m_invMass = 0;
  this.m_I = 0;
  this.m_invI = 0;
  this.m_sweep.localCenter.SetZero();
  if(this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
    return
  }
  var center = b2Vec2.Make(0, 0);
  for(var f = this.m_fixtureList;f;f = f.m_next) {
    if(f.m_density == 0) {
      continue
    }
    var massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I
  }
  if(this.m_mass > 0) {
    this.m_invMass = 1 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass
  }else {
    this.m_mass = 1;
    this.m_invMass = 1
  }
  if(this.m_I > 0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1 / this.m_I
  }else {
    this.m_I = 0;
    this.m_invI = 0
  }
  var oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x)
};
b2Body.prototype.GetWorldPoint = function(localPoint) {
  var A = this.m_xf.R;
  var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u
};
b2Body.prototype.GetWorldVector = function(localVector) {
  return b2Math.MulMV(this.m_xf.R, localVector)
};
b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return b2Math.MulXT(this.m_xf, worldPoint)
};
b2Body.prototype.GetLocalVector = function(worldVector) {
  return b2Math.MulTMV(this.m_xf.R, worldVector)
};
b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var A = this.m_xf.R;
  var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x))
};
b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping
};
b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping
};
b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping
};
b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping
};
b2Body.prototype.SetType = function(type) {
  if(this.m_type == type) {
    return
  }
  this.m_type = type;
  this.ResetMassData();
  if(this.m_type == b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0;
  for(var ce = this.m_contactList;ce;ce = ce.next) {
    ce.contact.FlagForFiltering()
  }
};
b2Body.prototype.GetType = function() {
  return this.m_type
};
b2Body.prototype.SetBullet = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_bulletFlag
  }else {
    this.m_flags &= ~b2Body.e_bulletFlag
  }
};
b2Body.prototype.IsBullet = function() {
  return(this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag
};
b2Body.prototype.SetSleepingAllowed = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_allowSleepFlag
  }else {
    this.m_flags &= ~b2Body.e_allowSleepFlag;
    this.SetAwake(true)
  }
};
b2Body.prototype.SetAwake = function(flag) {
  if(flag) {
    this.m_flags |= b2Body.e_awakeFlag;
    this.m_sleepTime = 0
  }else {
    this.m_flags &= ~b2Body.e_awakeFlag;
    this.m_sleepTime = 0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0;
    this.m_force.SetZero();
    this.m_torque = 0
  }
};
b2Body.prototype.IsAwake = function() {
  return(this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag
};
b2Body.prototype.SetFixedRotation = function(fixed) {
  if(fixed) {
    this.m_flags |= b2Body.e_fixedRotationFlag
  }else {
    this.m_flags &= ~b2Body.e_fixedRotationFlag
  }
  this.ResetMassData()
};
b2Body.prototype.IsFixedRotation = function() {
  return(this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag
};
b2Body.prototype.SetActive = function(flag) {
  if(flag == this.IsActive()) {
    return
  }
  var broadPhase;
  var f;
  if(flag) {
    this.m_flags |= b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf)
    }
  }else {
    this.m_flags &= ~b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for(f = this.m_fixtureList;f;f = f.m_next) {
      f.DestroyProxy(broadPhase)
    }
    var ce = this.m_contactList;
    while(ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact)
    }
    this.m_contactList = null
  }
};
b2Body.prototype.IsActive = function() {
  return(this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag
};
b2Body.prototype.IsSleepingAllowed = function() {
  return(this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag
};
b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList
};
b2Body.prototype.GetJointList = function() {
  return this.m_jointList
};
b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList
};
b2Body.prototype.GetContactList = function() {
  return this.m_contactList
};
b2Body.prototype.GetNext = function() {
  return this.m_next
};
b2Body.prototype.GetUserData = function() {
  return this.m_userData
};
b2Body.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Body.prototype.GetWorld = function() {
  return this.m_world
};
b2Body.prototype.m_flags = 0;
b2Body.prototype.m_type = 0;
b2Body.prototype.m_islandIndex = 0;
b2Body.prototype.m_xf = new b2Transform;
b2Body.prototype.m_sweep = new b2Sweep;
b2Body.prototype.m_linearVelocity = new b2Vec2;
b2Body.prototype.m_angularVelocity = null;
b2Body.prototype.m_force = new b2Vec2;
b2Body.prototype.m_torque = null;
b2Body.prototype.m_world = null;
b2Body.prototype.m_prev = null;
b2Body.prototype.m_next = null;
b2Body.prototype.m_fixtureList = null;
b2Body.prototype.m_fixtureCount = 0;
b2Body.prototype.m_controllerList = null;
b2Body.prototype.m_controllerCount = 0;
b2Body.prototype.m_jointList = null;
b2Body.prototype.m_contactList = null;
b2Body.prototype.m_mass = null;
b2Body.prototype.m_invMass = null;
b2Body.prototype.m_I = null;
b2Body.prototype.m_invI = null;
b2Body.prototype.m_inertiaScale = null;
b2Body.prototype.m_linearDamping = null;
b2Body.prototype.m_angularDamping = null;
b2Body.prototype.m_sleepTime = null;
b2Body.prototype.m_userData = null;var b2ContactImpulse = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactImpulse.prototype.__constructor = function() {
};
b2ContactImpulse.prototype.__varz = function() {
  this.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
  this.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints)
};
b2ContactImpulse.prototype.normalImpulses = new Array(b2Settings.b2_maxManifoldPoints);
b2ContactImpulse.prototype.tangentImpulses = new Array(b2Settings.b2_maxManifoldPoints);var b2TensorDampingController = function() {
  b2Controller.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2TensorDampingController.prototype, b2Controller.prototype);
b2TensorDampingController.prototype._super = b2Controller.prototype;
b2TensorDampingController.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2TensorDampingController.prototype.__varz = function() {
  this.T = new b2Mat22
};
b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
  this.T.col1.x = -xDamping;
  this.T.col1.y = 0;
  this.T.col2.x = 0;
  this.T.col2.y = -yDamping;
  if(xDamping > 0 || yDamping > 0) {
    this.maxTimestep = 1 / Math.max(xDamping, yDamping)
  }else {
    this.maxTimestep = 0
  }
};
b2TensorDampingController.prototype.Step = function(step) {
  var timestep = step.dt;
  if(timestep <= Number.MIN_VALUE) {
    return
  }
  if(timestep > this.maxTimestep && this.maxTimestep > 0) {
    timestep = this.maxTimestep
  }
  for(var i = m_bodyList;i;i = i.nextBody) {
    var body = i.body;
    if(!body.IsAwake()) {
      continue
    }
    var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
    body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep))
  }
};
b2TensorDampingController.prototype.T = new b2Mat22;
b2TensorDampingController.prototype.maxTimestep = 0;var b2ManifoldPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ManifoldPoint.prototype.__constructor = function() {
  this.Reset()
};
b2ManifoldPoint.prototype.__varz = function() {
  this.m_localPoint = new b2Vec2;
  this.m_id = new b2ContactID
};
b2ManifoldPoint.prototype.Reset = function() {
  this.m_localPoint.SetZero();
  this.m_normalImpulse = 0;
  this.m_tangentImpulse = 0;
  this.m_id.key = 0
};
b2ManifoldPoint.prototype.Set = function(m) {
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_normalImpulse = m.m_normalImpulse;
  this.m_tangentImpulse = m.m_tangentImpulse;
  this.m_id.Set(m.m_id)
};
b2ManifoldPoint.prototype.m_localPoint = new b2Vec2;
b2ManifoldPoint.prototype.m_normalImpulse = null;
b2ManifoldPoint.prototype.m_tangentImpulse = null;
b2ManifoldPoint.prototype.m_id = new b2ContactID;var b2PolygonShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonShape.prototype, b2Shape.prototype);
b2PolygonShape.prototype._super = b2Shape.prototype;
b2PolygonShape.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.m_type = b2Shape.e_polygonShape;
  this.m_centroid = new b2Vec2;
  this.m_vertices = new Array;
  this.m_normals = new Array
};
b2PolygonShape.prototype.__varz = function() {
};
b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape
};
b2PolygonShape.AsBox = function(hx, hy) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsBox(hx, hy);
  return polygonShape
};
b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape
};
b2PolygonShape.AsEdge = function(v1, v2) {
  var polygonShape = new b2PolygonShape;
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape
};
b2PolygonShape.ComputeCentroid = function(vs, count) {
  var c = new b2Vec2;
  var area = 0;
  var p1X = 0;
  var p1Y = 0;
  var inv3 = 1 / 3;
  for(var i = 0;i < count;++i) {
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y)
  }
  c.x *= 1 / area;
  c.y *= 1 / area;
  return c
};
b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var i = 0;
  var p = new Array(count + 1);
  for(i = 0;i < count;++i) {
    p[i] = vs[i]
  }
  p[count] = p[0];
  var minArea = Number.MAX_VALUE;
  for(i = 1;i <= count;++i) {
    var root = p[parseInt(i - 1)];
    var uxX = p[i].x - root.x;
    var uxY = p[i].y - root.y;
    var length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var uyX = -uxY;
    var uyY = uxX;
    var lowerX = Number.MAX_VALUE;
    var lowerY = Number.MAX_VALUE;
    var upperX = -Number.MAX_VALUE;
    var upperY = -Number.MAX_VALUE;
    for(var j = 0;j < count;++j) {
      var dX = p[j].x - root.x;
      var dY = p[j].y - root.y;
      var rX = uxX * dX + uxY * dY;
      var rY = uyX * dX + uyY * dY;
      if(rX < lowerX) {
        lowerX = rX
      }
      if(rY < lowerY) {
        lowerY = rY
      }
      if(rX > upperX) {
        upperX = rX
      }
      if(rY > upperY) {
        upperY = rY
      }
    }
    var area = (upperX - lowerX) * (upperY - lowerY);
    if(area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var centerX = 0.5 * (lowerX + upperX);
      var centerY = 0.5 * (lowerY + upperY);
      var tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY)
    }
  }
};
b2PolygonShape.s_mat = new b2Mat22;
b2PolygonShape.prototype.Validate = function() {
  return false
};
b2PolygonShape.prototype.Reserve = function(count) {
  for(var i = this.m_vertices.length;i < count;i++) {
    this.m_vertices[i] = new b2Vec2;
    this.m_normals[i] = new b2Vec2
  }
};
b2PolygonShape.prototype.Copy = function() {
  var s = new b2PolygonShape;
  s.Set(this);
  return s
};
b2PolygonShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2PolygonShape)) {
    var other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Reserve(this.m_vertexCount);
    for(var i = 0;i < this.m_vertexCount;i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i])
    }
  }
};
b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  var v = new Array;
  for(var i = 0, tVec = null;i < vertices.length, tVec = vertices[i];i++) {
    v.push(tVec)
  }
  this.SetAsVector(v, vertexCount)
};
b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  if(typeof vertexCount == "undefined") {
    vertexCount = vertices.length
  }
  b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = vertexCount;
  this.Reserve(vertexCount);
  var i = 0;
  for(i = 0;i < this.m_vertexCount;i++) {
    this.m_vertices[i].SetV(vertices[i])
  }
  for(i = 0;i < this.m_vertexCount;++i) {
    var i1 = i;
    var i2 = i + 1 < this.m_vertexCount ? i + 1 : 0;
    var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
    b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(b2Math.CrossVF(edge, 1));
    this.m_normals[i].Normalize()
  }
  this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)
};
b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid.SetZero()
};
b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  this.m_vertexCount = 4;
  this.Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0, -1);
  this.m_normals[1].Set(1, 0);
  this.m_normals[2].Set(0, 1);
  this.m_normals[3].Set(-1, 0);
  this.m_centroid = center;
  var xf = new b2Transform;
  xf.position = center;
  xf.R.Set(angle);
  for(var i = 0;i < this.m_vertexCount;++i) {
    this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
    this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i])
  }
};
b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y
};
b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var tVec;
  var tMat = xf.R;
  var tX = p.x - xf.position.x;
  var tY = p.y - xf.position.y;
  var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
  var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = this.m_normals[i];
    var dot = tVec.x * tX + tVec.y * tY;
    if(dot > 0) {
      return false
    }
  }
  return true
};
b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var lower = 0;
  var upper = input.maxFraction;
  var tX;
  var tY;
  var tMat;
  var tVec;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
  var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var index = -1;
  for(var i = 0;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = this.m_normals[i];
    var numerator = tVec.x * tX + tVec.y * tY;
    var denominator = tVec.x * dX + tVec.y * dY;
    if(denominator == 0) {
      if(numerator < 0) {
        return false
      }
    }else {
      if(denominator < 0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i
      }else {
        if(denominator > 0 && numerator < upper * denominator) {
          upper = numerator / denominator
        }
      }
    }
    if(upper < lower - Number.MIN_VALUE) {
      return false
    }
  }
  if(index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = this.m_normals[index];
    output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    return true
  }
  return false
};
b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var tMat = xf.R;
  var tVec = this.m_vertices[0];
  var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var upperX = lowerX;
  var upperY = lowerY;
  for(var i = 1;i < this.m_vertexCount;++i) {
    tVec = this.m_vertices[i];
    var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius
};
b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if(this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0;
    massData.I = 0;
    return
  }
  var centerX = 0;
  var centerY = 0;
  var area = 0;
  var I = 0;
  var p1X = 0;
  var p1Y = 0;
  var k_inv3 = 1 / 3;
  for(var i = 0;i < this.m_vertexCount;++i) {
    var p2 = this.m_vertices[i];
    var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
    var e1X = p2.x - p1X;
    var e1Y = p2.y - p1Y;
    var e2X = p3.x - p1X;
    var e2Y = p3.y - p1Y;
    var D = e1X * e2Y - e1Y * e2X;
    var triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var px = p1X;
    var py = p1Y;
    var ex1 = e1X;
    var ey1 = e1Y;
    var ex2 = e2X;
    var ey2 = e2Y;
    var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2)
  }
  massData.mass = density * area;
  centerX *= 1 / area;
  centerY *= 1 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I
};
b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var normalL = b2Math.MulTMV(xf.R, normal);
  var offsetL = offset - b2Math.Dot(normal, xf.position);
  var depths = new Array;
  var diveCount = 0;
  var intoIndex = -1;
  var outoIndex = -1;
  var lastSubmerged = false;
  var i = 0;
  for(i = 0;i < this.m_vertexCount;++i) {
    depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
    var isSubmerged = depths[i] < -Number.MIN_VALUE;
    if(i > 0) {
      if(isSubmerged) {
        if(!lastSubmerged) {
          intoIndex = i - 1;
          diveCount++
        }
      }else {
        if(lastSubmerged) {
          outoIndex = i - 1;
          diveCount++
        }
      }
    }
    lastSubmerged = isSubmerged
  }
  switch(diveCount) {
    case 0:
      if(lastSubmerged) {
        var md = new b2MassData;
        this.ComputeMass(md, 1);
        c.SetV(b2Math.MulX(xf, md.center));
        return md.mass
      }else {
        return 0
      }
      break;
    case 1:
      if(intoIndex == -1) {
        intoIndex = this.m_vertexCount - 1
      }else {
        outoIndex = this.m_vertexCount - 1
      }
      break
  }
  var intoIndex2 = (intoIndex + 1) % this.m_vertexCount;
  var outoIndex2 = (outoIndex + 1) % this.m_vertexCount;
  var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var area = 0;
  var center = new b2Vec2;
  var p2 = this.m_vertices[intoIndex2];
  var p3;
  i = intoIndex2;
  while(i != outoIndex2) {
    i = (i + 1) % this.m_vertexCount;
    if(i == outoIndex2) {
      p3 = outoVec
    }else {
      p3 = this.m_vertices[i]
    }
    var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3
  }
  center.Multiply(1 / area);
  c.SetV(b2Math.MulX(xf, center));
  return area
};
b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount
};
b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices
};
b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals
};
b2PolygonShape.prototype.GetSupport = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return bestIndex
};
b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var bestIndex = 0;
  var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for(var i = 1;i < this.m_vertexCount;++i) {
    var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if(value > bestValue) {
      bestIndex = i;
      bestValue = value
    }
  }
  return this.m_vertices[bestIndex]
};
b2PolygonShape.prototype.m_centroid = null;
b2PolygonShape.prototype.m_vertices = null;
b2PolygonShape.prototype.m_normals = null;
b2PolygonShape.prototype.m_vertexCount = 0;var b2Fixture = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Fixture.prototype.__constructor = function() {
  this.m_aabb = new b2AABB;
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0;
  this.m_friction = 0;
  this.m_restitution = 0
};
b2Fixture.prototype.__varz = function() {
  this.m_filter = new b2FilterData
};
b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density
};
b2Fixture.prototype.Destroy = function() {
  this.m_shape = null
};
b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this)
};
b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if(this.m_proxy == null) {
    return
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null
};
b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if(!this.m_proxy) {
    return
  }
  var aabb1 = new b2AABB;
  var aabb2 = new b2AABB;
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement)
};
b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType()
};
b2Fixture.prototype.GetShape = function() {
  return this.m_shape
};
b2Fixture.prototype.SetSensor = function(sensor) {
  if(this.m_isSensor == sensor) {
    return
  }
  this.m_isSensor = sensor;
  if(this.m_body == null) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor())
    }
    edge = edge.next
  }
};
b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor
};
b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if(this.m_body) {
    return
  }
  var edge = this.m_body.GetContactList();
  while(edge) {
    var contact = edge.contact;
    var fixtureA = contact.GetFixtureA();
    var fixtureB = contact.GetFixtureB();
    if(fixtureA == this || fixtureB == this) {
      contact.FlagForFiltering()
    }
    edge = edge.next
  }
};
b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy()
};
b2Fixture.prototype.GetBody = function() {
  return this.m_body
};
b2Fixture.prototype.GetNext = function() {
  return this.m_next
};
b2Fixture.prototype.GetUserData = function() {
  return this.m_userData
};
b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p)
};
b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform())
};
b2Fixture.prototype.GetMassData = function(massData) {
  if(massData == null) {
    massData = new b2MassData
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData
};
b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density
};
b2Fixture.prototype.GetDensity = function() {
  return this.m_density
};
b2Fixture.prototype.GetFriction = function() {
  return this.m_friction
};
b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction
};
b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution
};
b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution
};
b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb
};
b2Fixture.prototype.m_massData = null;
b2Fixture.prototype.m_aabb = null;
b2Fixture.prototype.m_density = null;
b2Fixture.prototype.m_next = null;
b2Fixture.prototype.m_body = null;
b2Fixture.prototype.m_shape = null;
b2Fixture.prototype.m_friction = null;
b2Fixture.prototype.m_restitution = null;
b2Fixture.prototype.m_proxy = null;
b2Fixture.prototype.m_filter = new b2FilterData;
b2Fixture.prototype.m_isSensor = null;
b2Fixture.prototype.m_userData = null;var b2DynamicTreeNode = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeNode.prototype.__constructor = function() {
};
b2DynamicTreeNode.prototype.__varz = function() {
  this.aabb = new b2AABB
};
b2DynamicTreeNode.prototype.IsLeaf = function() {
  return this.child1 == null
};
b2DynamicTreeNode.prototype.userData = null;
b2DynamicTreeNode.prototype.aabb = new b2AABB;
b2DynamicTreeNode.prototype.parent = null;
b2DynamicTreeNode.prototype.child1 = null;
b2DynamicTreeNode.prototype.child2 = null;var b2BodyDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BodyDef.prototype.__constructor = function() {
  this.userData = null;
  this.position.Set(0, 0);
  this.angle = 0;
  this.linearVelocity.Set(0, 0);
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type = b2Body.b2_staticBody;
  this.active = true;
  this.inertiaScale = 1
};
b2BodyDef.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.linearVelocity = new b2Vec2
};
b2BodyDef.prototype.type = 0;
b2BodyDef.prototype.position = new b2Vec2;
b2BodyDef.prototype.angle = null;
b2BodyDef.prototype.linearVelocity = new b2Vec2;
b2BodyDef.prototype.angularVelocity = null;
b2BodyDef.prototype.linearDamping = null;
b2BodyDef.prototype.angularDamping = null;
b2BodyDef.prototype.allowSleep = null;
b2BodyDef.prototype.awake = null;
b2BodyDef.prototype.fixedRotation = null;
b2BodyDef.prototype.bullet = null;
b2BodyDef.prototype.active = null;
b2BodyDef.prototype.userData = null;
b2BodyDef.prototype.inertiaScale = null;var b2DynamicTreeBroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2DynamicTreeBroadPhase.prototype.__constructor = function() {
};
b2DynamicTreeBroadPhase.prototype.__varz = function() {
  this.m_tree = new b2DynamicTree;
  this.m_moveBuffer = new Array;
  this.m_pairBuffer = new Array
};
b2DynamicTreeBroadPhase.prototype.BufferMove = function(proxy) {
  this.m_moveBuffer[this.m_moveBuffer.length] = proxy
};
b2DynamicTreeBroadPhase.prototype.UnBufferMove = function(proxy) {
  var i = this.m_moveBuffer.indexOf(proxy);
  this.m_moveBuffer.splice(i, 1)
};
b2DynamicTreeBroadPhase.prototype.ComparePairs = function(pair1, pair2) {
  return 0
};
b2DynamicTreeBroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var proxy = this.m_tree.CreateProxy(aabb, userData);
  ++this.m_proxyCount;
  this.BufferMove(proxy);
  return proxy
};
b2DynamicTreeBroadPhase.prototype.DestroyProxy = function(proxy) {
  this.UnBufferMove(proxy);
  --this.m_proxyCount;
  this.m_tree.DestroyProxy(proxy)
};
b2DynamicTreeBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
  var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
  if(buffer) {
    this.BufferMove(proxy)
  }
};
b2DynamicTreeBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var aabbA = this.m_tree.GetFatAABB(proxyA);
  var aabbB = this.m_tree.GetFatAABB(proxyB);
  return aabbA.TestOverlap(aabbB)
};
b2DynamicTreeBroadPhase.prototype.GetUserData = function(proxy) {
  return this.m_tree.GetUserData(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetFatAABB = function(proxy) {
  return this.m_tree.GetFatAABB(proxy)
};
b2DynamicTreeBroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2DynamicTreeBroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairCount = 0;
  for(var i = 0, queryProxy = null;i < this.m_moveBuffer.length, queryProxy = this.m_moveBuffer[i];i++) {
    var that = this;
    function QueryCallback(proxy) {
      if(proxy == queryProxy) {
        return true
      }
      if(that.m_pairCount == that.m_pairBuffer.length) {
        that.m_pairBuffer[that.m_pairCount] = new b2DynamicTreePair
      }
      var pair = that.m_pairBuffer[that.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++that.m_pairCount;
      return true
    }
    var fatAABB = this.m_tree.GetFatAABB(queryProxy);
    this.m_tree.Query(QueryCallback, fatAABB)
  }
  this.m_moveBuffer.length = 0;
  for(var i = 0;i < this.m_pairCount;) {
    var primaryPair = this.m_pairBuffer[i];
    var userDataA = this.m_tree.GetUserData(primaryPair.proxyA);
    var userDataB = this.m_tree.GetUserData(primaryPair.proxyB);
    callback(userDataA, userDataB);
    ++i;
    while(i < this.m_pairCount) {
      var pair = this.m_pairBuffer[i];
      if(pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
        break
      }
      ++i
    }
  }
};
b2DynamicTreeBroadPhase.prototype.Query = function(callback, aabb) {
  this.m_tree.Query(callback, aabb)
};
b2DynamicTreeBroadPhase.prototype.RayCast = function(callback, input) {
  this.m_tree.RayCast(callback, input)
};
b2DynamicTreeBroadPhase.prototype.Validate = function() {
};
b2DynamicTreeBroadPhase.prototype.Rebalance = function(iterations) {
  this.m_tree.Rebalance(iterations)
};
b2DynamicTreeBroadPhase.prototype.m_tree = new b2DynamicTree;
b2DynamicTreeBroadPhase.prototype.m_proxyCount = 0;
b2DynamicTreeBroadPhase.prototype.m_moveBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairBuffer = new Array;
b2DynamicTreeBroadPhase.prototype.m_pairCount = 0;var b2BroadPhase = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2BroadPhase.prototype.__constructor = function(worldAABB) {
  var i = 0;
  this.m_pairManager.Initialize(this);
  this.m_worldAABB = worldAABB;
  this.m_proxyCount = 0;
  this.m_bounds = new Array;
  for(i = 0;i < 2;i++) {
    this.m_bounds[i] = new Array
  }
  var dX = worldAABB.upperBound.x - worldAABB.lowerBound.x;
  var dY = worldAABB.upperBound.y - worldAABB.lowerBound.y;
  this.m_quantizationFactor.x = b2Settings.USHRT_MAX / dX;
  this.m_quantizationFactor.y = b2Settings.USHRT_MAX / dY;
  this.m_timeStamp = 1;
  this.m_queryResultCount = 0
};
b2BroadPhase.prototype.__varz = function() {
  this.m_pairManager = new b2PairManager;
  this.m_proxyPool = new Array;
  this.m_querySortKeys = new Array;
  this.m_queryResults = new Array;
  this.m_quantizationFactor = new b2Vec2
};
b2BroadPhase.BinarySearch = function(bounds, count, value) {
  var low = 0;
  var high = count - 1;
  while(low <= high) {
    var mid = Math.round((low + high) / 2);
    var bound = bounds[mid];
    if(bound.value > value) {
      high = mid - 1
    }else {
      if(bound.value < value) {
        low = mid + 1
      }else {
        return parseInt(mid)
      }
    }
  }
  return parseInt(low)
};
b2BroadPhase.s_validate = false;
b2BroadPhase.b2_invalid = b2Settings.USHRT_MAX;
b2BroadPhase.b2_nullEdge = b2Settings.USHRT_MAX;
b2BroadPhase.prototype.ComputeBounds = function(lowerValues, upperValues, aabb) {
  var minVertexX = aabb.lowerBound.x;
  var minVertexY = aabb.lowerBound.y;
  minVertexX = b2Math.Min(minVertexX, this.m_worldAABB.upperBound.x);
  minVertexY = b2Math.Min(minVertexY, this.m_worldAABB.upperBound.y);
  minVertexX = b2Math.Max(minVertexX, this.m_worldAABB.lowerBound.x);
  minVertexY = b2Math.Max(minVertexY, this.m_worldAABB.lowerBound.y);
  var maxVertexX = aabb.upperBound.x;
  var maxVertexY = aabb.upperBound.y;
  maxVertexX = b2Math.Min(maxVertexX, this.m_worldAABB.upperBound.x);
  maxVertexY = b2Math.Min(maxVertexY, this.m_worldAABB.upperBound.y);
  maxVertexX = b2Math.Max(maxVertexX, this.m_worldAABB.lowerBound.x);
  maxVertexY = b2Math.Max(maxVertexY, this.m_worldAABB.lowerBound.y);
  lowerValues[0] = parseInt(this.m_quantizationFactor.x * (minVertexX - this.m_worldAABB.lowerBound.x)) & b2Settings.USHRT_MAX - 1;
  upperValues[0] = parseInt(this.m_quantizationFactor.x * (maxVertexX - this.m_worldAABB.lowerBound.x)) % 65535 | 1;
  lowerValues[1] = parseInt(this.m_quantizationFactor.y * (minVertexY - this.m_worldAABB.lowerBound.y)) & b2Settings.USHRT_MAX - 1;
  upperValues[1] = parseInt(this.m_quantizationFactor.y * (maxVertexY - this.m_worldAABB.lowerBound.y)) % 65535 | 1
};
b2BroadPhase.prototype.TestOverlapValidate = function(p1, p2) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound1 = bounds[p1.lowerBounds[axis]];
    var bound2 = bounds[p2.upperBounds[axis]];
    if(bound1.value > bound2.value) {
      return false
    }
    bound1 = bounds[p1.upperBounds[axis]];
    bound2 = bounds[p2.lowerBounds[axis]];
    if(bound1.value < bound2.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.QueryAxis = function(lowerQueryOut, upperQueryOut, lowerValue, upperValue, bounds, boundCount, axis) {
  var lowerQuery = b2BroadPhase.BinarySearch(bounds, boundCount, lowerValue);
  var upperQuery = b2BroadPhase.BinarySearch(bounds, boundCount, upperValue);
  var bound;
  for(var j = lowerQuery;j < upperQuery;++j) {
    bound = bounds[j];
    if(bound.IsLower()) {
      this.IncrementOverlapCount(bound.proxy)
    }
  }
  if(lowerQuery > 0) {
    var i = lowerQuery - 1;
    bound = bounds[i];
    var s = bound.stabbingCount;
    while(s) {
      bound = bounds[i];
      if(bound.IsLower()) {
        var proxy = bound.proxy;
        if(lowerQuery <= proxy.upperBounds[axis]) {
          this.IncrementOverlapCount(bound.proxy);
          --s
        }
      }
      --i
    }
  }
  lowerQueryOut[0] = lowerQuery;
  upperQueryOut[0] = upperQuery
};
b2BroadPhase.prototype.IncrementOverlapCount = function(proxy) {
  if(proxy.timeStamp < this.m_timeStamp) {
    proxy.timeStamp = this.m_timeStamp;
    proxy.overlapCount = 1
  }else {
    proxy.overlapCount = 2;
    this.m_queryResults[this.m_queryResultCount] = proxy;
    ++this.m_queryResultCount
  }
};
b2BroadPhase.prototype.IncrementTimeStamp = function() {
  if(this.m_timeStamp == b2Settings.USHRT_MAX) {
    for(var i = 0;i < this.m_proxyPool.length;++i) {
      this.m_proxyPool[i].timeStamp = 0
    }
    this.m_timeStamp = 1
  }else {
    ++this.m_timeStamp
  }
};
b2BroadPhase.prototype.InRange = function(aabb) {
  var dX;
  var dY;
  var d2X;
  var d2Y;
  dX = aabb.lowerBound.x;
  dY = aabb.lowerBound.y;
  dX -= this.m_worldAABB.upperBound.x;
  dY -= this.m_worldAABB.upperBound.y;
  d2X = this.m_worldAABB.lowerBound.x;
  d2Y = this.m_worldAABB.lowerBound.y;
  d2X -= aabb.upperBound.x;
  d2Y -= aabb.upperBound.y;
  dX = b2Math.Max(dX, d2X);
  dY = b2Math.Max(dY, d2Y);
  return b2Math.Max(dX, dY) < 0
};
b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
  var index = 0;
  var proxy;
  var i = 0;
  var j = 0;
  if(!this.m_freeProxy) {
    this.m_freeProxy = this.m_proxyPool[this.m_proxyCount] = new b2Proxy;
    this.m_freeProxy.next = null;
    this.m_freeProxy.timeStamp = 0;
    this.m_freeProxy.overlapCount = b2BroadPhase.b2_invalid;
    this.m_freeProxy.userData = null;
    for(i = 0;i < 2;i++) {
      j = this.m_proxyCount * 2;
      this.m_bounds[i][j++] = new b2Bound;
      this.m_bounds[i][j] = new b2Bound
    }
  }
  proxy = this.m_freeProxy;
  this.m_freeProxy = proxy.next;
  proxy.overlapCount = 0;
  proxy.userData = userData;
  var boundCount = 2 * this.m_proxyCount;
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = 0;
    var upperIndex = 0;
    var lowerIndexOut = new Array;
    lowerIndexOut.push(lowerIndex);
    var upperIndexOut = new Array;
    upperIndexOut.push(upperIndex);
    this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
    lowerIndex = lowerIndexOut[0];
    upperIndex = upperIndexOut[0];
    bounds.splice(upperIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    bounds.splice(lowerIndex, 0, bounds[bounds.length - 1]);
    bounds.length--;
    ++upperIndex;
    var tBound1 = bounds[lowerIndex];
    var tBound2 = bounds[upperIndex];
    tBound1.value = lowerValues[axis];
    tBound1.proxy = proxy;
    tBound2.value = upperValues[axis];
    tBound2.proxy = proxy;
    var tBoundAS3 = bounds[parseInt(lowerIndex - 1)];
    tBound1.stabbingCount = lowerIndex == 0 ? 0 : tBoundAS3.stabbingCount;
    tBoundAS3 = bounds[parseInt(upperIndex - 1)];
    tBound2.stabbingCount = tBoundAS3.stabbingCount;
    for(index = lowerIndex;index < upperIndex;++index) {
      tBoundAS3 = bounds[index];
      tBoundAS3.stabbingCount++
    }
    for(index = lowerIndex;index < boundCount + 2;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
  }
  ++this.m_proxyCount;
  for(i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.AddBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return proxy
};
b2BroadPhase.prototype.DestroyProxy = function(proxy_) {
  var proxy = proxy_;
  var tBound1;
  var tBound2;
  var boundCount = 2 * this.m_proxyCount;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    tBound1 = bounds[lowerIndex];
    var lowerValue = tBound1.value;
    tBound2 = bounds[upperIndex];
    var upperValue = tBound2.value;
    bounds.splice(upperIndex, 1);
    bounds.splice(lowerIndex, 1);
    bounds.push(tBound1);
    bounds.push(tBound2);
    var tEnd = boundCount - 2;
    for(var index = lowerIndex;index < tEnd;++index) {
      tBound1 = bounds[index];
      var proxy2 = tBound1.proxy;
      if(tBound1.IsLower()) {
        proxy2.lowerBounds[axis] = index
      }else {
        proxy2.upperBounds[axis] = index
      }
    }
    tEnd = upperIndex - 1;
    for(var index2 = lowerIndex;index2 < tEnd;++index2) {
      tBound1 = bounds[index2];
      tBound1.stabbingCount--
    }
    var ignore = new Array;
    this.QueryAxis(ignore, ignore, lowerValue, upperValue, bounds, boundCount - 2, axis)
  }
  for(var i = 0;i < this.m_queryResultCount;++i) {
    this.m_pairManager.RemoveBufferedPair(proxy, this.m_queryResults[i])
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  proxy.userData = null;
  proxy.overlapCount = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[0] = b2BroadPhase.b2_invalid;
  proxy.lowerBounds[1] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[0] = b2BroadPhase.b2_invalid;
  proxy.upperBounds[1] = b2BroadPhase.b2_invalid;
  proxy.next = this.m_freeProxy;
  this.m_freeProxy = proxy;
  --this.m_proxyCount
};
b2BroadPhase.prototype.MoveProxy = function(proxy_, aabb, displacement) {
  var proxy = proxy_;
  var as3arr;
  var as3int = 0;
  var axis = 0;
  var index = 0;
  var bound;
  var prevBound;
  var nextBound;
  var nextProxyId = 0;
  var nextProxy;
  if(proxy == null) {
    return
  }
  if(aabb.IsValid() == false) {
    return
  }
  var boundCount = 2 * this.m_proxyCount;
  var newValues = new b2BoundValues;
  this.ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
  var oldValues = new b2BoundValues;
  for(axis = 0;axis < 2;++axis) {
    bound = this.m_bounds[axis][proxy.lowerBounds[axis]];
    oldValues.lowerValues[axis] = bound.value;
    bound = this.m_bounds[axis][proxy.upperBounds[axis]];
    oldValues.upperValues[axis] = bound.value
  }
  for(axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var lowerIndex = proxy.lowerBounds[axis];
    var upperIndex = proxy.upperBounds[axis];
    var lowerValue = newValues.lowerValues[axis];
    var upperValue = newValues.upperValues[axis];
    bound = bounds[lowerIndex];
    var deltaLower = lowerValue - bound.value;
    bound.value = lowerValue;
    bound = bounds[upperIndex];
    var deltaUpper = upperValue - bound.value;
    bound.value = upperValue;
    if(deltaLower < 0) {
      index = lowerIndex;
      while(index > 0 && lowerValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        var prevProxy = prevBound.proxy;
        prevBound.stabbingCount++;
        if(prevBound.IsUpper() == true) {
          if(this.TestOverlapBound(newValues, prevProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        --index
      }
    }
    if(deltaUpper > 0) {
      index = upperIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= upperValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount++;
        if(nextBound.IsLower() == true) {
          if(this.TestOverlapBound(newValues, nextProxy)) {
            this.m_pairManager.AddBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }else {
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaLower > 0) {
      index = lowerIndex;
      while(index < boundCount - 1 && bounds[parseInt(index + 1)].value <= lowerValue) {
        bound = bounds[index];
        nextBound = bounds[parseInt(index + 1)];
        nextProxy = nextBound.proxy;
        nextBound.stabbingCount--;
        if(nextBound.IsUpper()) {
          if(this.TestOverlapBound(oldValues, nextProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, nextProxy)
          }
          as3arr = nextProxy.upperBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = nextProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int--;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.lowerBounds;
        as3int = as3arr[axis];
        as3int++;
        as3arr[axis] = as3int;
        bound.Swap(nextBound);
        index++
      }
    }
    if(deltaUpper < 0) {
      index = upperIndex;
      while(index > 0 && upperValue < bounds[parseInt(index - 1)].value) {
        bound = bounds[index];
        prevBound = bounds[parseInt(index - 1)];
        prevProxy = prevBound.proxy;
        prevBound.stabbingCount--;
        if(prevBound.IsLower() == true) {
          if(this.TestOverlapBound(oldValues, prevProxy)) {
            this.m_pairManager.RemoveBufferedPair(proxy, prevProxy)
          }
          as3arr = prevProxy.lowerBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount--
        }else {
          as3arr = prevProxy.upperBounds;
          as3int = as3arr[axis];
          as3int++;
          as3arr[axis] = as3int;
          bound.stabbingCount++
        }
        as3arr = proxy.upperBounds;
        as3int = as3arr[axis];
        as3int--;
        as3arr[axis] = as3int;
        bound.Swap(prevBound);
        index--
      }
    }
  }
};
b2BroadPhase.prototype.UpdatePairs = function(callback) {
  this.m_pairManager.Commit(callback)
};
b2BroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
  var proxyA_ = proxyA;
  var proxyB_ = proxyB;
  if(proxyA_.lowerBounds[0] > proxyB_.upperBounds[0]) {
    return false
  }
  if(proxyB_.lowerBounds[0] > proxyA_.upperBounds[0]) {
    return false
  }
  if(proxyA_.lowerBounds[1] > proxyB_.upperBounds[1]) {
    return false
  }
  if(proxyB_.lowerBounds[1] > proxyA_.upperBounds[1]) {
    return false
  }
  return true
};
b2BroadPhase.prototype.GetUserData = function(proxy) {
  return proxy.userData
};
b2BroadPhase.prototype.GetFatAABB = function(proxy_) {
  var aabb = new b2AABB;
  var proxy = proxy_;
  aabb.lowerBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.lowerBounds[0]].value / this.m_quantizationFactor.x;
  aabb.lowerBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.lowerBounds[1]].value / this.m_quantizationFactor.y;
  aabb.upperBound.x = this.m_worldAABB.lowerBound.x + this.m_bounds[0][proxy.upperBounds[0]].value / this.m_quantizationFactor.x;
  aabb.upperBound.y = this.m_worldAABB.lowerBound.y + this.m_bounds[1][proxy.upperBounds[1]].value / this.m_quantizationFactor.y;
  return aabb
};
b2BroadPhase.prototype.GetProxyCount = function() {
  return this.m_proxyCount
};
b2BroadPhase.prototype.Query = function(callback, aabb) {
  var lowerValues = new Array;
  var upperValues = new Array;
  this.ComputeBounds(lowerValues, upperValues, aabb);
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[0], upperValues[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  this.QueryAxis(lowerIndexOut, upperIndexOut, lowerValues[1], upperValues[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  for(var i = 0;i < this.m_queryResultCount;++i) {
    var proxy = this.m_queryResults[i];
    if(!callback(proxy)) {
      break
    }
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp()
};
b2BroadPhase.prototype.Validate = function() {
  var pair;
  var proxy1;
  var proxy2;
  var overlap;
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var boundCount = 2 * this.m_proxyCount;
    var stabbingCount = 0;
    for(var i = 0;i < boundCount;++i) {
      var bound = bounds[i];
      if(bound.IsLower() == true) {
        stabbingCount++
      }else {
        stabbingCount--
      }
    }
  }
};
b2BroadPhase.prototype.Rebalance = function(iterations) {
};
b2BroadPhase.prototype.RayCast = function(callback, input) {
  var subInput = new b2RayCastInput;
  subInput.p1.SetV(input.p1);
  subInput.p2.SetV(input.p2);
  subInput.maxFraction = input.maxFraction;
  var dx = (input.p2.x - input.p1.x) * this.m_quantizationFactor.x;
  var dy = (input.p2.y - input.p1.y) * this.m_quantizationFactor.y;
  var sx = dx < -Number.MIN_VALUE ? -1 : dx > Number.MIN_VALUE ? 1 : 0;
  var sy = dy < -Number.MIN_VALUE ? -1 : dy > Number.MIN_VALUE ? 1 : 0;
  var p1x = this.m_quantizationFactor.x * (input.p1.x - this.m_worldAABB.lowerBound.x);
  var p1y = this.m_quantizationFactor.y * (input.p1.y - this.m_worldAABB.lowerBound.y);
  var startValues = new Array;
  var startValues2 = new Array;
  startValues[0] = parseInt(p1x) & b2Settings.USHRT_MAX - 1;
  startValues[1] = parseInt(p1y) & b2Settings.USHRT_MAX - 1;
  startValues2[0] = startValues[0] + 1;
  startValues2[1] = startValues[1] + 1;
  var startIndices = new Array;
  var xIndex = 0;
  var yIndex = 0;
  var proxy;
  var lowerIndex = 0;
  var upperIndex = 0;
  var lowerIndexOut = new Array;
  lowerIndexOut.push(lowerIndex);
  var upperIndexOut = new Array;
  upperIndexOut.push(upperIndex);
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[0], startValues2[0], this.m_bounds[0], 2 * this.m_proxyCount, 0);
  if(sx >= 0) {
    xIndex = upperIndexOut[0] - 1
  }else {
    xIndex = lowerIndexOut[0]
  }
  this.QueryAxis(lowerIndexOut, upperIndexOut, startValues[1], startValues2[1], this.m_bounds[1], 2 * this.m_proxyCount, 1);
  if(sy >= 0) {
    yIndex = upperIndexOut[0] - 1
  }else {
    yIndex = lowerIndexOut[0]
  }
  for(var i = 0;i < this.m_queryResultCount;i++) {
    subInput.maxFraction = callback(this.m_queryResults[i], subInput)
  }
  for(;;) {
    var xProgress = 0;
    var yProgress = 0;
    xIndex += sx >= 0 ? 1 : -1;
    if(xIndex < 0 || xIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sx != 0) {
      xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
    }
    yIndex += sy >= 0 ? 1 : -1;
    if(yIndex < 0 || yIndex >= this.m_proxyCount * 2) {
      break
    }
    if(sy != 0) {
      yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
    }
    for(;;) {
      if(sy == 0 || sx != 0 && xProgress < yProgress) {
        if(xProgress > subInput.maxFraction) {
          break
        }
        if(sx > 0 ? this.m_bounds[0][xIndex].IsLower() : this.m_bounds[0][xIndex].IsUpper()) {
          proxy = this.m_bounds[0][xIndex].proxy;
          if(sy >= 0) {
            if(proxy.lowerBounds[1] <= yIndex - 1 && proxy.upperBounds[1] >= yIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[1] <= yIndex && proxy.upperBounds[1] >= yIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sx > 0) {
          xIndex++;
          if(xIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          xIndex--;
          if(xIndex < 0) {
            break
          }
        }
        xProgress = (this.m_bounds[0][xIndex].value - p1x) / dx
      }else {
        if(yProgress > subInput.maxFraction) {
          break
        }
        if(sy > 0 ? this.m_bounds[1][yIndex].IsLower() : this.m_bounds[1][yIndex].IsUpper()) {
          proxy = this.m_bounds[1][yIndex].proxy;
          if(sx >= 0) {
            if(proxy.lowerBounds[0] <= xIndex - 1 && proxy.upperBounds[0] >= xIndex) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }else {
            if(proxy.lowerBounds[0] <= xIndex && proxy.upperBounds[0] >= xIndex + 1) {
              subInput.maxFraction = callback(proxy, subInput)
            }
          }
        }
        if(subInput.maxFraction == 0) {
          break
        }
        if(sy > 0) {
          yIndex++;
          if(yIndex == this.m_proxyCount * 2) {
            break
          }
        }else {
          yIndex--;
          if(yIndex < 0) {
            break
          }
        }
        yProgress = (this.m_bounds[1][yIndex].value - p1y) / dy
      }
    }
    break
  }
  this.m_queryResultCount = 0;
  this.IncrementTimeStamp();
  return
};
b2BroadPhase.prototype.TestOverlapBound = function(b, p) {
  for(var axis = 0;axis < 2;++axis) {
    var bounds = this.m_bounds[axis];
    var bound = bounds[p.upperBounds[axis]];
    if(b.lowerValues[axis] > bound.value) {
      return false
    }
    bound = bounds[p.lowerBounds[axis]];
    if(b.upperValues[axis] < bound.value) {
      return false
    }
  }
  return true
};
b2BroadPhase.prototype.m_pairManager = new b2PairManager;
b2BroadPhase.prototype.m_proxyPool = new Array;
b2BroadPhase.prototype.m_freeProxy = null;
b2BroadPhase.prototype.m_bounds = null;
b2BroadPhase.prototype.m_querySortKeys = new Array;
b2BroadPhase.prototype.m_queryResults = new Array;
b2BroadPhase.prototype.m_queryResultCount = 0;
b2BroadPhase.prototype.m_worldAABB = null;
b2BroadPhase.prototype.m_quantizationFactor = new b2Vec2;
b2BroadPhase.prototype.m_proxyCount = 0;
b2BroadPhase.prototype.m_timeStamp = 0;var b2Manifold = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Manifold.prototype.__constructor = function() {
  this.m_points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i] = new b2ManifoldPoint
  }
  this.m_localPlaneNormal = new b2Vec2;
  this.m_localPoint = new b2Vec2
};
b2Manifold.prototype.__varz = function() {
};
b2Manifold.e_circles = 1;
b2Manifold.e_faceA = 2;
b2Manifold.e_faceB = 4;
b2Manifold.prototype.Reset = function() {
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Reset()
  }
  this.m_localPlaneNormal.SetZero();
  this.m_localPoint.SetZero();
  this.m_type = 0;
  this.m_pointCount = 0
};
b2Manifold.prototype.Set = function(m) {
  this.m_pointCount = m.m_pointCount;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.m_points[i].Set(m.m_points[i])
  }
  this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
  this.m_localPoint.SetV(m.m_localPoint);
  this.m_type = m.m_type
};
b2Manifold.prototype.Copy = function() {
  var copy = new b2Manifold;
  copy.Set(this);
  return copy
};
b2Manifold.prototype.m_points = null;
b2Manifold.prototype.m_localPlaneNormal = null;
b2Manifold.prototype.m_localPoint = null;
b2Manifold.prototype.m_type = 0;
b2Manifold.prototype.m_pointCount = 0;var b2CircleShape = function() {
  b2Shape.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleShape.prototype, b2Shape.prototype);
b2CircleShape.prototype._super = b2Shape.prototype;
b2CircleShape.prototype.__constructor = function(radius) {
  this._super.__constructor.apply(this, []);
  this.m_type = b2Shape.e_circleShape;
  this.m_radius = radius
};
b2CircleShape.prototype.__varz = function() {
  this.m_p = new b2Vec2
};
b2CircleShape.prototype.Copy = function() {
  var s = new b2CircleShape;
  s.Set(this);
  return s
};
b2CircleShape.prototype.Set = function(other) {
  this._super.Set.apply(this, [other]);
  if(isInstanceOf(other, b2CircleShape)) {
    var other2 = other;
    this.m_p.SetV(other2.m_p)
  }
};
b2CircleShape.prototype.TestPoint = function(transform, p) {
  var tMat = transform.R;
  var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return dX * dX + dY * dY <= this.m_radius * this.m_radius
};
b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var tMat = transform.R;
  var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var sX = input.p1.x - positionX;
  var sY = input.p1.y - positionY;
  var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
  var rX = input.p2.x - input.p1.x;
  var rY = input.p2.y - input.p1.y;
  var c = sX * rX + sY * rY;
  var rr = rX * rX + rY * rY;
  var sigma = c * c - rr * b;
  if(sigma < 0 || rr < Number.MIN_VALUE) {
    return false
  }
  var a = -(c + Math.sqrt(sigma));
  if(0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true
  }
  return false
};
b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var tMat = transform.R;
  var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius)
};
b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
};
b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var p = b2Math.MulX(xf, this.m_p);
  var l = -(b2Math.Dot(normal, p) - offset);
  if(l < -this.m_radius + Number.MIN_VALUE) {
    return 0
  }
  if(l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius
  }
  var r2 = this.m_radius * this.m_radius;
  var l2 = l * l;
  var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area
};
b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p
};
b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position)
};
b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius
};
b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius
};
b2CircleShape.prototype.m_p = new b2Vec2;var b2Joint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Joint.prototype.__constructor = function(def) {
  b2Settings.b2Assert(def.bodyA != def.bodyB);
  this.m_type = def.type;
  this.m_prev = null;
  this.m_next = null;
  this.m_bodyA = def.bodyA;
  this.m_bodyB = def.bodyB;
  this.m_collideConnected = def.collideConnected;
  this.m_islandFlag = false;
  this.m_userData = def.userData
};
b2Joint.prototype.__varz = function() {
  this.m_edgeA = new b2JointEdge;
  this.m_edgeB = new b2JointEdge;
  this.m_localCenterA = new b2Vec2;
  this.m_localCenterB = new b2Vec2
};
b2Joint.Create = function(def, allocator) {
  var joint = null;
  switch(def.type) {
    case b2Joint.e_ropeJoint:
      joint = new b2RopeJoint(def);
      break;
    case b2Joint.e_distanceJoint:
      joint = new b2DistanceJoint(def);
      break;
    case b2Joint.e_mouseJoint:
      joint = new b2MouseJoint(def);
      break;
    case b2Joint.e_prismaticJoint:
      joint = new b2PrismaticJoint(def);
      break;
    case b2Joint.e_revoluteJoint:
      joint = new b2RevoluteJoint(def);
      break;
    case b2Joint.e_pulleyJoint:
      joint = new b2PulleyJoint(def);
      break;
    case b2Joint.e_gearJoint:
      joint = new b2GearJoint(def);
      break;
    case b2Joint.e_lineJoint:
      joint = new b2LineJoint(def);
      break;
    case b2Joint.e_weldJoint:
      joint = new b2WeldJoint(def);
      break;
    case b2Joint.e_frictionJoint:
      joint = new b2FrictionJoint(def);
      break;
    default:
      break
  }
  return joint
};
b2Joint.Destroy = function(joint, allocator) {
};
b2Joint.e_unknownJoint = 0;
b2Joint.e_revoluteJoint = 1;
b2Joint.e_prismaticJoint = 2;
b2Joint.e_distanceJoint = 3;
b2Joint.e_pulleyJoint = 4;
b2Joint.e_mouseJoint = 5;
b2Joint.e_gearJoint = 6;
b2Joint.e_lineJoint = 7;
b2Joint.e_weldJoint = 8;
b2Joint.e_frictionJoint = 9;
b2Joint.e_ropeJoint= 10;
b2Joint.e_inactiveLimit = 0;
b2Joint.e_atLowerLimit = 1;
b2Joint.e_atUpperLimit = 2;
b2Joint.e_equalLimits = 3;
b2Joint.prototype.InitVelocityConstraints = function(step) {
};
b2Joint.prototype.SolveVelocityConstraints = function(step) {
};
b2Joint.prototype.FinalizeVelocityConstraints = function() {
};
b2Joint.prototype.SolvePositionConstraints = function(baumgarte) {
  return false
};
b2Joint.prototype.GetType = function() {
  return this.m_type
};
b2Joint.prototype.GetAnchorA = function() {
  return null
};
b2Joint.prototype.GetAnchorB = function() {
  return null
};
b2Joint.prototype.GetReactionForce = function(inv_dt) {
  return null
};
b2Joint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2Joint.prototype.GetBodyA = function() {
  return this.m_bodyA
};
b2Joint.prototype.GetBodyB = function() {
  return this.m_bodyB
};
b2Joint.prototype.GetNext = function() {
  return this.m_next
};
b2Joint.prototype.GetUserData = function() {
  return this.m_userData
};
b2Joint.prototype.SetUserData = function(data) {
  this.m_userData = data
};
b2Joint.prototype.IsActive = function() {
  return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
b2Joint.prototype.m_type = 0;
b2Joint.prototype.m_prev = null;
b2Joint.prototype.m_next = null;
b2Joint.prototype.m_edgeA = new b2JointEdge;
b2Joint.prototype.m_edgeB = new b2JointEdge;
b2Joint.prototype.m_bodyA = null;
b2Joint.prototype.m_bodyB = null;
b2Joint.prototype.m_islandFlag = null;
b2Joint.prototype.m_collideConnected = null;
b2Joint.prototype.m_userData = null;
b2Joint.prototype.m_localCenterA = new b2Vec2;
b2Joint.prototype.m_localCenterB = new b2Vec2;
b2Joint.prototype.m_invMassA = null;
b2Joint.prototype.m_invMassB = null;
b2Joint.prototype.m_invIA = null;
b2Joint.prototype.m_invIB = null;var b2LineJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJoint.prototype, b2Joint.prototype);
b2LineJoint.prototype._super = b2Joint.prototype;
b2LineJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2LineJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat22;
  this.m_impulse = new b2Vec2
};
b2LineJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.y = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.y = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2LineJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve(new b2Vec2, -Cdot1, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0)
      }
    }
    var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
    var f2r;
    if(this.m_K.col1.x != 0) {
      f2r = b / this.m_K.col1.x + f1.x
    }else {
      f2r = f1.x
    }
    this.m_impulse.x = f2r;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y * this.m_a1;
    L2 = df.x * this.m_s2 + df.y * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2;
    if(this.m_K.col1.x != 0) {
      df2 = -Cdot1 / this.m_K.col1.x
    }else {
      df2 = 0
    }
    this.m_impulse.x += df2;
    PX = df2 * this.m_perp.x;
    PY = df2 * this.m_perp.y;
    L1 = df2 * this.m_s1;
    L2 = df2 * this.m_s2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2LineJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec2;
  var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1));
  angularError = 0;
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve(impulse, -C1, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var impulse1;
    if(k11 != 0) {
      impulse1 = -C1 / k11
    }else {
      impulse1 = 0
    }
    impulse.x = impulse1;
    impulse.y = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2LineJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2LineJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2LineJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
};
b2LineJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2LineJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2LineJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2LineJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2LineJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2LineJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2LineJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2LineJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2LineJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2LineJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2LineJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2LineJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2LineJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2LineJoint.prototype.GetMaxMotorForce = function() {
  return this.m_maxMotorForce
};
b2LineJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2LineJoint.prototype.m_localAnchor1 = new b2Vec2;
b2LineJoint.prototype.m_localAnchor2 = new b2Vec2;
b2LineJoint.prototype.m_localXAxis1 = new b2Vec2;
b2LineJoint.prototype.m_localYAxis1 = new b2Vec2;
b2LineJoint.prototype.m_axis = new b2Vec2;
b2LineJoint.prototype.m_perp = new b2Vec2;
b2LineJoint.prototype.m_s1 = null;
b2LineJoint.prototype.m_s2 = null;
b2LineJoint.prototype.m_a1 = null;
b2LineJoint.prototype.m_a2 = null;
b2LineJoint.prototype.m_K = new b2Mat22;
b2LineJoint.prototype.m_impulse = new b2Vec2;
b2LineJoint.prototype.m_motorMass = null;
b2LineJoint.prototype.m_motorImpulse = null;
b2LineJoint.prototype.m_lowerTranslation = null;
b2LineJoint.prototype.m_upperTranslation = null;
b2LineJoint.prototype.m_maxMotorForce = null;
b2LineJoint.prototype.m_motorSpeed = null;
b2LineJoint.prototype.m_enableLimit = null;
b2LineJoint.prototype.m_enableMotor = null;
b2LineJoint.prototype.m_limitState = 0;var b2ContactSolver = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactSolver.prototype.__constructor = function() {
};
b2ContactSolver.prototype.__varz = function() {
  this.m_step = new b2TimeStep;
  this.m_constraints = new Array
};
b2ContactSolver.s_worldManifold = new b2WorldManifold;
b2ContactSolver.s_psm = new b2PositionSolverManifold;
b2ContactSolver.prototype.Initialize = function(step, contacts, contactCount, allocator) {
  var contact;
  this.m_step.Set(step);
  this.m_allocator = allocator;
  var i = 0;
  var tVec;
  var tMat;
  this.m_constraintCount = contactCount;
  while(this.m_constraints.length < this.m_constraintCount) {
    this.m_constraints[this.m_constraints.length] = new b2ContactConstraint
  }
  for(i = 0;i < contactCount;++i) {
    contact = contacts[i];
    var fixtureA = contact.m_fixtureA;
    var fixtureB = contact.m_fixtureB;
    var shapeA = fixtureA.m_shape;
    var shapeB = fixtureB.m_shape;
    var radiusA = shapeA.m_radius;
    var radiusB = shapeB.m_radius;
    var bodyA = fixtureA.m_body;
    var bodyB = fixtureB.m_body;
    var manifold = contact.GetManifold();
    var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
    var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
    var vAX = bodyA.m_linearVelocity.x;
    var vAY = bodyA.m_linearVelocity.y;
    var vBX = bodyB.m_linearVelocity.x;
    var vBY = bodyB.m_linearVelocity.y;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    b2Settings.b2Assert(manifold.m_pointCount > 0);
    b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
    var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
    var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
    var cc = this.m_constraints[i];
    cc.bodyA = bodyA;
    cc.bodyB = bodyB;
    cc.manifold = manifold;
    cc.normal.x = normalX;
    cc.normal.y = normalY;
    cc.pointCount = manifold.m_pointCount;
    cc.friction = friction;
    cc.restitution = restitution;
    cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
    cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
    cc.localPoint.x = manifold.m_localPoint.x;
    cc.localPoint.y = manifold.m_localPoint.y;
    cc.radius = radiusA + radiusB;
    cc.type = manifold.m_type;
    for(var k = 0;k < cc.pointCount;++k) {
      var cp = manifold.m_points[k];
      var ccp = cc.points[k];
      ccp.normalImpulse = cp.m_normalImpulse;
      ccp.tangentImpulse = cp.m_tangentImpulse;
      ccp.localPoint.SetV(cp.m_localPoint);
      var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
      var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
      var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
      var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
      var rnA = rAX * normalY - rAY * normalX;
      var rnB = rBX * normalY - rBY * normalX;
      rnA *= rnA;
      rnB *= rnB;
      var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
      ccp.normalMass = 1 / kNormal;
      var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
      kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
      ccp.equalizedMass = 1 / kEqualized;
      var tangentX = normalY;
      var tangentY = -normalX;
      var rtA = rAX * tangentY - rAY * tangentX;
      var rtB = rBX * tangentY - rBY * tangentX;
      rtA *= rtA;
      rtB *= rtB;
      var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
      ccp.tangentMass = 1 / kTangent;
      ccp.velocityBias = 0;
      var tX = vBX + -wB * rBY - vAX - -wA * rAY;
      var tY = vBY + wB * rBX - vAY - wA * rAX;
      var vRel = cc.normal.x * tX + cc.normal.y * tY;
      if(vRel < -b2Settings.b2_velocityThreshold) {
        ccp.velocityBias += -cc.restitution * vRel
      }
    }
    if(cc.pointCount == 2) {
      var ccp1 = cc.points[0];
      var ccp2 = cc.points[1];
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
      var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
      var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
      var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
      var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
      var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
      var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
      var k_maxConditionNumber = 100;
      if(k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
        cc.K.col1.Set(k11, k12);
        cc.K.col2.Set(k12, k22);
        cc.K.GetInverse(cc.normalMass)
      }else {
        cc.pointCount = 1
      }
    }
  }
};
b2ContactSolver.prototype.InitVelocityConstraints = function(step) {
  var tVec;
  var tVec2;
  var tMat;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var tX;
    var j = 0;
    var tCount = 0;
    if(step.warmStarting) {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp = c.points[j];
        ccp.normalImpulse *= step.dtRatio;
        ccp.tangentImpulse *= step.dtRatio;
        var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
        var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
        bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        bodyA.m_linearVelocity.x -= invMassA * PX;
        bodyA.m_linearVelocity.y -= invMassA * PY;
        bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        bodyB.m_linearVelocity.x += invMassB * PX;
        bodyB.m_linearVelocity.y += invMassB * PY
      }
    }else {
      tCount = c.pointCount;
      for(j = 0;j < tCount;++j) {
        var ccp2 = c.points[j];
        ccp2.normalImpulse = 0;
        ccp2.tangentImpulse = 0
      }
    }
  }
};
b2ContactSolver.prototype.SolveVelocityConstraints = function() {
  var j = 0;
  var ccp;
  var rAX;
  var rAY;
  var rBX;
  var rBY;
  var dvX;
  var dvY;
  var vn;
  var vt;
  var lambda;
  var maxFriction;
  var newImpulse;
  var PX;
  var PY;
  var dX;
  var dY;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var tMat;
  var tVec;
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var wA = bodyA.m_angularVelocity;
    var wB = bodyB.m_angularVelocity;
    var vA = bodyA.m_linearVelocity;
    var vB = bodyB.m_linearVelocity;
    var invMassA = bodyA.m_invMass;
    var invIA = bodyA.m_invI;
    var invMassB = bodyB.m_invMass;
    var invIB = bodyB.m_invI;
    var normalX = c.normal.x;
    var normalY = c.normal.y;
    var tangentX = normalY;
    var tangentY = -normalX;
    var friction = c.friction;
    var tX;
    for(j = 0;j < c.pointCount;j++) {
      ccp = c.points[j];
      dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vt = dvX * tangentX + dvY * tangentY;
      lambda = ccp.tangentMass * -vt;
      maxFriction = friction * ccp.normalImpulse;
      newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - ccp.tangentImpulse;
      PX = lambda * tangentX;
      PY = lambda * tangentY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.tangentImpulse = newImpulse
    }
    var tCount = c.pointCount;
    if(c.pointCount == 1) {
      ccp = c.points[0];
      dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
      dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
      vn = dvX * normalX + dvY * normalY;
      lambda = -ccp.normalMass * (vn - ccp.velocityBias);
      newImpulse = ccp.normalImpulse + lambda;
      newImpulse = newImpulse > 0 ? newImpulse : 0;
      lambda = newImpulse - ccp.normalImpulse;
      PX = lambda * normalX;
      PY = lambda * normalY;
      vA.x -= invMassA * PX;
      vA.y -= invMassA * PY;
      wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
      vB.x += invMassB * PX;
      vB.y += invMassB * PY;
      wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
      ccp.normalImpulse = newImpulse
    }else {
      var cp1 = c.points[0];
      var cp2 = c.points[1];
      var aX = cp1.normalImpulse;
      var aY = cp2.normalImpulse;
      var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
      var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
      var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
      var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
      var vn1 = dv1X * normalX + dv1Y * normalY;
      var vn2 = dv2X * normalX + dv2Y * normalY;
      var bX = vn1 - cp1.velocityBias;
      var bY = vn2 - cp2.velocityBias;
      tMat = c.K;
      bX -= tMat.col1.x * aX + tMat.col2.x * aY;
      bY -= tMat.col1.y * aX + tMat.col2.y * aY;
      var k_errorTol = 0.0010;
      for(;;) {
        tMat = c.normalMass;
        var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
        var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);
        if(xX >= 0 && xY >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = -cp1.normalMass * bX;
        xY = 0;
        vn1 = 0;
        vn2 = c.K.col1.y * xX + bY;
        if(xX >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = -cp2.normalMass * bY;
        vn1 = c.K.col2.x * xY + bX;
        vn2 = 0;
        if(xY >= 0 && vn1 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        xX = 0;
        xY = 0;
        vn1 = bX;
        vn2 = bY;
        if(vn1 >= 0 && vn2 >= 0) {
          dX = xX - aX;
          dY = xY - aY;
          P1X = dX * normalX;
          P1Y = dX * normalY;
          P2X = dY * normalX;
          P2Y = dY * normalY;
          vA.x -= invMassA * (P1X + P2X);
          vA.y -= invMassA * (P1Y + P2Y);
          wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
          vB.x += invMassB * (P1X + P2X);
          vB.y += invMassB * (P1Y + P2Y);
          wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
          cp1.normalImpulse = xX;
          cp2.normalImpulse = xY;
          break
        }
        break
      }
    }
    bodyA.m_angularVelocity = wA;
    bodyB.m_angularVelocity = wB
  }
};
b2ContactSolver.prototype.FinalizeVelocityConstraints = function() {
  for(var i = 0;i < this.m_constraintCount;++i) {
    var c = this.m_constraints[i];
    var m = c.manifold;
    for(var j = 0;j < c.pointCount;++j) {
      var point1 = m.m_points[j];
      var point2 = c.points[j];
      point1.m_normalImpulse = point2.normalImpulse;
      point1.m_tangentImpulse = point2.tangentImpulse
    }
  }
};
b2ContactSolver.prototype.SolvePositionConstraints = function(baumgarte) {
  var minSeparation = 0;
  for(var i = 0;i < this.m_constraintCount;i++) {
    var c = this.m_constraints[i];
    var bodyA = c.bodyA;
    var bodyB = c.bodyB;
    var invMassA = bodyA.m_mass * bodyA.m_invMass;
    var invIA = bodyA.m_mass * bodyA.m_invI;
    var invMassB = bodyB.m_mass * bodyB.m_invMass;
    var invIB = bodyB.m_mass * bodyB.m_invI;
    b2ContactSolver.s_psm.Initialize(c);
    var normal = b2ContactSolver.s_psm.m_normal;
    for(var j = 0;j < c.pointCount;j++) {
      var ccp = c.points[j];
      var point = b2ContactSolver.s_psm.m_points[j];
      var separation = b2ContactSolver.s_psm.m_separations[j];
      var rAX = point.x - bodyA.m_sweep.c.x;
      var rAY = point.y - bodyA.m_sweep.c.y;
      var rBX = point.x - bodyB.m_sweep.c.x;
      var rBY = point.y - bodyB.m_sweep.c.y;
      minSeparation = minSeparation < separation ? minSeparation : separation;
      var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0);
      var impulse = -ccp.equalizedMass * C;
      var PX = impulse * normal.x;
      var PY = impulse * normal.y;
      bodyA.m_sweep.c.x -= invMassA * PX;
      bodyA.m_sweep.c.y -= invMassA * PY;
      bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
      bodyA.SynchronizeTransform();
      bodyB.m_sweep.c.x += invMassB * PX;
      bodyB.m_sweep.c.y += invMassB * PY;
      bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
      bodyB.SynchronizeTransform()
    }
  }
  return minSeparation > -1.5 * b2Settings.b2_linearSlop
};
b2ContactSolver.prototype.m_step = new b2TimeStep;
b2ContactSolver.prototype.m_allocator = null;
b2ContactSolver.prototype.m_constraints = new Array;
b2ContactSolver.prototype.m_constraintCount = 0;var b2Simplex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Simplex.prototype.__constructor = function() {
  this.m_vertices[0] = this.m_v1;
  this.m_vertices[1] = this.m_v2;
  this.m_vertices[2] = this.m_v3
};
b2Simplex.prototype.__varz = function() {
  this.m_v1 = new b2SimplexVertex;
  this.m_v2 = new b2SimplexVertex;
  this.m_v3 = new b2SimplexVertex;
  this.m_vertices = new Array(3)
};
b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
  b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
  var wALocal;
  var wBLocal;
  this.m_count = cache.count;
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    var v = vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = proxyA.GetVertex(v.indexA);
    wBLocal = proxyB.GetVertex(v.indexB);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    v.a = 0
  }
  if(this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.GetMetric();
    if(metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
      this.m_count = 0
    }
  }
  if(this.m_count == 0) {
    v = vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.GetVertex(0);
    wBLocal = proxyB.GetVertex(0);
    v.wA = b2Math.MulX(transformA, wALocal);
    v.wB = b2Math.MulX(transformB, wBLocal);
    v.w = b2Math.SubtractVV(v.wB, v.wA);
    this.m_count = 1
  }
};
b2Simplex.prototype.WriteCache = function(cache) {
  cache.metric = this.GetMetric();
  cache.count = parseInt(this.m_count);
  var vertices = this.m_vertices;
  for(var i = 0;i < this.m_count;i++) {
    cache.indexA[i] = parseInt(vertices[i].indexA);
    cache.indexB[i] = parseInt(vertices[i].indexB)
  }
};
b2Simplex.prototype.GetSearchDirection = function() {
  switch(this.m_count) {
    case 1:
      return this.m_v1.w.GetNegative();
    case 2:
      var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
      var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
      if(sgn > 0) {
        return b2Math.CrossFV(1, e12)
      }else {
        return b2Math.CrossVF(e12, 1)
      }
    ;
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetClosestPoint = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return new b2Vec2;
    case 1:
      return this.m_v1.w;
    case 2:
      return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
    default:
      b2Settings.b2Assert(false);
      return new b2Vec2
  }
};
b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      break;
    case 1:
      pA.SetV(this.m_v1.wA);
      pB.SetV(this.m_v1.wB);
      break;
    case 2:
      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
      break;
    case 3:
      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
      break;
    default:
      b2Settings.b2Assert(false);
      break
  }
};
b2Simplex.prototype.GetMetric = function() {
  switch(this.m_count) {
    case 0:
      b2Settings.b2Assert(false);
      return 0;
    case 1:
      return 0;
    case 2:
      return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
    case 3:
      return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
    default:
      b2Settings.b2Assert(false);
      return 0
  }
};
b2Simplex.prototype.Solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var d12_2 = -(w1.x * e12.x + w1.y * e12.y);
  if(d12_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  var d12_1 = w2.x * e12.x + w2.y * e12.y;
  if(d12_1 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  var inv_d12 = 1 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2
};
b2Simplex.prototype.Solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;
  var e12 = b2Math.SubtractVV(w2, w1);
  var w1e12 = b2Math.Dot(w1, e12);
  var w2e12 = b2Math.Dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;
  var e13 = b2Math.SubtractVV(w3, w1);
  var w1e13 = b2Math.Dot(w1, e13);
  var w3e13 = b2Math.Dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;
  var e23 = b2Math.SubtractVV(w3, w2);
  var w2e23 = b2Math.Dot(w2, e23);
  var w3e23 = b2Math.Dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;
  var n123 = b2Math.CrossVV(e12, e13);
  var d123_1 = n123 * b2Math.CrossVV(w2, w3);
  var d123_2 = n123 * b2Math.CrossVV(w3, w1);
  var d123_3 = n123 * b2Math.CrossVV(w1, w2);
  if(d12_2 <= 0 && d13_2 <= 0) {
    this.m_v1.a = 1;
    this.m_count = 1;
    return
  }
  if(d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
    var inv_d12 = 1 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return
  }
  if(d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
    var inv_d13 = 1 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.Set(this.m_v3);
    return
  }
  if(d12_1 <= 0 && d23_2 <= 0) {
    this.m_v2.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v2);
    return
  }
  if(d13_1 <= 0 && d23_1 <= 0) {
    this.m_v3.a = 1;
    this.m_count = 1;
    this.m_v1.Set(this.m_v3);
    return
  }
  if(d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
    var inv_d23 = 1 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.Set(this.m_v3);
    return
  }
  var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3
};
b2Simplex.prototype.m_v1 = new b2SimplexVertex;
b2Simplex.prototype.m_v2 = new b2SimplexVertex;
b2Simplex.prototype.m_v3 = new b2SimplexVertex;
b2Simplex.prototype.m_vertices = new Array(3);
b2Simplex.prototype.m_count = 0;var b2WeldJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJoint.prototype, b2Joint.prototype);
b2WeldJoint.prototype._super = b2Joint.prototype;
b2WeldJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2WeldJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_impulse.z *= step.dtRatio;
    bA.m_linearVelocity.x -= mA * this.m_impulse.x;
    bA.m_linearVelocity.y -= mA * this.m_impulse.y;
    bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
    bB.m_linearVelocity.x += mB * this.m_impulse.x;
    bB.m_linearVelocity.y += mB * this.m_impulse.y;
    bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero()
  }
};
b2WeldJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
  var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
  var Cdot2 = wB - wA;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
  this.m_impulse.Add(impulse);
  vA.x -= mA * impulse.x;
  vA.y -= mA * impulse.y;
  wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  vB.x += mB * impulse.x;
  vB.y += mB * impulse.y;
  wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2WeldJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
  var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
  var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
  var angularError = b2Math.Abs(C2);
  if(positionError > k_allowedStretch) {
    iA *= 1;
    iB *= 1
  }
  this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
  this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
  this.m_mass.col3.x = -rAY * iA - rBY * iB;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
  this.m_mass.col3.y = rAX * iA + rBX * iB;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = iA + iB;
  var impulse = new b2Vec3;
  this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
  bA.m_sweep.c.x -= mA * impulse.x;
  bA.m_sweep.c.y -= mA * impulse.y;
  bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
  bB.m_sweep.c.x += mB * impulse.x;
  bB.m_sweep.c.y += mB * impulse.y;
  bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2WeldJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2WeldJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2WeldJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2WeldJoint.prototype.m_localAnchorA = new b2Vec2;
b2WeldJoint.prototype.m_localAnchorB = new b2Vec2;
b2WeldJoint.prototype.m_referenceAngle = null;
b2WeldJoint.prototype.m_impulse = new b2Vec3;
b2WeldJoint.prototype.m_mass = new b2Mat33;var b2Math = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Math.prototype.__constructor = function() {
};
b2Math.prototype.__varz = function() {
};
b2Math.IsValid = function(x) {
  return isFinite(x)
};
b2Math.Dot = function(a, b) {
  return a.x * b.x + a.y * b.y
};
b2Math.CrossVV = function(a, b) {
  return a.x * b.y - a.y * b.x
};
b2Math.CrossVF = function(a, s) {
  var v = new b2Vec2(s * a.y, -s * a.x);
  return v
};
b2Math.CrossFV = function(s, a) {
  var v = new b2Vec2(-s * a.y, s * a.x);
  return v
};
b2Math.MulMV = function(A, v) {
  var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
  return u
};
b2Math.MulTMV = function(A, v) {
  var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
  return u
};
b2Math.MulX = function(T, v) {
  var a = b2Math.MulMV(T.R, v);
  a.x += T.position.x;
  a.y += T.position.y;
  return a
};
b2Math.MulXT = function(T, v) {
  var a = b2Math.SubtractVV(v, T.position);
  var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
  a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
  a.x = tX;
  return a
};
b2Math.AddVV = function(a, b) {
  var v = new b2Vec2(a.x + b.x, a.y + b.y);
  return v
};
b2Math.SubtractVV = function(a, b) {
  var v = new b2Vec2(a.x - b.x, a.y - b.y);
  return v
};
b2Math.Distance = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return Math.sqrt(cX * cX + cY * cY)
};
b2Math.DistanceSquared = function(a, b) {
  var cX = a.x - b.x;
  var cY = a.y - b.y;
  return cX * cX + cY * cY
};
b2Math.MulFV = function(s, a) {
  var v = new b2Vec2(s * a.x, s * a.y);
  return v
};
b2Math.AddMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
  return C
};
b2Math.MulMM = function(A, B) {
  var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
  return C
};
b2Math.MulTMM = function(A, B) {
  var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
  var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
  var C = b2Mat22.FromVV(c1, c2);
  return C
};
b2Math.Abs = function(a) {
  return a > 0 ? a : -a
};
b2Math.AbsV = function(a) {
  var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
  return b
};
b2Math.AbsM = function(A) {
  var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
  return B
};
b2Math.Min = function(a, b) {
  return a < b ? a : b
};
b2Math.MinV = function(a, b) {
  var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
  return c
};
b2Math.Max = function(a, b) {
  return a > b ? a : b
};
b2Math.MaxV = function(a, b) {
  var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
  return c
};
b2Math.Clamp = function(a, low, high) {
  return a < low ? low : a > high ? high : a
};
b2Math.ClampV = function(a, low, high) {
  return b2Math.MaxV(low, b2Math.MinV(a, high))
};
b2Math.Swap = function(a, b) {
  var tmp = a[0];
  a[0] = b[0];
  b[0] = tmp
};
b2Math.Random = function() {
  return Math.random() * 2 - 1
};
b2Math.RandomRange = function(lo, hi) {
  var r = Math.random();
  r = (hi - lo) * r + lo;
  return r
};
b2Math.NextPowerOfTwo = function(x) {
  x |= x >> 1 & 2147483647;
  x |= x >> 2 & 1073741823;
  x |= x >> 4 & 268435455;
  x |= x >> 8 & 16777215;
  x |= x >> 16 & 65535;
  return x + 1
};
b2Math.IsPowerOfTwo = function(x) {
  var result = x > 0 && (x & x - 1) == 0;
  return result
};
b2Math.b2Vec2_zero = new b2Vec2(0, 0);
b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1, 0), new b2Vec2(0, 1));
b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);var b2PulleyJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJoint.prototype, b2Joint.prototype);
b2PulleyJoint.prototype._super = b2Joint.prototype;
b2PulleyJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_ground = this.m_bodyA.m_world.m_groundBody;
  this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
  this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
  this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_ratio = def.ratio;
  this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
  this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
  this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
  this.m_impulse = 0;
  this.m_limitImpulse1 = 0;
  this.m_limitImpulse2 = 0
};
b2PulleyJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u1 = new b2Vec2;
  this.m_u2 = new b2Vec2
};
b2PulleyJoint.b2_minPulleyLength = 2;
b2PulleyJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  this.m_u1.Set(p1X - s1X, p1Y - s1Y);
  this.m_u2.Set(p2X - s2X, p2Y - s2Y);
  var length1 = this.m_u1.Length();
  var length2 = this.m_u2.Length();
  if(length1 > b2Settings.b2_linearSlop) {
    this.m_u1.Multiply(1 / length1)
  }else {
    this.m_u1.SetZero()
  }
  if(length2 > b2Settings.b2_linearSlop) {
    this.m_u2.Multiply(1 / length2)
  }else {
    this.m_u2.SetZero()
  }
  var C = this.m_constant - length1 - this.m_ratio * length2;
  if(C > 0) {
    this.m_state = b2Joint.e_inactiveLimit;
    this.m_impulse = 0
  }else {
    this.m_state = b2Joint.e_atUpperLimit
  }
  if(length1 < this.m_maxLength1) {
    this.m_limitState1 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse1 = 0
  }else {
    this.m_limitState1 = b2Joint.e_atUpperLimit
  }
  if(length2 < this.m_maxLength2) {
    this.m_limitState2 = b2Joint.e_inactiveLimit;
    this.m_limitImpulse2 = 0
  }else {
    this.m_limitState2 = b2Joint.e_atUpperLimit
  }
  var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
  var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
  this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
  this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
  this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
  this.m_limitMass1 = 1 / this.m_limitMass1;
  this.m_limitMass2 = 1 / this.m_limitMass2;
  this.m_pulleyMass = 1 / this.m_pulleyMass;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    this.m_limitImpulse1 *= step.dtRatio;
    this.m_limitImpulse2 *= step.dtRatio;
    var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
    var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
    var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
    var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }else {
    this.m_impulse = 0;
    this.m_limitImpulse1 = 0;
    this.m_limitImpulse2 = 0
  }
};
b2PulleyJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X;
  var v1Y;
  var v2X;
  var v2Y;
  var P1X;
  var P1Y;
  var P2X;
  var P2Y;
  var Cdot;
  var impulse;
  var oldImpulse;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = this.m_pulleyMass * -Cdot;
    oldImpulse = this.m_impulse;
    this.m_impulse = b2Math.Max(0, this.m_impulse + impulse);
    impulse = this.m_impulse - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    P2X = -this.m_ratio * impulse * this.m_u2.x;
    P2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
    impulse = -this.m_limitMass1 * Cdot;
    oldImpulse = this.m_limitImpulse1;
    this.m_limitImpulse1 = b2Math.Max(0, this.m_limitImpulse1 + impulse);
    impulse = this.m_limitImpulse1 - oldImpulse;
    P1X = -impulse * this.m_u1.x;
    P1Y = -impulse * this.m_u1.y;
    bA.m_linearVelocity.x += bA.m_invMass * P1X;
    bA.m_linearVelocity.y += bA.m_invMass * P1Y;
    bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X)
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
    impulse = -this.m_limitMass2 * Cdot;
    oldImpulse = this.m_limitImpulse2;
    this.m_limitImpulse2 = b2Math.Max(0, this.m_limitImpulse2 + impulse);
    impulse = this.m_limitImpulse2 - oldImpulse;
    P2X = -impulse * this.m_u2.x;
    P2Y = -impulse * this.m_u2.y;
    bB.m_linearVelocity.x += bB.m_invMass * P2X;
    bB.m_linearVelocity.y += bB.m_invMass * P2Y;
    bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X)
  }
};
b2PulleyJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var p1X;
  var p1Y;
  var p2X;
  var p2Y;
  var length1;
  var length2;
  var C;
  var impulse;
  var oldImpulse;
  var oldLimitPositionImpulse;
  var tX;
  var linearError = 0;
  if(this.m_state == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length1 = this.m_u1.Length();
    length2 = this.m_u2.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1 / length1)
    }else {
      this.m_u1.SetZero()
    }
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1 / length2)
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_constant - length1 - this.m_ratio * length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_pulleyMass * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    p2X = -this.m_ratio * impulse * this.m_u2.x;
    p2Y = -this.m_ratio * impulse * this.m_u2.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  if(this.m_limitState1 == b2Joint.e_atUpperLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    p1X = bA.m_sweep.c.x + r1X;
    p1Y = bA.m_sweep.c.y + r1Y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    length1 = this.m_u1.Length();
    if(length1 > b2Settings.b2_linearSlop) {
      this.m_u1.x *= 1 / length1;
      this.m_u1.y *= 1 / length1
    }else {
      this.m_u1.SetZero()
    }
    C = this.m_maxLength1 - length1;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass1 * C;
    p1X = -impulse * this.m_u1.x;
    p1Y = -impulse * this.m_u1.y;
    bA.m_sweep.c.x += bA.m_invMass * p1X;
    bA.m_sweep.c.y += bA.m_invMass * p1Y;
    bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
    bA.SynchronizeTransform()
  }
  if(this.m_limitState2 == b2Joint.e_atUpperLimit) {
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    p2X = bB.m_sweep.c.x + r2X;
    p2Y = bB.m_sweep.c.y + r2Y;
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    length2 = this.m_u2.Length();
    if(length2 > b2Settings.b2_linearSlop) {
      this.m_u2.x *= 1 / length2;
      this.m_u2.y *= 1 / length2
    }else {
      this.m_u2.SetZero()
    }
    C = this.m_maxLength2 - length2;
    linearError = b2Math.Max(linearError, -C);
    C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
    impulse = -this.m_limitMass2 * C;
    p2X = -impulse * this.m_u2.x;
    p2Y = -impulse * this.m_u2.y;
    bB.m_sweep.c.x += bB.m_invMass * p2X;
    bB.m_sweep.c.y += bB.m_invMass * p2Y;
    bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
    bB.SynchronizeTransform()
  }
  return linearError < b2Settings.b2_linearSlop
};
b2PulleyJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PulleyJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PulleyJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y)
};
b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2PulleyJoint.prototype.GetGroundAnchorA = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor1);
  return a
};
b2PulleyJoint.prototype.GetGroundAnchorB = function() {
  var a = this.m_ground.m_xf.position.Copy();
  a.Add(this.m_groundAnchor2);
  return a
};
b2PulleyJoint.prototype.GetLength1 = function() {
  var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetLength2 = function() {
  var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
  var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
  var dX = p.x - sX;
  var dY = p.y - sY;
  return Math.sqrt(dX * dX + dY * dY)
};
b2PulleyJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2PulleyJoint.prototype.m_ground = null;
b2PulleyJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PulleyJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PulleyJoint.prototype.m_u1 = new b2Vec2;
b2PulleyJoint.prototype.m_u2 = new b2Vec2;
b2PulleyJoint.prototype.m_constant = null;
b2PulleyJoint.prototype.m_ratio = null;
b2PulleyJoint.prototype.m_maxLength1 = null;
b2PulleyJoint.prototype.m_maxLength2 = null;
b2PulleyJoint.prototype.m_pulleyMass = null;
b2PulleyJoint.prototype.m_limitMass1 = null;
b2PulleyJoint.prototype.m_limitMass2 = null;
b2PulleyJoint.prototype.m_impulse = null;
b2PulleyJoint.prototype.m_limitImpulse1 = null;
b2PulleyJoint.prototype.m_limitImpulse2 = null;
b2PulleyJoint.prototype.m_state = 0;
b2PulleyJoint.prototype.m_limitState1 = 0;
b2PulleyJoint.prototype.m_limitState2 = 0;var b2PrismaticJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJoint.prototype, b2Joint.prototype);
b2PrismaticJoint.prototype._super = b2Joint.prototype;
b2PrismaticJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_localXAxis1.SetV(def.localAxisA);
  this.m_localYAxis1.x = -this.m_localXAxis1.y;
  this.m_localYAxis1.y = this.m_localXAxis1.x;
  this.m_refAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorMass = 0;
  this.m_motorImpulse = 0;
  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit;
  this.m_axis.SetZero();
  this.m_perp.SetZero()
};
b2PrismaticJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_localXAxis1 = new b2Vec2;
  this.m_localYAxis1 = new b2Vec2;
  this.m_axis = new b2Vec2;
  this.m_perp = new b2Vec2;
  this.m_K = new b2Mat33;
  this.m_impulse = new b2Vec3
};
b2PrismaticJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  this.m_localCenterA.SetV(bA.GetLocalCenter());
  this.m_localCenterB.SetV(bB.GetLocalCenter());
  var xf1 = bA.GetTransform();
  var xf2 = bB.GetTransform();
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_invMassA = bA.m_invMass;
  this.m_invMassB = bB.m_invMass;
  this.m_invIA = bA.m_invI;
  this.m_invIB = bB.m_invI;
  this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
  this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
  this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
  this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
  if(this.m_motorMass > Number.MIN_VALUE) {
    this.m_motorMass = 1 / this.m_motorMass
  }
  this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var m1 = this.m_invMassA;
  var m2 = this.m_invMassB;
  var i1 = this.m_invIA;
  var i2 = this.m_invIB;
  this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
  this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
  this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
  this.m_K.col2.x = this.m_K.col1.y;
  this.m_K.col2.y = i1 + i2;
  this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
  this.m_K.col3.x = this.m_K.col1.z;
  this.m_K.col3.y = this.m_K.col2.z;
  this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
  if(this.m_enableLimit) {
    var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointTransition <= this.m_lowerTranslation) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0
        }
      }else {
        if(jointTransition >= this.m_upperTranslation) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_limitState = b2Joint.e_atUpperLimit;
            this.m_impulse.z = 0
          }
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
    var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
    var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
    bA.m_linearVelocity.x -= this.m_invMassA * PX;
    bA.m_linearVelocity.y -= this.m_invMassA * PY;
    bA.m_angularVelocity -= this.m_invIA * L1;
    bB.m_linearVelocity.x += this.m_invMassB * PX;
    bB.m_linearVelocity.y += this.m_invMassB * PY;
    bB.m_angularVelocity += this.m_invIB * L2
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2PrismaticJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var PX;
  var PY;
  var L1;
  var L2;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    PX = impulse * this.m_axis.x;
    PY = impulse * this.m_axis.y;
    L1 = impulse * this.m_a1;
    L2 = impulse * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
  var Cdot1Y = w2 - w1;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
    var f1 = this.m_impulse.Copy();
    var df = this.m_K.Solve33(new b2Vec3, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(df);
    if(this.m_limitState == b2Joint.e_atLowerLimit) {
      this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0)
    }else {
      if(this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0)
      }
    }
    var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
    var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
    var f2r = this.m_K.Solve22(new b2Vec2, bX, bY);
    f2r.x += f1.x;
    f2r.y += f1.y;
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;
    df.x = this.m_impulse.x - f1.x;
    df.y = this.m_impulse.y - f1.y;
    df.z = this.m_impulse.z - f1.z;
    PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
    PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
    L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
    L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }else {
    var df2 = this.m_K.Solve22(new b2Vec2, -Cdot1X, -Cdot1Y);
    this.m_impulse.x += df2.x;
    this.m_impulse.y += df2.y;
    PX = df2.x * this.m_perp.x;
    PY = df2.x * this.m_perp.y;
    L1 = df2.x * this.m_s1 + df2.y;
    L2 = df2.x * this.m_s2 + df2.y;
    v1.x -= this.m_invMassA * PX;
    v1.y -= this.m_invMassA * PY;
    w1 -= this.m_invIA * L1;
    v2.x += this.m_invMassB * PX;
    v2.y += this.m_invMassB * PY;
    w2 += this.m_invIB * L2
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2PrismaticJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var limitC;
  var oldLimitImpulse;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var c1 = bA.m_sweep.c;
  var a1 = bA.m_sweep.a;
  var c2 = bB.m_sweep.c;
  var a2 = bB.m_sweep.a;
  var tMat;
  var tX;
  var m1;
  var m2;
  var i1;
  var i2;
  var linearError = 0;
  var angularError = 0;
  var active = false;
  var C2 = 0;
  var R1 = b2Mat22.FromAngle(a1);
  var R2 = b2Mat22.FromAngle(a2);
  tMat = R1;
  var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
  var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = R2;
  var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
  var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = c2.x + r2X - c1.x - r1X;
  var dY = c2.y + r2Y - c1.y - r1Y;
  if(this.m_enableLimit) {
    this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
    this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
    this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
    var translation = this.m_axis.x * dX + this.m_axis.y * dY;
    if(b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings.b2_linearSlop) {
      C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
      linearError = b2Math.Abs(translation);
      active = true
    }else {
      if(translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0);
        linearError = this.m_lowerTranslation - translation;
        active = true
      }else {
        if(translation >= this.m_upperTranslation) {
          C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0, b2Settings.b2_maxLinearCorrection);
          linearError = translation - this.m_upperTranslation;
          active = true
        }
      }
    }
  }
  this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
  this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
  this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
  var impulse = new b2Vec3;
  var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
  var C1Y = a2 - a1 - this.m_refAngle;
  linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
  angularError = b2Math.Abs(C1Y);
  if(active) {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
    this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
    this.m_K.col2.x = this.m_K.col1.y;
    this.m_K.col2.y = i1 + i2;
    this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
    this.m_K.col3.x = this.m_K.col1.z;
    this.m_K.col3.y = this.m_K.col2.z;
    this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    this.m_K.Solve33(impulse, -C1X, -C1Y, -C2)
  }else {
    m1 = this.m_invMassA;
    m2 = this.m_invMassB;
    i1 = this.m_invIA;
    i2 = this.m_invIB;
    var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
    var k12 = i1 * this.m_s1 + i2 * this.m_s2;
    var k22 = i1 + i2;
    this.m_K.col1.Set(k11, k12, 0);
    this.m_K.col2.Set(k12, k22, 0);
    var impulse1 = this.m_K.Solve22(new b2Vec2, -C1X, -C1Y);
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0
  }
  var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
  var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
  var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
  var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
  c1.x -= this.m_invMassA * PX;
  c1.y -= this.m_invMassA * PY;
  a1 -= this.m_invIA * L1;
  c2.x += this.m_invMassB * PX;
  c2.y += this.m_invMassB * PY;
  a2 += this.m_invIB * L2;
  bA.m_sweep.a = a1;
  bB.m_sweep.a = a2;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2PrismaticJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2PrismaticJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y
};
b2PrismaticJoint.prototype.GetJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var p1 = bA.GetWorldPoint(this.m_localAnchor1);
  var p2 = bB.GetWorldPoint(this.m_localAnchor2);
  var dX = p2.x - p1.x;
  var dY = p2.y - p1.y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var translation = axis.x * dX + axis.y * dY;
  return translation
};
b2PrismaticJoint.prototype.GetJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var p1X = bA.m_sweep.c.x + r1X;
  var p1Y = bA.m_sweep.c.y + r1Y;
  var p2X = bB.m_sweep.c.x + r2X;
  var p2Y = bB.m_sweep.c.y + r2Y;
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var axis = bA.GetWorldVector(this.m_localXAxis1);
  var v1 = bA.m_linearVelocity;
  var v2 = bB.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var w2 = bB.m_angularVelocity;
  var speed = dX * -w1 * axis.y + dY * w1 * axis.x + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
  return speed
};
b2PrismaticJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2PrismaticJoint.prototype.EnableLimit = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableLimit = flag
};
b2PrismaticJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerTranslation
};
b2PrismaticJoint.prototype.GetUpperLimit = function() {
  return this.m_upperTranslation
};
b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_lowerTranslation = lower;
  this.m_upperTranslation = upper
};
b2PrismaticJoint.prototype.IsMotorEnabled = function() {
  return this.m_enableMotor
};
b2PrismaticJoint.prototype.EnableMotor = function(flag) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_enableMotor = flag
};
b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2PrismaticJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_maxMotorForce = force
};
b2PrismaticJoint.prototype.GetMotorForce = function() {
  return this.m_motorImpulse
};
b2PrismaticJoint.prototype.m_localAnchor1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localAnchor2 = new b2Vec2;
b2PrismaticJoint.prototype.m_localXAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_localYAxis1 = new b2Vec2;
b2PrismaticJoint.prototype.m_refAngle = null;
b2PrismaticJoint.prototype.m_axis = new b2Vec2;
b2PrismaticJoint.prototype.m_perp = new b2Vec2;
b2PrismaticJoint.prototype.m_s1 = null;
b2PrismaticJoint.prototype.m_s2 = null;
b2PrismaticJoint.prototype.m_a1 = null;
b2PrismaticJoint.prototype.m_a2 = null;
b2PrismaticJoint.prototype.m_K = new b2Mat33;
b2PrismaticJoint.prototype.m_impulse = new b2Vec3;
b2PrismaticJoint.prototype.m_motorMass = null;
b2PrismaticJoint.prototype.m_motorImpulse = null;
b2PrismaticJoint.prototype.m_lowerTranslation = null;
b2PrismaticJoint.prototype.m_upperTranslation = null;
b2PrismaticJoint.prototype.m_maxMotorForce = null;
b2PrismaticJoint.prototype.m_motorSpeed = null;
b2PrismaticJoint.prototype.m_enableLimit = null;
b2PrismaticJoint.prototype.m_enableMotor = null;
b2PrismaticJoint.prototype.m_limitState = 0;var b2RevoluteJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJoint.prototype, b2Joint.prototype);
b2RevoluteJoint.prototype._super = b2Joint.prototype;
b2RevoluteJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_referenceAngle = def.referenceAngle;
  this.m_impulse.SetZero();
  this.m_motorImpulse = 0;
  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = b2Joint.e_inactiveLimit
};
b2RevoluteJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.K3 = new b2Mat22;
  this.impulse3 = new b2Vec3;
  this.impulse2 = new b2Vec2;
  this.reduced = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_impulse = new b2Vec3;
  this.m_mass = new b2Mat33
};
b2RevoluteJoint.tImpulse = new b2Vec2;
b2RevoluteJoint.prototype.InitVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  if(this.m_enableMotor || this.m_enableLimit) {
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
  this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
  this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
  this.m_mass.col1.y = this.m_mass.col2.x;
  this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
  this.m_mass.col3.y = r1X * i1 + r2X * i2;
  this.m_mass.col1.z = this.m_mass.col3.x;
  this.m_mass.col2.z = this.m_mass.col3.y;
  this.m_mass.col3.z = i1 + i2;
  this.m_motorMass = 1 / (i1 + i2);
  if(this.m_enableMotor == false) {
    this.m_motorImpulse = 0
  }
  if(this.m_enableLimit) {
    var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    if(b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings.b2_angularSlop) {
      this.m_limitState = b2Joint.e_equalLimits
    }else {
      if(jointAngle <= this.m_lowerAngle) {
        if(this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0
        }
        this.m_limitState = b2Joint.e_atLowerLimit
      }else {
        if(jointAngle >= this.m_upperAngle) {
          if(this.m_limitState != b2Joint.e_atUpperLimit) {
            this.m_impulse.z = 0
          }
          this.m_limitState = b2Joint.e_atUpperLimit
        }else {
          this.m_limitState = b2Joint.e_inactiveLimit;
          this.m_impulse.z = 0
        }
      }
    }
  }else {
    this.m_limitState = b2Joint.e_inactiveLimit
  }
  if(step.warmStarting) {
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;
    var PX = this.m_impulse.x;
    var PY = this.m_impulse.y;
    bA.m_linearVelocity.x -= m1 * PX;
    bA.m_linearVelocity.y -= m1 * PY;
    bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
    bB.m_linearVelocity.x += m2 * PX;
    bB.m_linearVelocity.y += m2 * PY;
    bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z)
  }else {
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0
  }
};
b2RevoluteJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var tMat;
  var tX;
  var newImpulse;
  var r1X;
  var r1Y;
  var r2X;
  var r2Y;
  var v1 = bA.m_linearVelocity;
  var w1 = bA.m_angularVelocity;
  var v2 = bB.m_linearVelocity;
  var w2 = bB.m_angularVelocity;
  var m1 = bA.m_invMass;
  var m2 = bB.m_invMass;
  var i1 = bA.m_invI;
  var i2 = bB.m_invI;
  if(this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
    var Cdot = w2 - w1 - this.m_motorSpeed;
    var impulse = this.m_motorMass * -Cdot;
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;
    w1 -= i1 * impulse;
    w2 += i2 * impulse
  }
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
    var Cdot2 = w2 - w1;
    this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);
    if(this.m_limitState == b2Joint.e_equalLimits) {
      this.m_impulse.Add(this.impulse3)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;
        if(newImpulse < 0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0
        }
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          newImpulse = this.m_impulse.z + this.impulse3.z;
          if(newImpulse > 0) {
            this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
            this.impulse3.x = this.reduced.x;
            this.impulse3.y = this.reduced.y;
            this.impulse3.z = -this.m_impulse.z;
            this.m_impulse.x += this.reduced.x;
            this.m_impulse.y += this.reduced.y;
            this.m_impulse.z = 0
          }
        }
      }
    }
    v1.x -= m1 * this.impulse3.x;
    v1.y -= m1 * this.impulse3.y;
    w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
    v2.x += m2 * this.impulse3.x;
    v2.y += m2 * this.impulse3.y;
    w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z)
  }else {
    tMat = bA.m_xf.R;
    r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
    var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
    this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
    this.m_impulse.x += this.impulse2.x;
    this.m_impulse.y += this.impulse2.y;
    v1.x -= m1 * this.impulse2.x;
    v1.y -= m1 * this.impulse2.y;
    w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
    v2.x += m2 * this.impulse2.x;
    v2.y += m2 * this.impulse2.y;
    w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x)
  }
  bA.m_linearVelocity.SetV(v1);
  bA.m_angularVelocity = w1;
  bB.m_linearVelocity.SetV(v2);
  bB.m_angularVelocity = w2
};
b2RevoluteJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var oldLimitImpulse;
  var C;
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var angularError = 0;
  var positionError = 0;
  var tX;
  var impulseX;
  var impulseY;
  if(this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
    var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var limitImpulse = 0;
    if(this.m_limitState == b2Joint.e_equalLimits) {
      C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
      angularError = b2Math.Abs(C)
    }else {
      if(this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0);
        limitImpulse = -this.m_motorMass * C
      }else {
        if(this.m_limitState == b2Joint.e_atUpperLimit) {
          C = angle - this.m_upperAngle;
          angularError = C;
          C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0, b2Settings.b2_maxAngularCorrection);
          limitImpulse = -this.m_motorMass * C
        }
      }
    }
    bA.m_sweep.a -= bA.m_invI * limitImpulse;
    bB.m_sweep.a += bB.m_invI * limitImpulse;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform()
  }
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var CLengthSquared = CX * CX + CY * CY;
  var CLength = Math.sqrt(CLengthSquared);
  positionError = CLength;
  var invMass1 = bA.m_invMass;
  var invMass2 = bB.m_invMass;
  var invI1 = bA.m_invI;
  var invI2 = bB.m_invI;
  var k_allowedStretch = 10 * b2Settings.b2_linearSlop;
  if(CLengthSquared > k_allowedStretch * k_allowedStretch) {
    var uX = CX / CLength;
    var uY = CY / CLength;
    var k = invMass1 + invMass2;
    var m = 1 / k;
    impulseX = m * -CX;
    impulseY = m * -CY;
    var k_beta = 0.5;
    bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
    bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
    bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
    bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
    CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y
  }
  this.K1.col1.x = invMass1 + invMass2;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass1 + invMass2;
  this.K2.col1.x = invI1 * r1Y * r1Y;
  this.K2.col2.x = -invI1 * r1X * r1Y;
  this.K2.col1.y = -invI1 * r1X * r1Y;
  this.K2.col2.y = invI1 * r1X * r1X;
  this.K3.col1.x = invI2 * r2Y * r2Y;
  this.K3.col2.x = -invI2 * r2X * r2Y;
  this.K3.col1.y = -invI2 * r2X * r2Y;
  this.K3.col2.y = invI2 * r2X * r2X;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.AddM(this.K3);
  this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
  impulseX = b2RevoluteJoint.tImpulse.x;
  impulseY = b2RevoluteJoint.tImpulse.y;
  bA.m_sweep.c.x -= bA.m_invMass * impulseX;
  bA.m_sweep.c.y -= bA.m_invMass * impulseY;
  bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
  bB.m_sweep.c.x += bB.m_invMass * impulseX;
  bB.m_sweep.c.y += bB.m_invMass * impulseY;
  bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop
};
b2RevoluteJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2RevoluteJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z
};
b2RevoluteJoint.prototype.GetJointAngle = function() {
  return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
b2RevoluteJoint.prototype.GetJointSpeed = function() {
  return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
b2RevoluteJoint.prototype.IsLimitEnabled = function() {
  return this.m_enableLimit
};
b2RevoluteJoint.prototype.EnableLimit = function(flag) {
  this.m_enableLimit = flag
};
b2RevoluteJoint.prototype.GetLowerLimit = function() {
  return this.m_lowerAngle
};
b2RevoluteJoint.prototype.GetUpperLimit = function() {
  return this.m_upperAngle
};
b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
  this.m_lowerAngle = lower;
  this.m_upperAngle = upper
};
b2RevoluteJoint.prototype.IsMotorEnabled = function() {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  return this.m_enableMotor
};
b2RevoluteJoint.prototype.EnableMotor = function(flag) {
  this.m_enableMotor = flag
};
b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
  this.m_bodyA.SetAwake(true);
  this.m_bodyB.SetAwake(true);
  this.m_motorSpeed = speed
};
b2RevoluteJoint.prototype.GetMotorSpeed = function() {
  return this.m_motorSpeed
};
b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
  this.m_maxMotorTorque = torque
};
b2RevoluteJoint.prototype.GetMotorTorque = function() {
  return this.m_maxMotorTorque
};
b2RevoluteJoint.prototype.K = new b2Mat22;
b2RevoluteJoint.prototype.K1 = new b2Mat22;
b2RevoluteJoint.prototype.K2 = new b2Mat22;
b2RevoluteJoint.prototype.K3 = new b2Mat22;
b2RevoluteJoint.prototype.impulse3 = new b2Vec3;
b2RevoluteJoint.prototype.impulse2 = new b2Vec2;
b2RevoluteJoint.prototype.reduced = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor1 = new b2Vec2;
b2RevoluteJoint.prototype.m_localAnchor2 = new b2Vec2;
b2RevoluteJoint.prototype.m_impulse = new b2Vec3;
b2RevoluteJoint.prototype.m_motorImpulse = null;
b2RevoluteJoint.prototype.m_mass = new b2Mat33;
b2RevoluteJoint.prototype.m_motorMass = null;
b2RevoluteJoint.prototype.m_enableMotor = null;
b2RevoluteJoint.prototype.m_maxMotorTorque = null;
b2RevoluteJoint.prototype.m_motorSpeed = null;
b2RevoluteJoint.prototype.m_enableLimit = null;
b2RevoluteJoint.prototype.m_referenceAngle = null;
b2RevoluteJoint.prototype.m_lowerAngle = null;
b2RevoluteJoint.prototype.m_upperAngle = null;
b2RevoluteJoint.prototype.m_limitState = 0;var b2JointDef = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2JointDef.prototype.__constructor = function() {
  this.type = b2Joint.e_unknownJoint;
  this.userData = null;
  this.bodyA = null;
  this.bodyB = null;
  this.collideConnected = false
};
b2JointDef.prototype.__varz = function() {
};
b2JointDef.prototype.type = 0;
b2JointDef.prototype.userData = null;
b2JointDef.prototype.bodyA = null;
b2JointDef.prototype.bodyB = null;
b2JointDef.prototype.collideConnected = null;var b2LineJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2LineJointDef.prototype, b2JointDef.prototype);
b2LineJointDef.prototype._super = b2JointDef.prototype;
b2LineJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_lineJoint;
  this.localAxisA.Set(1, 0);
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2LineJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2LineJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis)
};
b2LineJointDef.prototype.localAnchorA = new b2Vec2;
b2LineJointDef.prototype.localAnchorB = new b2Vec2;
b2LineJointDef.prototype.localAxisA = new b2Vec2;
b2LineJointDef.prototype.enableLimit = null;
b2LineJointDef.prototype.lowerTranslation = null;
b2LineJointDef.prototype.upperTranslation = null;
b2LineJointDef.prototype.enableMotor = null;
b2LineJointDef.prototype.maxMotorForce = null;
b2LineJointDef.prototype.motorSpeed = null;

var b2RopeJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments);
};
extend(b2RopeJoint.prototype, b2Joint.prototype);
b2RopeJoint.prototype._super = b2Joint.prototype;
b2RopeJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_length = 0;
  this.m_maxLength = def.maxLength;
  this.m_mass = 0;
  this.m_impulse = 0;
  this.m_state = b2Joint.e_inactiveLimit;
};
b2RopeJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_u = new b2Vec2;
  this.m_rA = new b2Vec2;
  this.m_rB = new b2Vec2;
};
b2RopeJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  
  this.m_rA.x = r1X;
  this.m_rA.y = r1Y;
  this.m_rB.x = r2X;
  this.m_rB.y = r2Y;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  this.m_length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(this.m_length > this.m_maxLength) {
	  this.m_state = b2Joint.e_atUpperLimit;
  }else {
	  this.m_state = b2Joint.e_inactiveLimit;
  }
  if(this.m_length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / this.m_length);
  }else {
	  this.m_u.SetZero();
	  this.m_mass = 0;
	  this.m_impulse = 0;
	  return;
  }
  
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
  }else {
    this.m_impulse = 0;
  }
};
b2RopeJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * this.m_rA.y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * this.m_rA.x;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * this.m_rB.y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * this.m_rB.x;
  
  var C = this.m_length - this.m_maxLength;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
//Predictive constraint.
  if (C < 0) {
	  Cdot += step.inv_dt * C;
  }
  var impulse = -this.m_mass * Cdot;
  var oldImpulse = this.m_impulse;
  this.m_impulse = (this.m_impulse + impulse <0) ? this.m_impulse + impulse : 0;
  impulse = this.m_impulse - oldImpulse;
  
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (this.m_rA.x * PY - this.m_rA.y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (this.m_rB.x * PY - this.m_rB.y * PX);
};
b2RopeJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_maxLength;
  C = b2Math.Clamp(C, 0, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return length - this.m_maxLength < b2Settings.b2_linearSlop; 
};
b2RopeJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
};
b2RopeJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
};
b2RopeJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
};
b2RopeJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0;
};
b2RopeJoint.prototype.GetMaxLength = function() {
  return this.m_maxLength;
};
b2RopeJoint.prototype.m_localAnchorA = new b2Vec2;
b2RopeJoint.prototype.m_localAnchorB = new b2Vec2;
b2RopeJoint.prototype.m_u = new b2Vec2;
b2RopeJoint.prototype.m_impulse = null;
b2RopeJoint.prototype.m_mass = null;
b2RopeJoint.prototype.m_length = null;

var b2RopeJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments);
};
extend(b2RopeJointDef.prototype, b2JointDef.prototype);
b2RopeJointDef.prototype._super = b2JointDef.prototype;
b2RopeJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_ropeJoint;
  this.maxLength = 0;
};
b2RopeJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2(-1,0);
  this.localAnchorB = new b2Vec2(1, 0);
};
b2RopeJointDef.prototype.localAnchorA = new b2Vec2;
b2RopeJointDef.prototype.localAnchorB = new b2Vec2;
b2RopeJointDef.prototype.maxLength = null;


var b2DistanceJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJoint.prototype, b2Joint.prototype);
b2DistanceJoint.prototype._super = b2Joint.prototype;
b2DistanceJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var tMat;
  var tX;
  var tY;
  this.m_localAnchor1.SetV(def.localAnchorA);
  this.m_localAnchor2.SetV(def.localAnchorB);
  this.m_length = def.length;
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0;
  this.m_gamma = 0;
  this.m_bias = 0
};
b2DistanceJoint.prototype.__varz = function() {
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_u = new b2Vec2
};
b2DistanceJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
  if(length > b2Settings.b2_linearSlop) {
    this.m_u.Multiply(1 / length)
  }else {
    this.m_u.SetZero()
  }
  var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
  var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
  var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
  this.m_mass = invMass != 0 ? 1 / invMass : 0;
  if(this.m_frequencyHz > 0) {
    var C = length - this.m_length;
    var omega = 2 * Math.PI * this.m_frequencyHz;
    var d = 2 * this.m_mass * this.m_dampingRatio * omega;
    var k = this.m_mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
    this.m_bias = C * step.dt * k * this.m_gamma;
    this.m_mass = invMass + this.m_gamma;
    this.m_mass = this.m_mass != 0 ? 1 / this.m_mass : 0
  }
  if(step.warmStarting) {
    this.m_impulse *= step.dtRatio;
    var PX = this.m_impulse * this.m_u.x;
    var PY = this.m_impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
  }else {
    this.m_impulse = 0
  }
};
b2DistanceJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
  var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
  var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
  var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
  var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
  var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_linearVelocity.x -= bA.m_invMass * PX;
  bA.m_linearVelocity.y -= bA.m_invMass * PY;
  bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_linearVelocity.x += bB.m_invMass * PX;
  bB.m_linearVelocity.y += bB.m_invMass * PY;
  bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX)
};
b2DistanceJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var tMat;
  if(this.m_frequencyHz > 0) {
    return true
  }
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
  var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
  var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
  r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
  r1X = tX;
  tMat = bB.m_xf.R;
  var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
  var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
  r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
  r2X = tX;
  var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
  var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
  var length = Math.sqrt(dX * dX + dY * dY);
  dX /= length;
  dY /= length;
  var C = length - this.m_length;
  C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
  var impulse = -this.m_mass * C;
  this.m_u.Set(dX, dY);
  var PX = impulse * this.m_u.x;
  var PY = impulse * this.m_u.y;
  bA.m_sweep.c.x -= bA.m_invMass * PX;
  bA.m_sweep.c.y -= bA.m_invMass * PY;
  bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
  bB.m_sweep.c.x += bB.m_invMass * PX;
  bB.m_sweep.c.y += bB.m_invMass * PY;
  bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return b2Math.Abs(C) < b2Settings.b2_linearSlop
};
b2DistanceJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2DistanceJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2DistanceJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y)
};
b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2DistanceJoint.prototype.GetLength = function() {
  return this.m_length
};
b2DistanceJoint.prototype.SetLength = function(length) {
  this.m_length = length
};
b2DistanceJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2DistanceJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2DistanceJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2DistanceJoint.prototype.m_localAnchor1 = new b2Vec2;
b2DistanceJoint.prototype.m_localAnchor2 = new b2Vec2;
b2DistanceJoint.prototype.m_u = new b2Vec2;
b2DistanceJoint.prototype.m_frequencyHz = null;
b2DistanceJoint.prototype.m_dampingRatio = null;
b2DistanceJoint.prototype.m_gamma = null;
b2DistanceJoint.prototype.m_bias = null;
b2DistanceJoint.prototype.m_impulse = null;
b2DistanceJoint.prototype.m_mass = null;
b2DistanceJoint.prototype.m_length = null;var b2PulleyJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PulleyJointDef.prototype, b2JointDef.prototype);
b2PulleyJointDef.prototype._super = b2JointDef.prototype;
b2PulleyJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_pulleyJoint;
  this.groundAnchorA.Set(-1, 1);
  this.groundAnchorB.Set(1, 1);
  this.localAnchorA.Set(-1, 0);
  this.localAnchorB.Set(1, 0);
  this.lengthA = 0;
  this.maxLengthA = 0;
  this.lengthB = 0;
  this.maxLengthB = 0;
  this.ratio = 1;
  this.collideConnected = true
};
b2PulleyJointDef.prototype.__varz = function() {
  this.groundAnchorA = new b2Vec2;
  this.groundAnchorB = new b2Vec2;
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2PulleyJointDef.prototype.Initialize = function(bA, bB, gaA, gaB, anchorA, anchorB, r) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.groundAnchorA.SetV(gaA);
  this.groundAnchorB.SetV(gaB);
  this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
  var d1X = anchorA.x - gaA.x;
  var d1Y = anchorA.y - gaA.y;
  this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
  var d2X = anchorB.x - gaB.x;
  var d2Y = anchorB.y - gaB.y;
  this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
  this.ratio = r;
  var C = this.lengthA + this.ratio * this.lengthB;
  this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
  this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio
};
b2PulleyJointDef.prototype.groundAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.groundAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorA = new b2Vec2;
b2PulleyJointDef.prototype.localAnchorB = new b2Vec2;
b2PulleyJointDef.prototype.lengthA = null;
b2PulleyJointDef.prototype.maxLengthA = null;
b2PulleyJointDef.prototype.lengthB = null;
b2PulleyJointDef.prototype.maxLengthB = null;
b2PulleyJointDef.prototype.ratio = null;var b2DistanceJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2DistanceJointDef.prototype, b2JointDef.prototype);
b2DistanceJointDef.prototype._super = b2JointDef.prototype;
b2DistanceJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_distanceJoint;
  this.length = 1;
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2DistanceJointDef.prototype.Initialize = function(bA, bB, anchorA, anchorB) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
  var dX = anchorB.x - anchorA.x;
  var dY = anchorB.y - anchorA.y;
  this.length = Math.sqrt(dX * dX + dY * dY);
  this.frequencyHz = 0;
  this.dampingRatio = 0
};
b2DistanceJointDef.prototype.localAnchorA = new b2Vec2;
b2DistanceJointDef.prototype.localAnchorB = new b2Vec2;
b2DistanceJointDef.prototype.length = null;
b2DistanceJointDef.prototype.frequencyHz = null;
b2DistanceJointDef.prototype.dampingRatio = null;var b2FrictionJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJointDef.prototype, b2JointDef.prototype);
b2FrictionJointDef.prototype._super = b2JointDef.prototype;
b2FrictionJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_frictionJoint;
  this.maxForce = 0;
  this.maxTorque = 0
};
b2FrictionJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor))
};
b2FrictionJointDef.prototype.localAnchorA = new b2Vec2;
b2FrictionJointDef.prototype.localAnchorB = new b2Vec2;
b2FrictionJointDef.prototype.maxForce = null;
b2FrictionJointDef.prototype.maxTorque = null;var b2WeldJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2WeldJointDef.prototype, b2JointDef.prototype);
b2WeldJointDef.prototype._super = b2JointDef.prototype;
b2WeldJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_weldJoint;
  this.referenceAngle = 0
};
b2WeldJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
  this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2WeldJointDef.prototype.localAnchorA = new b2Vec2;
b2WeldJointDef.prototype.localAnchorB = new b2Vec2;
b2WeldJointDef.prototype.referenceAngle = null;var b2GearJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJointDef.prototype, b2JointDef.prototype);
b2GearJointDef.prototype._super = b2JointDef.prototype;
b2GearJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_gearJoint;
  this.joint1 = null;
  this.joint2 = null;
  this.ratio = 1
};
b2GearJointDef.prototype.__varz = function() {
};
b2GearJointDef.prototype.joint1 = null;
b2GearJointDef.prototype.joint2 = null;
b2GearJointDef.prototype.ratio = null;var b2Color = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Color.prototype.__constructor = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__varz = function() {
};
b2Color.prototype.Set = function(rr, gg, bb) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1));
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1));
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
};
b2Color.prototype.__defineGetter__("r", function() {
  return this._r
});
b2Color.prototype.__defineSetter__("r", function(rr) {
  this._r = parseInt(255 * b2Math.Clamp(rr, 0, 1))
});
b2Color.prototype.__defineGetter__("g", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("g", function(gg) {
  this._g = parseInt(255 * b2Math.Clamp(gg, 0, 1))
});
b2Color.prototype.__defineGetter__("b", function() {
  return this._g
});
b2Color.prototype.__defineSetter__("b", function(bb) {
  this._b = parseInt(255 * b2Math.Clamp(bb, 0, 1))
});
b2Color.prototype.__defineGetter__("color", function() {
  return this._r << 16 | this._g << 8 | this._b
});
b2Color.prototype._r = 0;
b2Color.prototype._g = 0;
b2Color.prototype._b = 0;var b2FrictionJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2FrictionJoint.prototype, b2Joint.prototype);
b2FrictionJoint.prototype._super = b2Joint.prototype;
b2FrictionJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_localAnchorA.SetV(def.localAnchorA);
  this.m_localAnchorB.SetV(def.localAnchorB);
  this.m_linearMass.SetZero();
  this.m_angularMass = 0;
  this.m_linearImpulse.SetZero();
  this.m_angularImpulse = 0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque
};
b2FrictionJoint.prototype.__varz = function() {
  this.m_localAnchorA = new b2Vec2;
  this.m_localAnchorB = new b2Vec2;
  this.m_linearImpulse = new b2Vec2;
  this.m_linearMass = new b2Mat22
};
b2FrictionJoint.prototype.InitVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  var K = new b2Mat22;
  K.col1.x = mA + mB;
  K.col2.x = 0;
  K.col1.y = 0;
  K.col2.y = mA + mB;
  K.col1.x += iA * rAY * rAY;
  K.col2.x += -iA * rAX * rAY;
  K.col1.y += -iA * rAX * rAY;
  K.col2.y += iA * rAX * rAX;
  K.col1.x += iB * rBY * rBY;
  K.col2.x += -iB * rBX * rBY;
  K.col1.y += -iB * rBX * rBY;
  K.col2.y += iB * rBX * rBX;
  K.GetInverse(this.m_linearMass);
  this.m_angularMass = iA + iB;
  if(this.m_angularMass > 0) {
    this.m_angularMass = 1 / this.m_angularMass
  }
  if(step.warmStarting) {
    this.m_linearImpulse.x *= step.dtRatio;
    this.m_linearImpulse.y *= step.dtRatio;
    this.m_angularImpulse *= step.dtRatio;
    var P = this.m_linearImpulse;
    bA.m_linearVelocity.x -= mA * P.x;
    bA.m_linearVelocity.y -= mA * P.y;
    bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
    bB.m_linearVelocity.x += mB * P.x;
    bB.m_linearVelocity.y += mB * P.y;
    bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse)
  }else {
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0
  }
};
b2FrictionJoint.prototype.SolveVelocityConstraints = function(step) {
  var tMat;
  var tX;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var vA = bA.m_linearVelocity;
  var wA = bA.m_angularVelocity;
  var vB = bB.m_linearVelocity;
  var wB = bB.m_angularVelocity;
  var mA = bA.m_invMass;
  var mB = bB.m_invMass;
  var iA = bA.m_invI;
  var iB = bB.m_invI;
  tMat = bA.m_xf.R;
  var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
  var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
  tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
  rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
  rAX = tX;
  tMat = bB.m_xf.R;
  var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
  var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
  tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
  rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
  rBX = tX;
  var maxImpulse;
  var Cdot = wB - wA;
  var impulse = -this.m_angularMass * Cdot;
  var oldImpulse = this.m_angularImpulse;
  maxImpulse = step.dt * this.m_maxTorque;
  this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
  impulse = this.m_angularImpulse - oldImpulse;
  wA -= iA * impulse;
  wB += iB * impulse;
  var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
  var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
  var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
  var oldImpulseV = this.m_linearImpulse.Copy();
  this.m_linearImpulse.Add(impulseV);
  maxImpulse = step.dt * this.m_maxForce;
  if(this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_linearImpulse.Normalize();
    this.m_linearImpulse.Multiply(maxImpulse)
  }
  impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
  vA.x -= mA * impulseV.x;
  vA.y -= mA * impulseV.y;
  wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
  vB.x += mB * impulseV.x;
  vB.y += mB * impulseV.y;
  wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
  bA.m_angularVelocity = wA;
  bB.m_angularVelocity = wB
};
b2FrictionJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2FrictionJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
};
b2FrictionJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
};
b2FrictionJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y)
};
b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse
};
b2FrictionJoint.prototype.SetMaxForce = function(force) {
  this.m_maxForce = force
};
b2FrictionJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
  this.m_maxTorque = torque
};
b2FrictionJoint.prototype.GetMaxTorque = function() {
  return this.m_maxTorque
};
b2FrictionJoint.prototype.m_localAnchorA = new b2Vec2;
b2FrictionJoint.prototype.m_localAnchorB = new b2Vec2;
b2FrictionJoint.prototype.m_linearImpulse = new b2Vec2;
b2FrictionJoint.prototype.m_angularImpulse = null;
b2FrictionJoint.prototype.m_maxForce = null;
b2FrictionJoint.prototype.m_maxTorque = null;
b2FrictionJoint.prototype.m_linearMass = new b2Mat22;
b2FrictionJoint.prototype.m_angularMass = null;var b2Distance = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Distance.prototype.__constructor = function() {
};
b2Distance.prototype.__varz = function() {
};
b2Distance.Distance = function(output, cache, input) {
  ++b2Distance.b2_gjkCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var transformA = input.transformA;
  var transformB = input.transformB;
  var simplex = b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var vertices = simplex.m_vertices;
  var k_maxIters = 20;
  var saveA = b2Distance.s_saveA;
  var saveB = b2Distance.s_saveB;
  var saveCount = 0;
  var closestPoint = simplex.GetClosestPoint();
  var distanceSqr1 = closestPoint.LengthSquared();
  var distanceSqr2 = distanceSqr1;
  var i = 0;
  var p;
  var iter = 0;
  while(iter < k_maxIters) {
    saveCount = simplex.m_count;
    for(i = 0;i < saveCount;i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB
    }
    switch(simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        b2Settings.b2Assert(false)
    }
    if(simplex.m_count == 3) {
      break
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    if(distanceSqr2 > distanceSqr1) {
    }
    distanceSqr1 = distanceSqr2;
    var d = simplex.GetSearchDirection();
    if(d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break
    }
    var vertex = vertices[simplex.m_count];
    vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
    vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
    vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++b2Distance.b2_gjkIters;
    var duplicate = false;
    for(i = 0;i < saveCount;i++) {
      if(vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break
      }
    }
    if(duplicate) {
      break
    }
    ++simplex.m_count
  }
  b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if(input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;
    if(output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var normal = b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y
    }else {
      p = new b2Vec2;
      p.x = 0.5 * (output.pointA.x + output.pointB.x);
      p.y = 0.5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0
    }
  }
};
b2Distance.b2_gjkCalls = 0;
b2Distance.b2_gjkIters = 0;
b2Distance.b2_gjkMaxIters = 0;
b2Distance.s_simplex = new b2Simplex;
b2Distance.s_saveA = new Array(3);
b2Distance.s_saveB = new Array(3);var b2MouseJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJoint.prototype, b2Joint.prototype);
b2MouseJoint.prototype._super = b2Joint.prototype;
b2MouseJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  this.m_target.SetV(def.target);
  var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
  var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
  var tMat = this.m_bodyB.m_xf.R;
  this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
  this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
  this.m_maxForce = def.maxForce;
  this.m_impulse.SetZero();
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_beta = 0;
  this.m_gamma = 0
};
b2MouseJoint.prototype.__varz = function() {
  this.K = new b2Mat22;
  this.K1 = new b2Mat22;
  this.K2 = new b2Mat22;
  this.m_localAnchor = new b2Vec2;
  this.m_target = new b2Vec2;
  this.m_impulse = new b2Vec2;
  this.m_mass = new b2Mat22;
  this.m_C = new b2Vec2
};
b2MouseJoint.prototype.InitVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var mass = b.GetMass();
  var omega = 2 * Math.PI * this.m_frequencyHz;
  var d = 2 * mass * this.m_dampingRatio * omega;
  var k = mass * omega * omega;
  this.m_gamma = step.dt * (d + step.dt * k);
  this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;
  this.m_beta = step.dt * k * this.m_gamma;
  var tMat;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var invMass = b.m_invMass;
  var invI = b.m_invI;
  this.K1.col1.x = invMass;
  this.K1.col2.x = 0;
  this.K1.col1.y = 0;
  this.K1.col2.y = invMass;
  this.K2.col1.x = invI * rY * rY;
  this.K2.col2.x = -invI * rX * rY;
  this.K2.col1.y = -invI * rX * rY;
  this.K2.col2.y = invI * rX * rX;
  this.K.SetM(this.K1);
  this.K.AddM(this.K2);
  this.K.col1.x += this.m_gamma;
  this.K.col2.y += this.m_gamma;
  this.K.GetInverse(this.m_mass);
  this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
  this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
  b.m_angularVelocity *= 0.98;
  this.m_impulse.x *= step.dtRatio;
  this.m_impulse.y *= step.dtRatio;
  b.m_linearVelocity.x += invMass * this.m_impulse.x;
  b.m_linearVelocity.y += invMass * this.m_impulse.y;
  b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x)
};
b2MouseJoint.prototype.SolveVelocityConstraints = function(step) {
  var b = this.m_bodyB;
  var tMat;
  var tX;
  var tY;
  tMat = b.m_xf.R;
  var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
  var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
  tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
  var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
  tMat = this.m_mass;
  tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
  tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
  var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
  var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
  var oldImpulseX = this.m_impulse.x;
  var oldImpulseY = this.m_impulse.y;
  this.m_impulse.x += impulseX;
  this.m_impulse.y += impulseY;
  var maxImpulse = step.dt * this.m_maxForce;
  if(this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
    this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length())
  }
  impulseX = this.m_impulse.x - oldImpulseX;
  impulseY = this.m_impulse.y - oldImpulseY;
  b.m_linearVelocity.x += b.m_invMass * impulseX;
  b.m_linearVelocity.y += b.m_invMass * impulseY;
  b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX)
};
b2MouseJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  return true
};
b2MouseJoint.prototype.GetAnchorA = function() {
  return this.m_target
};
b2MouseJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
};
b2MouseJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y)
};
b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
  return 0
};
b2MouseJoint.prototype.GetTarget = function() {
  return this.m_target
};
b2MouseJoint.prototype.SetTarget = function(target) {
  if(this.m_bodyB.IsAwake() == false) {
    this.m_bodyB.SetAwake(true)
  }
  this.m_target = target
};
b2MouseJoint.prototype.GetMaxForce = function() {
  return this.m_maxForce
};
b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
  this.m_maxForce = maxForce
};
b2MouseJoint.prototype.GetFrequency = function() {
  return this.m_frequencyHz
};
b2MouseJoint.prototype.SetFrequency = function(hz) {
  this.m_frequencyHz = hz
};
b2MouseJoint.prototype.GetDampingRatio = function() {
  return this.m_dampingRatio
};
b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio
};
b2MouseJoint.prototype.K = new b2Mat22;
b2MouseJoint.prototype.K1 = new b2Mat22;
b2MouseJoint.prototype.K2 = new b2Mat22;
b2MouseJoint.prototype.m_localAnchor = new b2Vec2;
b2MouseJoint.prototype.m_target = new b2Vec2;
b2MouseJoint.prototype.m_impulse = new b2Vec2;
b2MouseJoint.prototype.m_mass = new b2Mat22;
b2MouseJoint.prototype.m_C = new b2Vec2;
b2MouseJoint.prototype.m_maxForce = null;
b2MouseJoint.prototype.m_frequencyHz = null;
b2MouseJoint.prototype.m_dampingRatio = null;
b2MouseJoint.prototype.m_beta = null;
b2MouseJoint.prototype.m_gamma = null;var b2PrismaticJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PrismaticJointDef.prototype, b2JointDef.prototype);
b2PrismaticJointDef.prototype._super = b2JointDef.prototype;
b2PrismaticJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_prismaticJoint;
  this.localAxisA.Set(1, 0);
  this.referenceAngle = 0;
  this.enableLimit = false;
  this.lowerTranslation = 0;
  this.upperTranslation = 0;
  this.enableMotor = false;
  this.maxMotorForce = 0;
  this.motorSpeed = 0
};
b2PrismaticJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2;
  this.localAxisA = new b2Vec2
};
b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.localAxisA = this.bodyA.GetLocalVector(axis);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2PrismaticJointDef.prototype.localAnchorA = new b2Vec2;
b2PrismaticJointDef.prototype.localAnchorB = new b2Vec2;
b2PrismaticJointDef.prototype.localAxisA = new b2Vec2;
b2PrismaticJointDef.prototype.referenceAngle = null;
b2PrismaticJointDef.prototype.enableLimit = null;
b2PrismaticJointDef.prototype.lowerTranslation = null;
b2PrismaticJointDef.prototype.upperTranslation = null;
b2PrismaticJointDef.prototype.enableMotor = null;
b2PrismaticJointDef.prototype.maxMotorForce = null;
b2PrismaticJointDef.prototype.motorSpeed = null;var b2TimeOfImpact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TimeOfImpact.prototype.__constructor = function() {
};
b2TimeOfImpact.prototype.__varz = function() {
};
b2TimeOfImpact.TimeOfImpact = function(input) {
  ++b2TimeOfImpact.b2_toiCalls;
  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var sweepA = input.sweepA;
  var sweepB = input.sweepB;
  b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
  b2Settings.b2Assert(1 - sweepA.t0 > Number.MIN_VALUE);
  var radius = proxyA.m_radius + proxyB.m_radius;
  var tolerance = input.tolerance;
  var alpha = 0;
  var k_maxIterations = 1E3;
  var iter = 0;
  var target = 0;
  b2TimeOfImpact.s_cache.count = 0;
  b2TimeOfImpact.s_distanceInput.useRadii = false;
  for(;;) {
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
    b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
    b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
    b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
    b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
    b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
    if(b2TimeOfImpact.s_distanceOutput.distance <= 0) {
      alpha = 1;
      break
    }
    b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
    var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(separation <= 0) {
      alpha = 1;
      break
    }
    if(iter == 0) {
      if(separation > radius) {
        target = b2Math.Max(radius - tolerance, 0.75 * radius)
      }else {
        target = b2Math.Max(separation - tolerance, 0.02 * radius)
      }
    }
    if(separation - target < 0.5 * tolerance) {
      if(iter == 0) {
        alpha = 1;
        break
      }
      break
    }
    var newAlpha = alpha;
    var x1 = alpha;
    var x2 = 1;
    var f1 = separation;
    sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
    sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
    var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
    if(f2 >= target) {
      alpha = 1;
      break
    }
    var rootIterCount = 0;
    for(;;) {
      var x;
      if(rootIterCount & 1) {
        x = x1 + (target - f1) * (x2 - x1) / (f2 - f1)
      }else {
        x = 0.5 * (x1 + x2)
      }
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
      var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
      if(b2Math.Abs(f - target) < 0.025 * tolerance) {
        newAlpha = x;
        break
      }
      if(f > target) {
        x1 = x;
        f1 = f
      }else {
        x2 = x;
        f2 = f
      }
      ++rootIterCount;
      ++b2TimeOfImpact.b2_toiRootIters;
      if(rootIterCount == 50) {
        break
      }
    }
    b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
    if(newAlpha < (1 + 100 * Number.MIN_VALUE) * alpha) {
      break
    }
    alpha = newAlpha;
    iter++;
    ++b2TimeOfImpact.b2_toiIters;
    if(iter == k_maxIterations) {
      break
    }
  }
  b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
  return alpha
};
b2TimeOfImpact.b2_toiCalls = 0;
b2TimeOfImpact.b2_toiIters = 0;
b2TimeOfImpact.b2_toiMaxIters = 0;
b2TimeOfImpact.b2_toiRootIters = 0;
b2TimeOfImpact.b2_toiMaxRootIters = 0;
b2TimeOfImpact.s_cache = new b2SimplexCache;
b2TimeOfImpact.s_distanceInput = new b2DistanceInput;
b2TimeOfImpact.s_xfA = new b2Transform;
b2TimeOfImpact.s_xfB = new b2Transform;
b2TimeOfImpact.s_fcn = new b2SeparationFunction;
b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput;var b2GearJoint = function() {
  b2Joint.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2GearJoint.prototype, b2Joint.prototype);
b2GearJoint.prototype._super = b2Joint.prototype;
b2GearJoint.prototype.__constructor = function(def) {
  this._super.__constructor.apply(this, [def]);
  var type1 = def.joint1.m_type;
  var type2 = def.joint2.m_type;
  this.m_revolute1 = null;
  this.m_prismatic1 = null;
  this.m_revolute2 = null;
  this.m_prismatic2 = null;
  var coordinate1;
  var coordinate2;
  this.m_ground1 = def.joint1.GetBodyA();
  this.m_bodyA = def.joint1.GetBodyB();
  if(type1 == b2Joint.e_revoluteJoint) {
    this.m_revolute1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    this.m_prismatic1 = def.joint1;
    this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
    this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  this.m_ground2 = def.joint2.GetBodyA();
  this.m_bodyB = def.joint2.GetBodyB();
  if(type2 == b2Joint.e_revoluteJoint) {
    this.m_revolute2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    this.m_prismatic2 = def.joint2;
    this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
    this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  this.m_ratio = def.ratio;
  this.m_constant = coordinate1 + this.m_ratio * coordinate2;
  this.m_impulse = 0
};
b2GearJoint.prototype.__varz = function() {
  this.m_groundAnchor1 = new b2Vec2;
  this.m_groundAnchor2 = new b2Vec2;
  this.m_localAnchor1 = new b2Vec2;
  this.m_localAnchor2 = new b2Vec2;
  this.m_J = new b2Jacobian
};
b2GearJoint.prototype.InitVelocityConstraints = function(step) {
  var g1 = this.m_ground1;
  var g2 = this.m_ground2;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var ugX;
  var ugY;
  var rX;
  var rY;
  var tMat;
  var tVec;
  var crug;
  var tX;
  var K = 0;
  this.m_J.SetZero();
  if(this.m_revolute1) {
    this.m_J.angularA = -1;
    K += bA.m_invI
  }else {
    tMat = g1.m_xf.R;
    tVec = this.m_prismatic1.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bA.m_xf.R;
    rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearA.Set(-ugX, -ugY);
    this.m_J.angularA = -crug;
    K += bA.m_invMass + bA.m_invI * crug * crug
  }
  if(this.m_revolute2) {
    this.m_J.angularB = -this.m_ratio;
    K += this.m_ratio * this.m_ratio * bB.m_invI
  }else {
    tMat = g2.m_xf.R;
    tVec = this.m_prismatic2.m_localXAxis1;
    ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = bB.m_xf.R;
    rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    crug = rX * ugY - rY * ugX;
    this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
    this.m_J.angularB = -this.m_ratio * crug;
    K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug)
  }
  this.m_mass = K > 0 ? 1 / K : 0;
  if(step.warmStarting) {
    bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB
  }else {
    this.m_impulse = 0
  }
};
b2GearJoint.prototype.SolveVelocityConstraints = function(step) {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
  var impulse = -this.m_mass * Cdot;
  this.m_impulse += impulse;
  bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB
};
b2GearJoint.prototype.SolvePositionConstraints = function(baumgarte) {
  var linearError = 0;
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  var coordinate1;
  var coordinate2;
  if(this.m_revolute1) {
    coordinate1 = this.m_revolute1.GetJointAngle()
  }else {
    coordinate1 = this.m_prismatic1.GetJointTranslation()
  }
  if(this.m_revolute2) {
    coordinate2 = this.m_revolute2.GetJointAngle()
  }else {
    coordinate2 = this.m_prismatic2.GetJointTranslation()
  }
  var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
  var impulse = -this.m_mass * C;
  bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
  bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
  bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
  bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
  bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
  bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
  bA.SynchronizeTransform();
  bB.SynchronizeTransform();
  return linearError < b2Settings.b2_linearSlop
};
b2GearJoint.prototype.GetAnchorA = function() {
  return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
};
b2GearJoint.prototype.GetAnchorB = function() {
  return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
};
b2GearJoint.prototype.GetReactionForce = function(inv_dt) {
  return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y)
};
b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
  var tMat = this.m_bodyB.m_xf.R;
  var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
  var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
  var tX = tMat.col1.x * rX + tMat.col2.x * rY;
  rY = tMat.col1.y * rX + tMat.col2.y * rY;
  rX = tX;
  var PX = this.m_impulse * this.m_J.linearB.x;
  var PY = this.m_impulse * this.m_J.linearB.y;
  return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX)
};
b2GearJoint.prototype.GetRatio = function() {
  return this.m_ratio
};
b2GearJoint.prototype.SetRatio = function(ratio) {
  this.m_ratio = ratio
};
b2GearJoint.prototype.m_ground1 = null;
b2GearJoint.prototype.m_ground2 = null;
b2GearJoint.prototype.m_revolute1 = null;
b2GearJoint.prototype.m_prismatic1 = null;
b2GearJoint.prototype.m_revolute2 = null;
b2GearJoint.prototype.m_prismatic2 = null;
b2GearJoint.prototype.m_groundAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_groundAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor1 = new b2Vec2;
b2GearJoint.prototype.m_localAnchor2 = new b2Vec2;
b2GearJoint.prototype.m_J = new b2Jacobian;
b2GearJoint.prototype.m_constant = null;
b2GearJoint.prototype.m_ratio = null;
b2GearJoint.prototype.m_mass = null;
b2GearJoint.prototype.m_impulse = null;var b2TOIInput = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2TOIInput.prototype.__constructor = function() {
};
b2TOIInput.prototype.__varz = function() {
  this.proxyA = new b2DistanceProxy;
  this.proxyB = new b2DistanceProxy;
  this.sweepA = new b2Sweep;
  this.sweepB = new b2Sweep
};
b2TOIInput.prototype.proxyA = new b2DistanceProxy;
b2TOIInput.prototype.proxyB = new b2DistanceProxy;
b2TOIInput.prototype.sweepA = new b2Sweep;
b2TOIInput.prototype.sweepB = new b2Sweep;
b2TOIInput.prototype.tolerance = null;var b2RevoluteJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2RevoluteJointDef.prototype, b2JointDef.prototype);
b2RevoluteJointDef.prototype._super = b2JointDef.prototype;
b2RevoluteJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_revoluteJoint;
  this.localAnchorA.Set(0, 0);
  this.localAnchorB.Set(0, 0);
  this.referenceAngle = 0;
  this.lowerAngle = 0;
  this.upperAngle = 0;
  this.maxMotorTorque = 0;
  this.motorSpeed = 0;
  this.enableLimit = false;
  this.enableMotor = false
};
b2RevoluteJointDef.prototype.__varz = function() {
  this.localAnchorA = new b2Vec2;
  this.localAnchorB = new b2Vec2
};
b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
  this.bodyA = bA;
  this.bodyB = bB;
  this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
  this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
  this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
};
b2RevoluteJointDef.prototype.localAnchorA = new b2Vec2;
b2RevoluteJointDef.prototype.localAnchorB = new b2Vec2;
b2RevoluteJointDef.prototype.referenceAngle = null;
b2RevoluteJointDef.prototype.enableLimit = null;
b2RevoluteJointDef.prototype.lowerAngle = null;
b2RevoluteJointDef.prototype.upperAngle = null;
b2RevoluteJointDef.prototype.enableMotor = null;
b2RevoluteJointDef.prototype.motorSpeed = null;
b2RevoluteJointDef.prototype.maxMotorTorque = null;var b2MouseJointDef = function() {
  b2JointDef.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2MouseJointDef.prototype, b2JointDef.prototype);
b2MouseJointDef.prototype._super = b2JointDef.prototype;
b2MouseJointDef.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments);
  this.type = b2Joint.e_mouseJoint;
  this.maxForce = 0;
  this.frequencyHz = 5;
  this.dampingRatio = 0.7
};
b2MouseJointDef.prototype.__varz = function() {
  this.target = new b2Vec2
};
b2MouseJointDef.prototype.target = new b2Vec2;
b2MouseJointDef.prototype.maxForce = null;
b2MouseJointDef.prototype.frequencyHz = null;
b2MouseJointDef.prototype.dampingRatio = null;var b2Contact = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Contact.prototype.__constructor = function() {
};
b2Contact.prototype.__varz = function() {
  this.m_nodeA = new b2ContactEdge;
  this.m_nodeB = new b2ContactEdge;
  this.m_manifold = new b2Manifold;
  this.m_oldManifold = new b2Manifold
};
b2Contact.s_input = new b2TOIInput;
b2Contact.e_sensorFlag = 1;
b2Contact.e_continuousFlag = 2;
b2Contact.e_islandFlag = 4;
b2Contact.e_toiFlag = 8;
b2Contact.e_touchingFlag = 16;
b2Contact.e_enabledFlag = 32;
b2Contact.e_filterFlag = 64;
b2Contact.prototype.Reset = function(fixtureA, fixtureB) {
  this.m_flags = b2Contact.e_enabledFlag;
  if(!fixtureA || !fixtureB) {
    this.m_fixtureA = null;
    this.m_fixtureB = null;
    return
  }
  if(fixtureA.IsSensor() || fixtureB.IsSensor()) {
    this.m_flags |= b2Contact.e_sensorFlag
  }
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
    this.m_flags |= b2Contact.e_continuousFlag
  }
  this.m_fixtureA = fixtureA;
  this.m_fixtureB = fixtureB;
  this.m_manifold.m_pointCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_nodeA.contact = null;
  this.m_nodeA.prev = null;
  this.m_nodeA.next = null;
  this.m_nodeA.other = null;
  this.m_nodeB.contact = null;
  this.m_nodeB.prev = null;
  this.m_nodeB.next = null;
  this.m_nodeB.other = null
};
b2Contact.prototype.Update = function(listener) {
  var tManifold = this.m_oldManifold;
  this.m_oldManifold = this.m_manifold;
  this.m_manifold = tManifold;
  this.m_flags |= b2Contact.e_enabledFlag;
  var touching = false;
  var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;
  var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
  if(this.m_flags & b2Contact.e_sensorFlag) {
    if(aabbOverlap) {
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      var xfA = bodyA.GetTransform();
      var xfB = bodyB.GetTransform();
      touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB)
    }
    this.m_manifold.m_pointCount = 0
  }else {
    if(bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag
    }else {
      this.m_flags &= ~b2Contact.e_continuousFlag
    }
    if(aabbOverlap) {
      this.Evaluate();
      touching = this.m_manifold.m_pointCount > 0;
      for(var i = 0;i < this.m_manifold.m_pointCount;++i) {
        var mp2 = this.m_manifold.m_points[i];
        mp2.m_normalImpulse = 0;
        mp2.m_tangentImpulse = 0;
        var id2 = mp2.m_id;
        for(var j = 0;j < this.m_oldManifold.m_pointCount;++j) {
          var mp1 = this.m_oldManifold.m_points[j];
          if(mp1.m_id.key == id2.key) {
            mp2.m_normalImpulse = mp1.m_normalImpulse;
            mp2.m_tangentImpulse = mp1.m_tangentImpulse;
            break
          }
        }
      }
    }else {
      this.m_manifold.m_pointCount = 0
    }
    if(touching != wasTouching) {
      bodyA.SetAwake(true);
      bodyB.SetAwake(true)
    }
  }
  if(touching) {
    this.m_flags |= b2Contact.e_touchingFlag
  }else {
    this.m_flags &= ~b2Contact.e_touchingFlag
  }
  if(wasTouching == false && touching == true) {
    listener.BeginContact(this)
  }
  if(wasTouching == true && touching == false) {
    listener.EndContact(this)
  }
  if((this.m_flags & b2Contact.e_sensorFlag) == 0) {
    listener.PreSolve(this, this.m_oldManifold)
  }
};
b2Contact.prototype.Evaluate = function() {
};
b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
  b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
  b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
  b2Contact.s_input.sweepA = sweepA;
  b2Contact.s_input.sweepB = sweepB;
  b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
  return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input)
};
b2Contact.prototype.GetManifold = function() {
  return this.m_manifold
};
b2Contact.prototype.GetWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.GetBody();
  var bodyB = this.m_fixtureB.GetBody();
  var shapeA = this.m_fixtureA.GetShape();
  var shapeB = this.m_fixtureB.GetShape();
  worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius)
};
b2Contact.prototype.IsTouching = function() {
  return(this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag
};
b2Contact.prototype.IsContinuous = function() {
  return(this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag
};
b2Contact.prototype.SetSensor = function(sensor) {
  if(sensor) {
    this.m_flags |= b2Contact.e_sensorFlag
  }else {
    this.m_flags &= ~b2Contact.e_sensorFlag
  }
};
b2Contact.prototype.IsSensor = function() {
  return(this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag
};
b2Contact.prototype.SetEnabled = function(flag) {
  if(flag) {
    this.m_flags |= b2Contact.e_enabledFlag
  }else {
    this.m_flags &= ~b2Contact.e_enabledFlag
  }
};
b2Contact.prototype.IsEnabled = function() {
  return(this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag
};
b2Contact.prototype.GetNext = function() {
  return this.m_next
};
b2Contact.prototype.GetFixtureA = function() {
  return this.m_fixtureA
};
b2Contact.prototype.GetFixtureB = function() {
  return this.m_fixtureB
};
b2Contact.prototype.FlagForFiltering = function() {
  this.m_flags |= b2Contact.e_filterFlag
};
b2Contact.prototype.m_flags = 0;
b2Contact.prototype.m_prev = null;
b2Contact.prototype.m_next = null;
b2Contact.prototype.m_nodeA = new b2ContactEdge;
b2Contact.prototype.m_nodeB = new b2ContactEdge;
b2Contact.prototype.m_fixtureA = null;
b2Contact.prototype.m_fixtureB = null;
b2Contact.prototype.m_manifold = new b2Manifold;
b2Contact.prototype.m_oldManifold = new b2Manifold;
b2Contact.prototype.m_toi = null;var b2ContactConstraint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactConstraint.prototype.__constructor = function() {
  this.points = new Array(b2Settings.b2_maxManifoldPoints);
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;i++) {
    this.points[i] = new b2ContactConstraintPoint
  }
};
b2ContactConstraint.prototype.__varz = function() {
  this.localPlaneNormal = new b2Vec2;
  this.localPoint = new b2Vec2;
  this.normal = new b2Vec2;
  this.normalMass = new b2Mat22;
  this.K = new b2Mat22
};
b2ContactConstraint.prototype.points = null;
b2ContactConstraint.prototype.localPlaneNormal = new b2Vec2;
b2ContactConstraint.prototype.localPoint = new b2Vec2;
b2ContactConstraint.prototype.normal = new b2Vec2;
b2ContactConstraint.prototype.normalMass = new b2Mat22;
b2ContactConstraint.prototype.K = new b2Mat22;
b2ContactConstraint.prototype.bodyA = null;
b2ContactConstraint.prototype.bodyB = null;
b2ContactConstraint.prototype.type = 0;
b2ContactConstraint.prototype.radius = null;
b2ContactConstraint.prototype.friction = null;
b2ContactConstraint.prototype.restitution = null;
b2ContactConstraint.prototype.pointCount = 0;
b2ContactConstraint.prototype.manifold = null;var b2ContactResult = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactResult.prototype.__constructor = function() {
};
b2ContactResult.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactResult.prototype.shape1 = null;
b2ContactResult.prototype.shape2 = null;
b2ContactResult.prototype.position = new b2Vec2;
b2ContactResult.prototype.normal = new b2Vec2;
b2ContactResult.prototype.normalImpulse = null;
b2ContactResult.prototype.tangentImpulse = null;
b2ContactResult.prototype.id = new b2ContactID;var b2PolygonContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolygonContact.prototype, b2Contact.prototype);
b2PolygonContact.prototype._super = b2Contact.prototype;
b2PolygonContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolygonContact.prototype.__varz = function() {
};
b2PolygonContact.Create = function(allocator) {
  return new b2PolygonContact
};
b2PolygonContact.Destroy = function(contact, allocator) {
};
b2PolygonContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolygonContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var ClipVertex = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
ClipVertex.prototype.__constructor = function() {
};
ClipVertex.prototype.__varz = function() {
  this.v = new b2Vec2;
  this.id = new b2ContactID
};
ClipVertex.prototype.Set = function(other) {
  this.v.SetV(other.v);
  this.id.Set(other.id)
};
ClipVertex.prototype.v = new b2Vec2;
ClipVertex.prototype.id = new b2ContactID;var b2ContactFilter = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactFilter.prototype.__constructor = function() {
};
b2ContactFilter.prototype.__varz = function() {
};
b2ContactFilter.b2_defaultFilter = new b2ContactFilter;
b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
  var filter1 = fixtureA.GetFilterData();
  var filter2 = fixtureB.GetFilterData();
  if(filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
    return filter1.groupIndex > 0
  }
  var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
  return collide
};
b2ContactFilter.prototype.RayCollide = function(userData, fixture) {
  if(!userData) {
    return true
  }
  return this.ShouldCollide(userData, fixture)
};var b2NullContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2NullContact.prototype, b2Contact.prototype);
b2NullContact.prototype._super = b2Contact.prototype;
b2NullContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2NullContact.prototype.__varz = function() {
};
b2NullContact.prototype.Evaluate = function() {
};var b2ContactListener = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactListener.prototype.__constructor = function() {
};
b2ContactListener.prototype.__varz = function() {
};
b2ContactListener.b2_defaultListener = new b2ContactListener;
b2ContactListener.prototype.BeginContact = function(contact) {
};
b2ContactListener.prototype.EndContact = function(contact) {
};
b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {
};
b2ContactListener.prototype.PostSolve = function(contact, impulse) {
};var b2Island = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Island.prototype.__constructor = function() {
  this.m_bodies = new Array;
  this.m_contacts = new Array;
  this.m_joints = new Array
};
b2Island.prototype.__varz = function() {
};
b2Island.s_impulse = new b2ContactImpulse;
b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
  var i = 0;
  this.m_bodyCapacity = bodyCapacity;
  this.m_contactCapacity = contactCapacity;
  this.m_jointCapacity = jointCapacity;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_allocator = allocator;
  this.m_listener = listener;
  this.m_contactSolver = contactSolver;
  for(i = this.m_bodies.length;i < bodyCapacity;i++) {
    this.m_bodies[i] = null
  }
  for(i = this.m_contacts.length;i < contactCapacity;i++) {
    this.m_contacts[i] = null
  }
  for(i = this.m_joints.length;i < jointCapacity;i++) {
    this.m_joints[i] = null
  }
};
b2Island.prototype.Clear = function() {
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0
};
b2Island.prototype.Solve = function(step, gravity, allowSleep) {
  var i = 0;
  var j = 0;
  var b;
  var joint;
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() != b2Body.b2_dynamicBody) {
      continue
    }
    b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
    b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
    b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
    b.m_linearVelocity.Multiply(b2Math.Clamp(1 - step.dt * b.m_linearDamping, 0, 1));
    b.m_angularVelocity *= b2Math.Clamp(1 - step.dt * b.m_angularDamping, 0, 1)
  }
  this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  contactSolver.InitVelocityConstraints(step);
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.InitVelocityConstraints(step)
  }
  for(i = 0;i < step.velocityIterations;++i) {
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      joint.SolveVelocityConstraints(step)
    }
    contactSolver.SolveVelocityConstraints()
  }
  for(i = 0;i < this.m_jointCount;++i) {
    joint = this.m_joints[i];
    joint.FinalizeVelocityConstraints()
  }
  contactSolver.FinalizeVelocityConstraints();
  for(i = 0;i < this.m_bodyCount;++i) {
    b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = step.dt * b.m_linearVelocity.x;
    var translationY = step.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
    }
    var rotation = step.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
    b.m_sweep.a += step.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  for(i = 0;i < step.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      joint = this.m_joints[j];
      var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints);
  if(allowSleep) {
    var minSleepTime = Number.MAX_VALUE;
    var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
    var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
    for(i = 0;i < this.m_bodyCount;++i) {
      b = this.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }
      if((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
        b.m_sleepTime = 0;
        minSleepTime = 0
      }else {
        b.m_sleepTime += step.dt;
        minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
      }
    }
    if(minSleepTime >= b2Settings.b2_timeToSleep) {
      for(i = 0;i < this.m_bodyCount;++i) {
        b = this.m_bodies[i];
        b.SetAwake(false)
      }
    }
  }
};
b2Island.prototype.SolveTOI = function(subStep) {
  var i = 0;
  var j = 0;
  this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
  var contactSolver = this.m_contactSolver;
  for(i = 0;i < this.m_jointCount;++i) {
    this.m_joints[i].InitVelocityConstraints(subStep)
  }
  for(i = 0;i < subStep.velocityIterations;++i) {
    contactSolver.SolveVelocityConstraints();
    for(j = 0;j < this.m_jointCount;++j) {
      this.m_joints[j].SolveVelocityConstraints(subStep)
    }
  }
  for(i = 0;i < this.m_bodyCount;++i) {
    var b = this.m_bodies[i];
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    var translationX = subStep.dt * b.m_linearVelocity.x;
    var translationY = subStep.dt * b.m_linearVelocity.y;
    if(translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
      b.m_linearVelocity.Normalize();
      b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
    }
    var rotation = subStep.dt * b.m_angularVelocity;
    if(rotation * rotation > b2Settings.b2_maxRotationSquared) {
      if(b.m_angularVelocity < 0) {
        b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt
      }else {
        b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      }
    }
    b.m_sweep.c0.SetV(b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a;
    b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
    b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
    b.m_sweep.a += subStep.dt * b.m_angularVelocity;
    b.SynchronizeTransform()
  }
  var k_toiBaumgarte = 0.75;
  for(i = 0;i < subStep.positionIterations;++i) {
    var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
    var jointsOkay = true;
    for(j = 0;j < this.m_jointCount;++j) {
      var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      jointsOkay = jointsOkay && jointOkay
    }
    if(contactsOkay && jointsOkay) {
      break
    }
  }
  this.Report(contactSolver.m_constraints)
};
b2Island.prototype.Report = function(constraints) {
  if(this.m_listener == null) {
    return
  }
  for(var i = 0;i < this.m_contactCount;++i) {
    var c = this.m_contacts[i];
    var cc = constraints[i];
    for(var j = 0;j < cc.pointCount;++j) {
      b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
      b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
    }
    this.m_listener.PostSolve(c, b2Island.s_impulse)
  }
};
b2Island.prototype.AddBody = function(body) {
  body.m_islandIndex = this.m_bodyCount;
  this.m_bodies[this.m_bodyCount++] = body
};
b2Island.prototype.AddContact = function(contact) {
  this.m_contacts[this.m_contactCount++] = contact
};
b2Island.prototype.AddJoint = function(joint) {
  this.m_joints[this.m_jointCount++] = joint
};
b2Island.prototype.m_allocator = null;
b2Island.prototype.m_listener = null;
b2Island.prototype.m_contactSolver = null;
b2Island.prototype.m_bodies = null;
b2Island.prototype.m_contacts = null;
b2Island.prototype.m_joints = null;
b2Island.prototype.m_bodyCount = 0;
b2Island.prototype.m_jointCount = 0;
b2Island.prototype.m_contactCount = 0;
b2Island.prototype.m_bodyCapacity = 0;
b2Island.prototype.m_contactCapacity = 0;
b2Island.prototype.m_jointCapacity = 0;var b2PolyAndEdgeContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndEdgeContact.prototype, b2Contact.prototype);
b2PolyAndEdgeContact.prototype._super = b2Contact.prototype;
b2PolyAndEdgeContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndEdgeContact.prototype.__varz = function() {
};
b2PolyAndEdgeContact.Create = function(allocator) {
  return new b2PolyAndEdgeContact
};
b2PolyAndEdgeContact.Destroy = function(contact, allocator) {
};
b2PolyAndEdgeContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function(manifold, polygon, xf1, edge, xf2) {
};
b2PolyAndEdgeContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape)
};var b2Collision = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2Collision.prototype.__constructor = function() {
};
b2Collision.prototype.__varz = function() {
};
b2Collision.MakeClipPointVector = function() {
  var r = new Array(2);
  r[0] = new ClipVertex;
  r[1] = new ClipVertex;
  return r
};
b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var cv;
  var numOut = 0;
  cv = vIn[0];
  var vIn0 = cv.v;
  cv = vIn[1];
  var vIn1 = cv.v;
  var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if(distance0 <= 0) {
    vOut[numOut++].Set(vIn[0])
  }
  if(distance1 <= 0) {
    vOut[numOut++].Set(vIn[1])
  }
  if(distance0 * distance1 < 0) {
    var interp = distance0 / (distance0 - distance1);
    cv = vOut[numOut];
    var tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = vOut[numOut];
    var cv2;
    if(distance0 > 0) {
      cv2 = vIn[0];
      cv.id = cv2.id
    }else {
      cv2 = vIn[1];
      cv.id = cv2.id
    }
    ++numOut
  }
  return numOut
};
b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
  var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = vertices2[i];
    var dot = tVec.x * normal1X + tVec.y * normal1Y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  tVec = vertices1[edge1];
  tMat = xf1.R;
  var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = vertices2[index];
  tMat = xf2.R;
  var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation
};
b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
  var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
  var edge = 0;
  var maxDot = -Number.MAX_VALUE;
  for(var i = 0;i < count1;++i) {
    tVec = normals1[i];
    var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;
    if(dot > maxDot) {
      maxDot = dot;
      edge = i
    }
  }
  var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var prevEdge = edge - 1 >= 0 ? edge - 1 : count1 - 1;
  var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var nextEdge = edge + 1 < count1 ? edge + 1 : 0;
  var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  var bestEdge = 0;
  var bestSeparation;
  var increment = 0;
  if(sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev
  }else {
    if(sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext
    }else {
      edgeIndex[0] = edge;
      return s
    }
  }
  while(true) {
    if(increment == -1) {
      edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1
    }else {
      edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0
    }
    s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if(s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s
    }else {
      break
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation
};
b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var count1 = poly1.m_vertexCount;
  var normals1 = poly1.m_normals;
  var count2 = poly2.m_vertexCount;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = normals1[edge1];
  var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
  var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
  tMat = xf2.R;
  var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
  normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
  normal1X = tX;
  var index = 0;
  var minDot = Number.MAX_VALUE;
  for(var i = 0;i < count2;++i) {
    tVec = normals2[i];
    var dot = normal1X * tVec.x + normal1Y * tVec.y;
    if(dot < minDot) {
      minDot = dot;
      index = i
    }
  }
  var tClip;
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
  tClip = c[0];
  tVec = vertices2[i1];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = c[1];
  tVec = vertices2[i2];
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1
};
b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var cv;
  manifold.m_pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;
  var edgeA = 0;
  b2Collision.s_edgeAO[0] = edgeA;
  var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = b2Collision.s_edgeAO[0];
  if(separationA > totalRadius) {
    return
  }
  var edgeB = 0;
  b2Collision.s_edgeBO[0] = edgeB;
  var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = b2Collision.s_edgeBO[0];
  if(separationB > totalRadius) {
    return
  }
  var poly1;
  var poly2;
  var xf1;
  var xf2;
  var edge1 = 0;
  var flip = 0;
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.0010;
  var tMat;
  if(separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = b2Manifold.e_faceB;
    flip = 1
  }else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = b2Manifold.e_faceA;
    flip = 0
  }
  var incidentEdge = b2Collision.s_incidentEdge;
  b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var count1 = poly1.m_vertexCount;
  var vertices1 = poly1.m_vertices;
  var local_v11 = vertices1[edge1];
  var local_v12;
  if(edge1 + 1 < count1) {
    local_v12 = vertices1[parseInt(edge1 + 1)]
  }else {
    local_v12 = vertices1[0]
  }
  var localTangent = b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var localNormal = b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var planePoint = b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var tangent = b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
  tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
  var tangent2 = b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var normal = b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var v11 = b2Collision.s_v11;
  var v12 = b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var frontOffset = normal.x * v11.x + normal.y * v11.y;
  var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var clipPoints1 = b2Collision.s_clipPoints1;
  var clipPoints2 = b2Collision.s_clipPoints2;
  var np = 0;
  np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if(np < 2) {
    return
  }
  np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if(np < 2) {
    return
  }
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var pointCount = 0;
  for(var i = 0;i < b2Settings.b2_maxManifoldPoints;++i) {
    cv = clipPoints2[i];
    var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if(separation <= totalRadius) {
      var cp = manifold.m_points[pointCount];
      tMat = xf2.R;
      var tX = cv.v.x - xf2.position.x;
      var tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
      cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = flip;
      ++pointCount
    }
  }
  manifold.m_pointCount = pointCount
};
b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  manifold.m_pointCount = 0;
  var tMat;
  var tVec;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var dX = p2X - p1X;
  var dY = p2Y - p1Y;
  var distSqr = dX * dX + dY * dY;
  var radius = circle1.m_radius + circle2.m_radius;
  if(distSqr > radius * radius) {
    return
  }
  manifold.m_type = b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0
};
b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  manifold.m_pointCount = 0;
  var tPoint;
  var dX;
  var dY;
  var positionX;
  var positionY;
  var tVec;
  var tMat;
  tMat = xf2.R;
  tVec = circle.m_p;
  var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
  var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
  var dist;
  var normalIndex = 0;
  var separation = -Number.MAX_VALUE;
  var radius = polygon.m_radius + circle.m_radius;
  var vertexCount = polygon.m_vertexCount;
  var vertices = polygon.m_vertices;
  var normals = polygon.m_normals;
  for(var i = 0;i < vertexCount;++i) {
    tVec = vertices[i];
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = normals[i];
    var s = tVec.x * dX + tVec.y * dY;
    if(s > radius) {
      return
    }
    if(s > separation) {
      separation = s;
      normalIndex = i
    }
  }
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];
  if(separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return
  }
  var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if(u1 <= 0) {
    if((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) {
      return
    }
    manifold.m_pointCount = 1;
    manifold.m_type = b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0
  }else {
    if(u2 <= 0) {
      if((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if(separation > radius) {
        return
      }
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0
    }
  }
};
b2Collision.TestOverlap = function(a, b) {
  var t1 = b.lowerBound;
  var t2 = a.upperBound;
  var d1X = t1.x - t2.x;
  var d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var d2X = t1.x - t2.x;
  var d2Y = t1.y - t2.y;
  if(d1X > 0 || d1Y > 0) {
    return false
  }
  if(d2X > 0 || d2Y > 0) {
    return false
  }
  return true
};
b2Collision.b2_nullFeature = 255;
b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
b2Collision.s_edgeAO = new Array(1);
b2Collision.s_edgeBO = new Array(1);
b2Collision.s_localTangent = new b2Vec2;
b2Collision.s_localNormal = new b2Vec2;
b2Collision.s_planePoint = new b2Vec2;
b2Collision.s_normal = new b2Vec2;
b2Collision.s_tangent = new b2Vec2;
b2Collision.s_tangent2 = new b2Vec2;
b2Collision.s_v11 = new b2Vec2;
b2Collision.s_v12 = new b2Vec2;
b2Collision.b2CollidePolyTempVec = new b2Vec2;var b2PolyAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2PolyAndCircleContact.prototype, b2Contact.prototype);
b2PolyAndCircleContact.prototype._super = b2Contact.prototype;
b2PolyAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2PolyAndCircleContact.prototype.__varz = function() {
};
b2PolyAndCircleContact.Create = function(allocator) {
  return new b2PolyAndCircleContact
};
b2PolyAndCircleContact.Destroy = function(contact, allocator) {
};
b2PolyAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.m_body;
  var bB = this.m_fixtureB.m_body;
  b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2PolyAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB]);
  b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
  b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape)
};var b2ContactPoint = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactPoint.prototype.__constructor = function() {
};
b2ContactPoint.prototype.__varz = function() {
  this.position = new b2Vec2;
  this.velocity = new b2Vec2;
  this.normal = new b2Vec2;
  this.id = new b2ContactID
};
b2ContactPoint.prototype.shape1 = null;
b2ContactPoint.prototype.shape2 = null;
b2ContactPoint.prototype.position = new b2Vec2;
b2ContactPoint.prototype.velocity = new b2Vec2;
b2ContactPoint.prototype.normal = new b2Vec2;
b2ContactPoint.prototype.separation = null;
b2ContactPoint.prototype.friction = null;
b2ContactPoint.prototype.restitution = null;
b2ContactPoint.prototype.id = new b2ContactID;var b2CircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2CircleContact.prototype, b2Contact.prototype);
b2CircleContact.prototype._super = b2Contact.prototype;
b2CircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2CircleContact.prototype.__varz = function() {
};
b2CircleContact.Create = function(allocator) {
  return new b2CircleContact
};
b2CircleContact.Destroy = function(contact, allocator) {
};
b2CircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2CircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2EdgeAndCircleContact = function() {
  b2Contact.prototype.__varz.call(this);
  this.__varz();
  this.__constructor.apply(this, arguments)
};
extend(b2EdgeAndCircleContact.prototype, b2Contact.prototype);
b2EdgeAndCircleContact.prototype._super = b2Contact.prototype;
b2EdgeAndCircleContact.prototype.__constructor = function() {
  this._super.__constructor.apply(this, arguments)
};
b2EdgeAndCircleContact.prototype.__varz = function() {
};
b2EdgeAndCircleContact.Create = function(allocator) {
  return new b2EdgeAndCircleContact
};
b2EdgeAndCircleContact.Destroy = function(contact, allocator) {
};
b2EdgeAndCircleContact.prototype.Evaluate = function() {
  var bA = this.m_fixtureA.GetBody();
  var bB = this.m_fixtureB.GetBody();
  this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), bA.m_xf, this.m_fixtureB.GetShape(), bB.m_xf)
};
b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function(manifold, edge, xf1, circle, xf2) {
};
b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, fixtureB) {
  this._super.Reset.apply(this, [fixtureA, fixtureB])
};var b2ContactManager = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2ContactManager.prototype.__constructor = function() {
  this.m_world = null;
  this.m_contactCount = 0;
  this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
  this.m_contactListener = b2ContactListener.b2_defaultListener;
  this.m_contactFactory = new b2ContactFactory(this.m_allocator);
  this.m_broadPhase = new b2DynamicTreeBroadPhase
};
b2ContactManager.prototype.__varz = function() {
};
b2ContactManager.s_evalCP = new b2ContactPoint;
b2ContactManager.prototype.AddPair = function(proxyUserDataA, proxyUserDataB) {
  var fixtureA = proxyUserDataA;
  var fixtureB = proxyUserDataB;
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(bodyA == bodyB) {
    return
  }
  var edge = bodyB.GetContactList();
  while(edge) {
    if(edge.other == bodyA) {
      var fA = edge.contact.GetFixtureA();
      var fB = edge.contact.GetFixtureB();
      if(fA == fixtureA && fB == fixtureB) {
        return
      }
      if(fA == fixtureB && fB == fixtureA) {
        return
      }
    }
    edge = edge.next
  }
  if(bodyB.ShouldCollide(bodyA) == false) {
    return
  }
  if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
    return
  }
  var c = this.m_contactFactory.Create(fixtureA, fixtureB);
  fixtureA = c.GetFixtureA();
  fixtureB = c.GetFixtureB();
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this.m_world.m_contactList;
  if(this.m_world.m_contactList != null) {
    this.m_world.m_contactList.m_prev = c
  }
  this.m_world.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  if(bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = c.m_nodeA
  }
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  if(bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = c.m_nodeB
  }
  bodyB.m_contactList = c.m_nodeB;
  ++this.m_world.m_contactCount;
  return
};
b2ContactManager.prototype.FindNewContacts = function() {
  var that = this;
  this.m_broadPhase.UpdatePairs(function(a, b) {
    return that.AddPair(a, b)
  })
};
b2ContactManager.prototype.Destroy = function(c) {
  var fixtureA = c.GetFixtureA();
  var fixtureB = c.GetFixtureB();
  var bodyA = fixtureA.GetBody();
  var bodyB = fixtureB.GetBody();
  if(c.IsTouching()) {
    this.m_contactListener.EndContact(c)
  }
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(c == this.m_world.m_contactList) {
    this.m_world.m_contactList = c.m_next
  }
  if(c.m_nodeA.prev) {
    c.m_nodeA.prev.next = c.m_nodeA.next
  }
  if(c.m_nodeA.next) {
    c.m_nodeA.next.prev = c.m_nodeA.prev
  }
  if(c.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = c.m_nodeA.next
  }
  if(c.m_nodeB.prev) {
    c.m_nodeB.prev.next = c.m_nodeB.next
  }
  if(c.m_nodeB.next) {
    c.m_nodeB.next.prev = c.m_nodeB.prev
  }
  if(c.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = c.m_nodeB.next
  }
  this.m_contactFactory.Destroy(c);
  --this.m_contactCount
};
b2ContactManager.prototype.Collide = function() {
  var c = this.m_world.m_contactList;
  while(c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if(bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
      c = c.GetNext();
      continue
    }
    if(c.m_flags & b2Contact.e_filterFlag) {
      if(bodyB.ShouldCollide(bodyA) == false) {
        var cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      if(this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue
      }
      c.m_flags &= ~b2Contact.e_filterFlag
    }
    var proxyA = fixtureA.m_proxy;
    var proxyB = fixtureB.m_proxy;
    var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
    if(overlap == false) {
      cNuke = c;
      c = cNuke.GetNext();
      this.Destroy(cNuke);
      continue
    }
    c.Update(this.m_contactListener);
    c = c.GetNext()
  }
};
b2ContactManager.prototype.m_world = null;
b2ContactManager.prototype.m_broadPhase = null;
b2ContactManager.prototype.m_contactList = null;
b2ContactManager.prototype.m_contactCount = 0;
b2ContactManager.prototype.m_contactFilter = null;
b2ContactManager.prototype.m_contactListener = null;
b2ContactManager.prototype.m_contactFactory = null;
b2ContactManager.prototype.m_allocator = null;var b2World = function() {
  this.__varz();
  this.__constructor.apply(this, arguments)
};
b2World.prototype.__constructor = function(gravity, doSleep) {
  this.m_destructionListener = null;
  this.m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_bodyCount = 0;
  this.m_contactCount = 0;
  this.m_jointCount = 0;
  this.m_controllerCount = 0;
  b2World.m_warmStarting = true;
  b2World.m_continuousPhysics = true;
  this.m_allowSleep = doSleep;
  this.m_gravity = gravity;
  this.m_inv_dt0 = 0;
  this.m_contactManager.m_world = this;
  var bd = new b2BodyDef;
  this.m_groundBody = this.CreateBody(bd)
};
b2World.prototype.__varz = function() {
  this.s_stack = new Array;
  this.m_contactManager = new b2ContactManager;
  this.m_contactSolver = new b2ContactSolver;
  this.m_island = new b2Island
};
b2World.s_timestep2 = new b2TimeStep;
b2World.s_backupA = new b2Sweep;
b2World.s_backupB = new b2Sweep;
b2World.s_timestep = new b2TimeStep;
b2World.s_queue = new Array;
b2World.e_newFixture = 1;
b2World.e_locked = 2;
b2World.s_xf = new b2Transform;
b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
b2World.m_warmStarting = null;
b2World.m_continuousPhysics = null;
b2World.prototype.Solve = function(step) {
  var b;
  for(var controller = this.m_controllerList;controller;controller = controller.m_next) {
    controller.Step(step)
  }
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag
  }
  for(var c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~b2Contact.e_islandFlag
  }
  for(var j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  var stackSize = this.m_bodyCount;
  var stack = this.s_stack;
  for(var seed = this.m_bodyList;seed;seed = seed.m_next) {
    if(seed.m_flags & b2Body.e_islandFlag) {
      continue
    }
    if(seed.IsAwake() == false || seed.IsActive() == false) {
      continue
    }
    if(seed.GetType() == b2Body.b2_staticBody) {
      continue
    }
    island.Clear();
    var stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(stackCount > 0) {
      b = stack[--stackCount];
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() == b2Body.b2_staticBody) {
        continue
      }
      var other;
      for(var ce = b.m_contactList;ce;ce = ce.next) {
        if(ce.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= b2Contact.e_islandFlag;
        other = ce.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jn = b.m_jointList;jn;jn = jn.next) {
        if(jn.joint.m_islandFlag == true) {
          continue
        }
        other = jn.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        stack[stackCount++] = other;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    island.Solve(step, this.m_gravity, this.m_allowSleep);
    for(var i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      if(b.GetType() == b2Body.b2_staticBody) {
        b.m_flags &= ~b2Body.e_islandFlag
      }
    }
  }
  for(i = 0;i < stack.length;++i) {
    if(!stack[i]) {
      break
    }
    stack[i] = null
  }
  for(b = this.m_bodyList;b;b = b.m_next) {
    if(b.IsAwake() == false || b.IsActive() == false) {
      continue
    }
    if(b.GetType() == b2Body.b2_staticBody) {
      continue
    }
    b.SynchronizeFixtures()
  }
  this.m_contactManager.FindNewContacts()
};
b2World.prototype.SolveTOI = function(step) {
  var b;
  var fA;
  var fB;
  var bA;
  var bB;
  var cEdge;
  var j;
  var island = this.m_island;
  island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
  var queue = b2World.s_queue;
  for(b = this.m_bodyList;b;b = b.m_next) {
    b.m_flags &= ~b2Body.e_islandFlag;
    b.m_sweep.t0 = 0
  }
  var c;
  for(c = this.m_contactList;c;c = c.m_next) {
    c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
  }
  for(j = this.m_jointList;j;j = j.m_next) {
    j.m_islandFlag = false
  }
  for(;;) {
    var minContact = null;
    var minTOI = 1;
    for(c = this.m_contactList;c;c = c.m_next) {
      if(c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue
      }
      var toi = 1;
      if(c.m_flags & b2Contact.e_toiFlag) {
        toi = c.m_toi
      }else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue
        }
        var t0 = bA.m_sweep.t0;
        if(bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0)
        }else {
          if(bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0)
          }
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        b2Settings.b2Assert(0 <= toi && toi <= 1);
        if(toi > 0 && toi < 1) {
          toi = (1 - toi) * t0 + toi;
          if(toi > 1) {
            toi = 1
          }
        }
        c.m_toi = toi;
        c.m_flags |= b2Contact.e_toiFlag
      }
      if(Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi
      }
    }
    if(minContact == null || 1 - 100 * Number.MIN_VALUE < minTOI) {
      break
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    b2World.s_backupA.Set(bA.m_sweep);
    b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= ~b2Contact.e_toiFlag;
    if(minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(b2World.s_backupA);
      bB.m_sweep.Set(b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue
    }
    if(minContact.IsTouching() == false) {
      continue
    }
    var seed = bA;
    if(seed.GetType() != b2Body.b2_dynamicBody) {
      seed = bB
    }
    island.Clear();
    var queueStart = 0;
    var queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= b2Body.e_islandFlag;
    while(queueSize > 0) {
      b = queue[queueStart++];
      --queueSize;
      island.AddBody(b);
      if(b.IsAwake() == false) {
        b.SetAwake(true)
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        if(island.m_contactCount == island.m_contactCapacity) {
          break
        }
        if(cEdge.contact.m_flags & b2Contact.e_islandFlag) {
          continue
        }
        if(cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= b2Contact.e_islandFlag;
        var other = cEdge.other;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
      for(var jEdge = b.m_jointList;jEdge;jEdge = jEdge.next) {
        if(island.m_jointCount == island.m_jointCapacity) {
          continue
        }
        if(jEdge.joint.m_islandFlag == true) {
          continue
        }
        other = jEdge.other;
        if(other.IsActive() == false) {
          continue
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if(other.m_flags & b2Body.e_islandFlag) {
          continue
        }
        if(other.GetType() != b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true)
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= b2Body.e_islandFlag
      }
    }
    var subStep = b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1 - minTOI) * step.dt;
    subStep.inv_dt = 1 / subStep.dt;
    subStep.dtRatio = 0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    var i = 0;
    for(i = 0;i < island.m_bodyCount;++i) {
      b = island.m_bodies[i];
      b.m_flags &= ~b2Body.e_islandFlag;
      if(b.IsAwake() == false) {
        continue
      }
      if(b.GetType() != b2Body.b2_dynamicBody) {
        continue
      }
      b.SynchronizeFixtures();
      for(cEdge = b.m_contactList;cEdge;cEdge = cEdge.next) {
        cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
      }
    }
    for(i = 0;i < island.m_contactCount;++i) {
      c = island.m_contacts[i];
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
    }
    for(i = 0;i < island.m_jointCount;++i) {
      j = island.m_joints[i];
      j.m_islandFlag = false
    }
    this.m_contactManager.FindNewContacts()
  }
};
b2World.prototype.DrawJoint = function(joint) {
  var b1 = joint.GetBodyA();
  var b2 = joint.GetBodyB();
  var xf1 = b1.m_xf;
  var xf2 = b2.m_xf;
  var x1 = xf1.position;
  var x2 = xf2.position;
  var p1 = joint.GetAnchorA();
  var p2 = joint.GetAnchorB();
  var color = b2World.s_jointColor;
  switch(joint.m_type) {
    case b2Joint.e_distanceJoint:
    case b2Joint.e_ropeJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case b2Joint.e_pulleyJoint:
      var pulley = joint;
      var s1 = pulley.GetGroundAnchorA();
      var s2 = pulley.GetGroundAnchorB();
      this.m_debugDraw.DrawSegment(s1, p1, color);
      this.m_debugDraw.DrawSegment(s2, p2, color);
      this.m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case b2Joint.e_mouseJoint:
      this.m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if(b1 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x1, p1, color)
      }
      this.m_debugDraw.DrawSegment(p1, p2, color);
      if(b2 != this.m_groundBody) {
        this.m_debugDraw.DrawSegment(x2, p2, color)
      }
  }
};
b2World.prototype.DrawShape = function(shape, xf, color) {
  switch(shape.m_type) {
    case b2Shape.e_circleShape:
      var circle = shape;
      var center = b2Math.MulX(xf, circle.m_p);
      var radius = circle.m_radius;
      var axis = xf.R.col1;
      this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case b2Shape.e_polygonShape:
      var i = 0;
      var poly = shape;
      var vertexCount = poly.GetVertexCount();
      var localVertices = poly.GetVertices();
      var vertices = new Array(vertexCount);
      for(i = 0;i < vertexCount;++i) {
        vertices[i] = b2Math.MulX(xf, localVertices[i])
      }
      this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case b2Shape.e_edgeShape:
      var edge = shape;
      this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
      break
  }
};
b2World.prototype.SetDestructionListener = function(listener) {
  this.m_destructionListener = listener
};
b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter
};
b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener
};
b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.m_debugDraw = debugDraw
};
b2World.prototype.SetBroadPhase = function(broadPhase) {
  var oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for(var b = this.m_bodyList;b;b = b.m_next) {
    for(var f = b.m_fixtureList;f;f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
    }
  }
};
b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate()
};
b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount()
};
b2World.prototype.CreateBody = function(def) {
  if(this.IsLocked() == true) {
    return null
  }
  var b = new b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if(this.m_bodyList) {
    this.m_bodyList.m_prev = b
  }
  this.m_bodyList = b;
  ++this.m_bodyCount;
  return b
};
b2World.prototype.DestroyBody = function(b) {
  if(this.IsLocked() == true) {
    return
  }
  var jn = b.m_jointList;
  while(jn) {
    var jn0 = jn;
    jn = jn.next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeJoint(jn0.joint)
    }
    this.DestroyJoint(jn0.joint)
  }
  var coe = b.m_controllerList;
  while(coe) {
    var coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b)
  }
  var ce = b.m_contactList;
  while(ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact)
  }
  b.m_contactList = null;
  var f = b.m_fixtureList;
  while(f) {
    var f0 = f;
    f = f.m_next;
    if(this.m_destructionListener) {
      this.m_destructionListener.SayGoodbyeFixture(f0)
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy()
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if(b.m_prev) {
    b.m_prev.m_next = b.m_next
  }
  if(b.m_next) {
    b.m_next.m_prev = b.m_prev
  }
  if(b == this.m_bodyList) {
    this.m_bodyList = b.m_next
  }
  --this.m_bodyCount
};
b2World.prototype.CreateJoint = function(def) {
  var j = b2Joint.Create(def, null);
  j.m_prev = null;
  j.m_next = this.m_jointList;
  if(this.m_jointList) {
    this.m_jointList.m_prev = j
  }
  this.m_jointList = j;
  ++this.m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if(j.m_bodyA.m_jointList) {
    j.m_bodyA.m_jointList.prev = j.m_edgeA
  }
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if(j.m_bodyB.m_jointList) {
    j.m_bodyB.m_jointList.prev = j.m_edgeB
  }
  j.m_bodyB.m_jointList = j.m_edgeB;
  var bodyA = def.bodyA;
  var bodyB = def.bodyB;
  if(def.collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
  return j
};
b2World.prototype.DestroyJoint = function(j) {
  var collideConnected = j.m_collideConnected;
  if(j.m_prev) {
    j.m_prev.m_next = j.m_next
  }
  if(j.m_next) {
    j.m_next.m_prev = j.m_prev
  }
  if(j == this.m_jointList) {
    this.m_jointList = j.m_next
  }
  var bodyA = j.m_bodyA;
  var bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if(j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next
  }
  if(j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev
  }
  if(j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if(j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next
  }
  if(j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev
  }
  if(j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  b2Joint.Destroy(j, null);
  --this.m_jointCount;
  if(collideConnected == false) {
    var edge = bodyB.GetContactList();
    while(edge) {
      if(edge.other == bodyA) {
        edge.contact.FlagForFiltering()
      }
      edge = edge.next
    }
  }
};
b2World.prototype.AddController = function(c) {
  c.m_next = this.m_controllerList;
  c.m_prev = null;
  this.m_controllerList = c;
  c.m_world = this;
  this.m_controllerCount++;
  return c
};
b2World.prototype.RemoveController = function(c) {
  if(c.m_prev) {
    c.m_prev.m_next = c.m_next
  }
  if(c.m_next) {
    c.m_next.m_prev = c.m_prev
  }
  if(this.m_controllerList == c) {
    this.m_controllerList = c.m_next
  }
  this.m_controllerCount--
};
b2World.prototype.CreateController = function(controller) {
  if(controller.m_world != this) {
    throw new Error("Controller can only be a member of one world");
  }
  controller.m_next = this.m_controllerList;
  controller.m_prev = null;
  if(this.m_controllerList) {
    this.m_controllerList.m_prev = controller
  }
  this.m_controllerList = controller;
  ++this.m_controllerCount;
  controller.m_world = this;
  return controller
};
b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if(controller.m_next) {
    controller.m_next.m_prev = controller.m_prev
  }
  if(controller.m_prev) {
    controller.m_prev.m_next = controller.m_next
  }
  if(controller == this.m_controllerList) {
    this.m_controllerList = controller.m_next
  }
  --this.m_controllerCount
};
b2World.prototype.SetWarmStarting = function(flag) {
  b2World.m_warmStarting = flag
};
b2World.prototype.SetContinuousPhysics = function(flag) {
  b2World.m_continuousPhysics = flag
};
b2World.prototype.GetBodyCount = function() {
  return this.m_bodyCount
};
b2World.prototype.GetJointCount = function() {
  return this.m_jointCount
};
b2World.prototype.GetContactCount = function() {
  return this.m_contactCount
};
b2World.prototype.SetGravity = function(gravity) {
  this.m_gravity = gravity
};
b2World.prototype.GetGravity = function() {
  return this.m_gravity
};
b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody
};
b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if(this.m_flags & b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~b2World.e_newFixture
  }
  this.m_flags |= b2World.e_locked;
  var step = b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if(dt > 0) {
    step.inv_dt = 1 / dt
  }else {
    step.inv_dt = 0
  }
  step.dtRatio = this.m_inv_dt0 * dt;
  step.warmStarting = b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if(step.dt > 0) {
    this.Solve(step)
  }
  if(b2World.m_continuousPhysics && step.dt > 0) {
    this.SolveTOI(step)
  }
  if(step.dt > 0) {
    this.m_inv_dt0 = step.inv_dt
  }
  this.m_flags &= ~b2World.e_locked
};
b2World.prototype.ClearForces = function() {
  for(var body = this.m_bodyList;body;body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0
  }
};
b2World.prototype.DrawDebugData = function() {
  if(this.m_debugDraw == null) {
    return
  }
  this.m_debugDraw.Clear();
  var flags = this.m_debugDraw.GetFlags();
  var i = 0;
  var b;
  var f;
  var s;
  var j;
  var bp;
  var invQ = new b2Vec2;
  var x1 = new b2Vec2;
  var x2 = new b2Vec2;
  var xf;
  var b1 = new b2AABB;
  var b2 = new b2AABB;
  var vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
  var color = new b2Color(0, 0, 0);
  if(flags & b2DebugDraw.e_shapeBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b.m_xf;
      for(f = b.GetFixtureList();f;f = f.m_next) {
        s = f.GetShape();
        if(b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color)
        }else {
          if(b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color)
          }else {
            if(b.GetType() == b2Body.b2_kinematicBody) {
              color.Set(0.5, 0.5, 0.9);
              this.DrawShape(s, xf, color)
            }else {
              if(b.IsAwake() == false) {
                color.Set(0.6, 0.6, 0.6);
                this.DrawShape(s, xf, color)
              }else {
                color.Set(0.9, 0.7, 0.7);
                this.DrawShape(s, xf, color)
              }
            }
          }
        }
      }
    }
  }
  if(flags & b2DebugDraw.e_jointBit) {
    for(j = this.m_jointList;j;j = j.m_next) {
      this.DrawJoint(j)
    }
  }
  if(flags & b2DebugDraw.e_controllerBit) {
    for(var c = this.m_controllerList;c;c = c.m_next) {
      c.Draw(this.m_debugDraw)
    }
  }
  if(flags & b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for(var contact = this.m_contactManager.m_contactList;contact;contact = contact.GetNext()) {
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var cA = fixtureA.GetAABB().GetCenter();
      var cB = fixtureB.GetAABB().GetCenter();
      this.m_debugDraw.DrawSegment(cA, cB, color)
    }
  }
  if(flags & b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new b2Vec2, new b2Vec2, new b2Vec2, new b2Vec2];
    for(b = this.m_bodyList;b;b = b.GetNext()) {
      if(b.IsActive() == false) {
        continue
      }
      for(f = b.GetFixtureList();f;f = f.GetNext()) {
        var aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.m_debugDraw.DrawPolygon(vs, 4, color)
      }
    }
  }
  if(flags & b2DebugDraw.e_centerOfMassBit) {
    for(b = this.m_bodyList;b;b = b.m_next) {
      xf = b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.m_debugDraw.DrawTransform(xf)
    }
  }
};
b2World.prototype.QueryAABB = function(callback, aabb) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    return callback(broadPhase.GetUserData(proxy))
  }
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryShape = function(callback, shape, transform) {
  if(transform == null) {
    transform = new b2Transform;
    transform.SetIdentity()
  }
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.QueryPoint = function(callback, p) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  function WorldQueryWrapper(proxy) {
    var fixture = broadPhase.GetUserData(proxy);
    if(fixture.TestPoint(p)) {
      return callback(fixture)
    }
    return true
  }
  var aabb = new b2AABB;
  aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb)
};
b2World.prototype.RayCast = function(callback, point1, point2) {
  var broadPhase = this.m_contactManager.m_broadPhase;
  var output = new b2RayCastOutput;
  function RayCastWrapper(input, proxy) {
    var userData = broadPhase.GetUserData(proxy);
    var fixture = userData;
    var hit = fixture.RayCast(output, input);
    if(hit) {
      var fraction = output.fraction;
      var point = new b2Vec2((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
      return callback(fixture, point, output.normal, fraction)
    }
    return input.maxFraction
  }
  var input = new b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input)
};
b2World.prototype.RayCastOne = function(point1, point2) {
  var result;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction
  }
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result
};
b2World.prototype.RayCastAll = function(point1, point2) {
  var result = new Array;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1
  }
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result
};
b2World.prototype.GetBodyList = function() {
  return this.m_bodyList
};
b2World.prototype.GetJointList = function() {
  return this.m_jointList
};
b2World.prototype.GetContactList = function() {
  return this.m_contactList
};
b2World.prototype.IsLocked = function() {
  return(this.m_flags & b2World.e_locked) > 0
};
b2World.prototype.s_stack = new Array;
b2World.prototype.m_flags = 0;
b2World.prototype.m_contactManager = new b2ContactManager;
b2World.prototype.m_contactSolver = new b2ContactSolver;
b2World.prototype.m_island = new b2Island;
b2World.prototype.m_bodyList = null;
b2World.prototype.m_jointList = null;
b2World.prototype.m_contactList = null;
b2World.prototype.m_bodyCount = 0;
b2World.prototype.m_contactCount = 0;
b2World.prototype.m_jointCount = 0;
b2World.prototype.m_controllerList = null;
b2World.prototype.m_controllerCount = 0;
b2World.prototype.m_gravity = null;
b2World.prototype.m_allowSleep = null;
b2World.prototype.m_groundBody = null;
b2World.prototype.m_destructionListener = null;
b2World.prototype.m_debugDraw = null;
b2World.prototype.m_inv_dt0 = null;if(typeof exports !== "undefined") {
  exports.b2BoundValues = b2BoundValues;
  exports.b2Math = b2Math;
  exports.b2DistanceOutput = b2DistanceOutput;
  exports.b2Mat33 = b2Mat33;
  exports.b2ContactPoint = b2ContactPoint;
  exports.b2PairManager = b2PairManager;
  exports.b2PositionSolverManifold = b2PositionSolverManifold;
  exports.b2OBB = b2OBB;
  exports.b2CircleContact = b2CircleContact;
  exports.b2PulleyJoint = b2PulleyJoint;
  exports.b2Pair = b2Pair;
  exports.b2TimeStep = b2TimeStep;
  exports.b2FixtureDef = b2FixtureDef;
  exports.b2World = b2World;
  exports.b2PrismaticJoint = b2PrismaticJoint;
  exports.b2Controller = b2Controller;
  exports.b2ContactID = b2ContactID;
  exports.b2RevoluteJoint = b2RevoluteJoint;
  exports.b2JointDef = b2JointDef;
  exports.b2Transform = b2Transform;
  exports.b2GravityController = b2GravityController;
  exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
  exports.b2EdgeShape = b2EdgeShape;
  exports.b2BuoyancyController = b2BuoyancyController;
  exports.b2LineJointDef = b2LineJointDef;
  exports.b2Contact = b2Contact;
  exports.b2DistanceJoint = b2DistanceJoint;
  exports.b2Body = b2Body;
  exports.b2DestructionListener = b2DestructionListener;
  exports.b2PulleyJointDef = b2PulleyJointDef;
  exports.b2ContactEdge = b2ContactEdge;
  exports.b2ContactConstraint = b2ContactConstraint;
  exports.b2ContactImpulse = b2ContactImpulse;
  exports.b2DistanceJointDef = b2DistanceJointDef;
  exports.b2RopeJoint = b2RopeJoint;
  exports.b2RopeJointDef = b2RopeJointDef;
  exports.b2ContactResult = b2ContactResult;
  exports.b2EdgeChainDef = b2EdgeChainDef;
  exports.b2Vec2 = b2Vec2;
  exports.b2Vec3 = b2Vec3;
  exports.b2DistanceProxy = b2DistanceProxy;
  exports.b2FrictionJointDef = b2FrictionJointDef;
  exports.b2PolygonContact = b2PolygonContact;
  exports.b2TensorDampingController = b2TensorDampingController;
  exports.b2ContactFactory = b2ContactFactory;
  exports.b2WeldJointDef = b2WeldJointDef;
  exports.b2ConstantAccelController = b2ConstantAccelController;
  exports.b2GearJointDef = b2GearJointDef;
  exports.ClipVertex = ClipVertex;
  exports.b2SeparationFunction = b2SeparationFunction;
  exports.b2ManifoldPoint = b2ManifoldPoint;
  exports.b2Color = b2Color;
  exports.b2PolygonShape = b2PolygonShape;
  exports.b2DynamicTreePair = b2DynamicTreePair;
  exports.b2ContactConstraintPoint = b2ContactConstraintPoint;
  exports.b2FrictionJoint = b2FrictionJoint;
  exports.b2ContactFilter = b2ContactFilter;
  exports.b2ControllerEdge = b2ControllerEdge;
  exports.b2Distance = b2Distance;
  exports.b2Fixture = b2Fixture;
  exports.b2DynamicTreeNode = b2DynamicTreeNode;
  exports.b2MouseJoint = b2MouseJoint;
  exports.b2DistanceInput = b2DistanceInput;
  exports.b2BodyDef = b2BodyDef;
  exports.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;
  exports.b2Settings = b2Settings;
  exports.b2Proxy = b2Proxy;
  exports.b2Point = b2Point;
  exports.b2BroadPhase = b2BroadPhase;
  exports.b2Manifold = b2Manifold;
  exports.b2WorldManifold = b2WorldManifold;
  exports.b2PrismaticJointDef = b2PrismaticJointDef;
  exports.b2RayCastOutput = b2RayCastOutput;
  exports.b2ConstantForceController = b2ConstantForceController;
  exports.b2TimeOfImpact = b2TimeOfImpact;
  exports.b2CircleShape = b2CircleShape;
  exports.b2MassData = b2MassData;
  exports.b2Joint = b2Joint;
  exports.b2GearJoint = b2GearJoint;
  exports.b2DynamicTree = b2DynamicTree;
  exports.b2JointEdge = b2JointEdge;
  exports.b2LineJoint = b2LineJoint;
  exports.b2NullContact = b2NullContact;
  exports.b2ContactListener = b2ContactListener;
  exports.b2RayCastInput = b2RayCastInput;
  exports.b2TOIInput = b2TOIInput;
  exports.Features = Features;
  exports.b2FilterData = b2FilterData;
  exports.b2Island = b2Island;
  exports.b2ContactManager = b2ContactManager;
  exports.b2ContactSolver = b2ContactSolver;
  exports.b2Simplex = b2Simplex;
  exports.b2AABB = b2AABB;
  exports.b2Jacobian = b2Jacobian;
  exports.b2Bound = b2Bound;
  exports.b2RevoluteJointDef = b2RevoluteJointDef;
  exports.b2PolyAndEdgeContact = b2PolyAndEdgeContact;
  exports.b2SimplexVertex = b2SimplexVertex;
  exports.b2WeldJoint = b2WeldJoint;
  exports.b2Collision = b2Collision;
  exports.b2Mat22 = b2Mat22;
  exports.b2SimplexCache = b2SimplexCache;
  exports.b2PolyAndCircleContact = b2PolyAndCircleContact;
  exports.b2MouseJointDef = b2MouseJointDef;
  exports.b2Shape = b2Shape;
  exports.b2Segment = b2Segment;
  exports.b2ContactRegister = b2ContactRegister;
  exports.b2DebugDraw = b2DebugDraw;
  exports.b2Sweep = b2Sweep
}
;

}};
__resources__["/Candy.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var PhyObj = require('PhyObj').PhyObj;


var Candy = PhyObj.extend({
	joints:[],
	createPicture: function(point, scale) {
        scale = scale || 1;
        var sprite = cocos.nodes.Sprite.create({file: '/resources/candy.png'});
        sprite.set('position', point);
        sprite.set('scale', scale);
        this.set('picture', sprite);
    },
    createPhyBody: function(world, px, py, programe) {
    	this.world = world;
    	var bodyDef = new box2d.b2BodyDef;
    	bodyDef.type = box2d.b2Body.b2_dynamicBody;
        bodyDef.position.x =  px;
        bodyDef.position.y =  py;
		width = 32;//TODO
		
		var fixDef = new box2d.b2FixtureDef;
        fixDef.density = 100.0;
        fixDef.friction = 0.5;
        fixDef.restitution = 0;
        fixDef.shape = new box2d.b2CircleShape(width/programe.m_phy_scale);
        this.createPicture(new geo.Point(bodyDef.position.x * programe.m_phy_scale, bodyDef.position.y * programe.m_phy_scale), 1);
        
        var bdy = world.CreateBody(bodyDef);
        bdy.sprite = this.get('picture');
        programe.get('bodies').push(bdy);
        bdy.CreateFixture(fixDef);
        this.phy_obj = bdy;
        
        programe.addChild(bdy.sprite);
    },
    createJoint: function(nail_body, max_len) {
    	var jointdef = new box2d.b2RopeJointDef();
    	jointdef.bodyA = this.phy_obj;
    	jointdef.bodyB = nail_body;
    	jointdef.localAnchorA = new box2d.b2Vec2(0, 0);
    	jointdef.localAnchorB = new box2d.b2Vec2(0, 0);
    	jointdef.maxLength = max_len;
    	
//    	var jointdef = new box2d.b2DistanceJointDef();
//    	jointdef.Initialize(this.phy_obj, nail_body,
//    			this.phy_obj.GetPosition(), nail_body.GetPosition());
    	
    	jointdef.collideConnected = true;
        var joint = this.world.CreateJoint(jointdef);
        this.joints.push(joint);
        return joint;
    },
    init: function() {
    	Candy.superclass.init.call(this);
    	this.obj_category = PhyObj.TYPE_CANDY;
    }
});

exports.Candy = Candy;

}};
__resources__["/cutor.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var cocos = require('cocos2d');
var geom = require('geometry');
//
var Cutor = cocos.nodes.Node.extend({
    sprite:null,
    
    init: function(pic) {
		Cutor.superclass.init.call(this);

		if (undefined == pic) {
			pic = '/resources/cutor.png'
		}
		var sprite = cocos.nodes.Sprite.create({
	    	file: pic	    	
			,rect: new geom.Rect(0, 0, 500, 10)
		});
		sprite.set('anchorPoint', new geom.Point(0, 0));
		this.addChild({child: sprite});
		this.set('contentSize', sprite.get('contentSize'));	
		this.set('sprite',sprite);
		
	},
    show: function(points){
    	var midPos={};
    	midPos.x = points[0][0] + 500/2;//(points[0][0]+points[1][0])/2 +500/2;
    	midPos.y = points[0][1] + 10/2;//(points[1][0]+points[1][1])/2 +100/2;
    	
    	var x1=points[0][0],x2=points[1][0],y1=points[0][1],y2=points[1][1];
    	
    	var totalWidth = Math.sqrt( Math.abs(x1-x2)*Math.abs(x1-x2) + Math.abs(y1-y2)*Math.abs(y1-y2) );
    	var rotate = 0;
    	if(y1!=y2){
    		rotate = Math.atan2( (y2-y1),(x2-x1) ) * 360 / 2 /Math.PI;
    	}
    	var scale = totalWidth/500;
    	
    	//console.log("scale:"+scale+",rotate:"+rotate+"midpos:"+midPos.x+";"+midPos.y);
    	
    	this.get('sprite').set('position',midPos);
    	this.get('sprite').set('scale',scale);
    	this.get('sprite').set('rotation',rotate);
    	this.set('visible',true);
    },
    hide: function(){
    	this.get('sprite').set('scale',1);
    	this.get('sprite').set('rotation',0);
    	this.set('visible',false);
    }
});

exports.Cutor = Cutor;

}};
__resources__["/Frog.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var Tool = require('Tool').Tool;

var Frog = Tool.extend({ 

    createBox: function() {
        var frogBox = this.get('picture').get('boundingBox');
        var x = frogBox.origin.x;
        var y = frogBox.origin.y;
        var w = frogBox.size.width;
        var h = frogBox.size.height;
        x = x + (w - w/4)/2;
        w = w/4;
        h = h/4;
        return new geo.Rect(x, y, w, h);
    },

    createEat: function(x, y, program) {
        this.filepath = '/resources/pet2.png';
        this.createPicture(new geo.Point(x * program.m_phy_scale, y * program.m_phy_scale));
        program.addChild(this.get('picture'));
    },

    init: function() {
        Frog.superclass.init.call(this);
        this.filepath = '/resources/pet1.png';
    }    
});

exports.Frog = Frog;

}};
__resources__["/main.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var VPoint = require('VPoint').VPoint;
var VStick = require('VStick').VStick;
var VRope = require('VRope').VRope;

var Candy = require('Candy').Candy;
var PinNail = require('PinNail').PinNail;
var Frog = require('Frog').Frog;
var Star = require('Star').Star;
var Sock = require('Sock').Sock;

var PointContainer = require('pointContainer').PointContainer;
var Cutor = require('cutor').Cutor;


// Create a new layer
var Cuttherope = cocos.nodes.Layer.extend({
	testcount: 0,
	world: null,
    bodies: null,
    selectedBody: null,
    mouseJoint: null,
    m_phy_scale: 30,
    ropeSpriteSheet: null,

    //frog and action, by anho    
    doRunUpdate: true,
    frog: null,
    frogEat: null,

    //stars and action, by anho
    stars: [],
    getStars: 0,

    //socks and action;
    socks: [], 
    
    candy:null,
    nails:[],
    vRopes:[],
    
    //====================================
    cutor:null,
    pointContainer:null,
    //====================================
    
    init: function() {
        // You must always call the super class version of init
        Cuttherope.superclass.init.call(this);
        
        this.set('isMouseEnabled', true);
        this.set('bodies', []);
        // Get size of canvas
//        var s = cocos.Director.get('sharedDirector').get('winSize');
      //bg
		var bgsprite = cocos.nodes.Sprite.create({file: '/resources/bg.png'});
		bgsprite.set('position', new geo.Point(320,480));
		this.addChild({child:bgsprite});
        
        
        this.createWorld();
        this.scheduleUpdate();
        
        this.set('pointContainer',new PointContainer());
	
		var cutor = Cutor.create();
		this.set('cutor',cutor);
		this.addChild({child:cutor});
		cutor.hide();
		
//		 var sssss = cocos.nodes.Sprite.create({file: '/resources/cutor.png'});
//		 sssss.set('position', new geo.Point(235,650));
//		 sssss.set('scale', 0.5);
//		 sssss.set('rotation',Math.atan2( 500,170 ) * 360 / 2 /Math.PI);
//	        this.addChild({child:sssss});
		
    },
    update: function(dt) {
        if (!this.doRunUpdate) {
            return;
        }
        
        var world = this.get('world');

        world.Step(dt, 10, 10);
//        world.DrawDebugData();
        world.ClearForces();

        var bodies = this.get('bodies');
        for (var i = 0, len = bodies.length; i < len; i++) {
            var body = bodies[i],
                pos = body.GetPosition(),
                angle = geo.radiansToDegrees(body.GetAngle());
            body.sprite.set('position', new geo.Point(pos.x * 30, pos.y * 30));
            body.sprite.set('rotation', angle);
        }
        
//    	if (this.testcount>40){
//    		if(this.candy.joints[0]){
//    			world.DestroyJoint(this.candy.joints[0]);
//    		}
//    	}
        
//        var len = this.vRopes.length;
//        for(k=0;k<len;k++) {
//        	this.vRopes[k].update(dt);
//    	}
//        for(k=0;k<len;k++) {
//        	this.vRopes[k].updateSprites();
//    	}
        var k;
        var len = this.nails.length;
        for(k=0;k<len;k++) {
        	this.nails[k].showline();
    	}
        
        var candyBox = this.candy.phy_obj.sprite.get('boundingBox');
        var frogBox = this.frog.createBox();
        //frog get candy
        if (geo.rectOverlapsRect(candyBox, frogBox)) {
            //alert('win!!!');
            for (var i = 0; i < this.nails.length; i++) {
                this.nails[i].cut_force();
            }
            var k;
            var len = this.nails.length;
            for(k=0;k<len;k++) {
        	    this.nails[k].showline();
    	    }

            this.removeChild({child: this.candy.phy_obj.sprite});
            this.frog.get('picture').set('visible', false);
            this.frogEat.get('picture').set('visible', true);
            var t = setTimeout(winGame, 500);
            this.doRunUpdate = false;
        }

        //get star
        for (var i = 0; i < this.stars.length; i++) {
            if (this.stars[i].eaten) {
                continue;
            }
            var sprite = this.stars[i].get('picture');
            var starBox = sprite.get('boundingBox');
            if (geo.rectOverlapsRect(candyBox, starBox)) {
                this.removeChild({child:sprite});
                this.stars[i].set('eaten', true);
                this.getStars++;
            }
        }

        //socks jump
        for (var i = 0; i < 1; i++) {
            var sockBox = this.socks[i].createBox();
            if (geo.rectOverlapsRect(candyBox, sockBox)) {
                var jumpTo = this.socks[i].get('jumpTo');
                this.candy.phy_obj.SetPosition(this.socks[jumpTo].getJumpPosition(this.m_phy_scale));
                var vel = this.candy.phy_obj.GetLinearVelocity();
                this.candy.phy_obj.SetLinearVelocity(this.socks[jumpTo].getJumpVelocity(vel));
                for (var j = 0; j < this.nails.length; j++) {
                    this.nails[j].cut_force();
                }
            }
        }
    },
    createWorld: function() {
    	var world = new box2d.b2World(
                new box2d.b2Vec2(0, -10),    //gravity
                true                  //allow sleep
            );
            this.set('world', world);
            var fixDef = new box2d.b2FixtureDef;
            fixDef.density = 1.0;
            fixDef.friction = 0.5;
            fixDef.restitution = 0.2;
            var bodyDef = new box2d.b2BodyDef;
            //create ground
            bodyDef.type = box2d.b2Body.b2_staticBody;
            fixDef.shape = new box2d.b2PolygonShape;
            fixDef.shape.SetAsBox(20, 2);
//            bodyDef.position.Set(10, 400 / 30 + 2);
//            world.CreateBody(bodyDef).CreateFixture(fixDef);
//            bodyDef.position.Set(10, -2);
//            world.CreateBody(bodyDef).CreateFixture(fixDef);
//            fixDef.shape.SetAsBox(2, 14);
//            bodyDef.position.Set(-2, 13);
//            world.CreateBody(bodyDef).CreateFixture(fixDef);
//            bodyDef.position.Set(22, 13);
//            world.CreateBody(bodyDef).CreateFixture(fixDef);
            
            //create frog            
            this.frog = Frog.create();
            this.frog.createObj(320/this.m_phy_scale, 2, this);
            this.frogEat = Frog.create();
            this.frogEat.createEat(320/this.m_phy_scale, 2, this);
            this.frogEat.get('picture').set('visible', false);
            
            
            //create candy
            this.candy = Candy.create();
            this.candy.createPhyBody(world, 100/this.m_phy_scale,450/this.m_phy_scale, this);

            
            var ropepicpath = "/resources/rope.png";
            //create nails
            //1
            var test_nail = PinNail.create();
            test_nail.createPhyBody(world, 320/this.m_phy_scale,900/this.m_phy_scale, this);
            test_nail.line = Cutor.create(ropepicpath);
            this.addChild({child:test_nail.line});
            this.nails.push(test_nail);
                        
            var cdjoint = this.candy.createJoint(test_nail.phy_obj,400/this.m_phy_scale);
            test_nail.joint = cdjoint;
            
            //2 
            test_nail = PinNail.create();
            test_nail.createPhyBody(world, 150/this.m_phy_scale, 400/this.m_phy_scale, this);
            test_nail.line = Cutor.create(ropepicpath);
            this.addChild({child:test_nail.line});
            this.nails.push(test_nail);

            cdjoint = this.candy.createJoint(test_nail.phy_obj,400/this.m_phy_scale);
            test_nail.joint = cdjoint;
            
            //3
            test_nail = PinNail.create();
            test_nail.createPhyBody(world, 500/this.m_phy_scale,600/this.m_phy_scale, this);
            test_nail.line = Cutor.create(ropepicpath);
            this.addChild({child:test_nail.line});
            this.nails.push(test_nail);
            
            cdjoint = this.candy.createJoint(test_nail.phy_obj,350/this.m_phy_scale);
            test_nail.joint = cdjoint;
//            this.ropeSpriteSheet = cocos.nodes.SpriteBatchNode.create({file:'/resources/ball.png'});
//            this.ropeSpriteSheet.set("position",new geo.Point(5 * 30, 5 * 30));
//            this.addChild({child:this.ropeSpriteSheet});
//            var newRope = VRope.create();
//            newRope.initWithBodys(this.candy.phy_obj,test_nail.phy_obj, this.ropeSpriteSheet);
//            this.vRopes.push(newRope);

            
            //create stars for test
            this.stars[0] = Star.create();
            this.stars[0].createObj(320/this.m_phy_scale, 300/this.m_phy_scale, this);
            this.stars[1] = Star.create();
            this.stars[1].createObj(320/this.m_phy_scale, 450/this.m_phy_scale, this);
            this.stars[2] = Star.create();
            this.stars[2].createObj(500/this.m_phy_scale, 300/this.m_phy_scale, this);

            //create socks
            this.socks[0] = Sock.create();
            this.socks[0].createObj(500/this.m_phy_scale, 150/this.m_phy_scale, this);
            this.socks[0].set('jumpTo', 1);
            this.socks[1] = Sock.create();
            this.socks[1].createObj(320/this.m_phy_scale, 700/this.m_phy_scale, this);
            this.socks[1].revolve();            
            this.socks[1].set('jumpTo', 0);
            
        
        //setup debug draw
//        var debugDraw = new box2d.b2DebugDraw();
//            debugDraw.SetSprite(document.getElementById('debug-canvas').getContext("2d"));
//            debugDraw.SetDrawScale(30.0);
//            debugDraw.SetFillAlpha(0.5);
//            debugDraw.SetLineThickness(1.0);
//            debugDraw.SetFlags(box2d.b2DebugDraw.e_shapeBit | box2d.b2DebugDraw.e_jointBit);
//            world.SetDebugDraw(debugDraw);
            /**/
    }, 
    getBodyAtPoint: function (point) {
        point = new geo.Point(point.x /30, point.y /30);
        var world = this.get('world');
        var mousePVec = new box2d.b2Vec2(point.x, point.y);
        var aabb = new box2d.b2AABB();
        aabb.lowerBound.Set(point.x - 0.001, point.y - 0.001);
        aabb.upperBound.Set(point.x + 0.001, point.y + 0.001);


        var self = this;
        function getBodyCB(fixture) {
            if(fixture.GetBody().GetType() != box2d.b2Body.b2_staticBody) {
                if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    self.set('selectedBody', fixture.GetBody());
                    return false;
                }
            }
            return true;
        }


        // Query the world for overlapping shapes.

        this.set('selectedBody', null);
        world.QueryAABB(getBodyCB, aabb);
        return this.get('selectedBody');
    },

    mouseDown: function(evt) {
    	this.candy.joints=[];
        //
        this.get('pointContainer').pushStart(evt.locationInCanvas.x,evt.locationInCanvas.y);
    },

    mouseDragged: function(evt) {
        //
        this.get('pointContainer').pushStop(evt.locationInCanvas.x,evt.locationInCanvas.y);
        this.showCutor(this.get('pointContainer').getPoints());
    },

    mouseUp: function(evt) {
        
        var currentCutor = this.get('cutor');
        if(currentCutor){
        	this.get('cutor').hide();
        }
        
        var k;
        var len = this.nails.length;
        for(k=0;k<len;k++) {
        	var pts =this.get('pointContainer').getPoints();
        	if (pts.length ==2) {
        		this.nails[k].cut(pts[0][0],pts[0][1], pts[1][0],pts[1][1]);
        	}
    	}
    },
    showCutor: function(points){
		if(points.length!=2)return;
		
		var cutorStart = this.get('cutor');
		cutorStart.show(points);				
		//setTimeout(function(){cutorStart.hide();},500);		
	},
	cut_by_id: function(id) {
		this.nails[id-1].cut_force();
	},
	gameover: function() {
		this.cleanup();
	}
});

var CuttheropeMainStage = null;

exports.main = function() {
    // Initialise application

    // Get director
    var director = cocos.Director.get('sharedDirector');

    // Attach director to our <div> element
    director.attachInView(document.getElementById('cuttherope_app'));
    director.set('displayFPS', false);

    // Create a scene
    var scene = cocos.nodes.Scene.create();
    CuttheropeMainStage = Cuttherope.create();

    // Add our layer to the scene
    scene.addChild({child: CuttheropeMainStage});

    // Run the scene
    director.runWithScene(scene);
    global_stage = CuttheropeMainStage;
};

function winGame() {
    CuttheropeMainStage.frogEat.get('picture').set('visible', false);
    CuttheropeMainStage.frog.get('picture').set('visible', true);
    CuttheropeMainStage.gameover();
    showFinishWindow(CuttheropeMainStage.getStars);
}


//============================finish window=============================//
var FinishForm = function(starNum){
    var html = document.createElement("div");
    html.id="finish_form";
    html.style.display="none";
    html.style.zOrder=100000;
    html.style.position="absolute";
    html.style.left="30px";
    html.style.top="70px";
    html.style.width="640px";
    html.style.height="960px";
    html.style.backgroundImage="url('resources/score_bg.png')";
    
    var ok = document.createElement("div");
    ok.id="finish_form_ok";
    ok.style.width="240px";
    ok.style.height="120px";    
    ok.style.position="absolute";
    ok.style.left= "230px";
    ok.style.zIndex=1000;
    ok.style.top="630px";
    ok.style.backgroundImage="url('resources/ok.png')";
    document.body.appendChild(ok);

    var scoreValue=0;
    for(var index =0;index<starNum ;index++){
        var star = document.createElement("div");
        star.id="finish_form_star";
        star.style.width="75px";
        star.style.height="75px";    
        star.style.position="absolute";
        star.style.left= (index*100+170)+"px";
        star.style.top="720px";
        star.style.backgroundImage="url('resources/bstar.png')";
        
        scoreValue+=100;
        
        star.style.backgroundRepeat="no-repeat";
        html.appendChild(star);
    }
    
    var score = document.createElement("div");
    score.id="finish_form_score";
    score.innerHTML=":"+scoreValue;
    score.style.width="240px";
    score.style.height="120px";    
    score.style.position="absolute";
    score.style.left= "220px";
    score.style.fontSize = "50px";
    score.style.zIndex=1000;
    score.style.top="870px";
    //score.style.backgroundImage="url('resources/ok.png')";
    document.body.appendChild(score);
    
    document.body.appendChild(html);
}
FinishForm.prototype.show=function(){
    document.getElementById("finish_form").style.display="";
}
FinishForm.prototype.hide=function(){
    document.getElementById("finish_form").style.display="none";
    //document.removeChild(document.getElementById("finish_form"));
}

var finishForm = null;
function showFinishWindow(starNum){
    finishForm =new FinishForm(starNum);
    finishForm.show();
}
function hideFinishWindow(){
    finishForm.hide();    
}

}};
__resources__["/PhyObj.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');


var PhyObj = cocos.nodes.Node.extend({
	TYPE_CANDY : "candy",
	TYPE_PINNAIL : "pinnail",
    TYPE_FROG : "frog",
	phy_obj:null,
	picture:null,
	posx:0,
	posy:0,
	obj_category:"",
	world:null,
    init: function() {
    	PhyObj.superclass.init.call(this);
    }
});

exports.PhyObj = PhyObj;

}};
__resources__["/PinNail.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');
var PhyObj = require('PhyObj').PhyObj;

var PinNail = PhyObj.extend({
	line:null,
	stage:null,
	cutflag: false,
	joint:null,
	createPicture: function(point, scale) {
        scale = scale || 1;
        var sprite = cocos.nodes.Sprite.create({file: '/resources/nail.png'});
        sprite.set('position', point);
        sprite.set('scale', scale);
        this.set('picture', sprite);
    },
    createPhyBody: function(world, px, py, programe) {
    	this.stage = programe;
    	var bodyDef = new box2d.b2BodyDef;
    	bodyDef.type = box2d.b2Body.b2_staticBody;
        bodyDef.position.x =  px;
        bodyDef.position.y =  py;
		width = 42;//TODO
		
		var fixDef = new box2d.b2FixtureDef;
        fixDef.density = 1.0;
        fixDef.friction = 0.5;
        fixDef.restitution = 0.2;
        fixDef.shape = new box2d.b2CircleShape(width/programe.m_phy_scale);
        sprite = this.createPicture(
        		new geo.Point(bodyDef.position.x * programe.m_phy_scale,
        				bodyDef.position.y * programe.m_phy_scale),
        				1);
        
        var bdy = world.CreateBody(bodyDef);
        bdy.sprite = this.get('picture');
        programe.get('bodies').push(bdy);
        bdy.CreateFixture(fixDef);
        this.phy_obj = bdy;
        
        programe.addChild(bdy.sprite);
    },
    showline: function (){
    	if (null != this.line){
    		
    		if (this.cutflag) {
    			this.stage.removeChild({child:this.line});
    			this.line=null;
    			
    			if (null != this.joint) {
    				this.stage.world.DestroyJoint(this.joint);
    			}
    			return;
    		}
    		
    		var poscandy = this.stage.candy.phy_obj.GetPosition();
    		var posself = this.phy_obj.GetPosition();
    		this.line.show([[posself.x*this.stage.m_phy_scale, posself.y*this.stage.m_phy_scale],
    		     [poscandy.x*this.stage.m_phy_scale, poscandy.y*this.stage.m_phy_scale]]);
    	}
    },
    cut: function (px1, py1, px2, py2) {
    	if (null != this.line){
    		var poscandy = this.stage.candy.phy_obj.GetPosition();
    		var posself = this.phy_obj.GetPosition();
    		var cross = this.crossline(new box2d.b2Vec2(px1/this.stage.m_phy_scale, py1/this.stage.m_phy_scale), 
    				new box2d.b2Vec2(px2/this.stage.m_phy_scale, py2/this.stage.m_phy_scale), poscandy, posself);
    		if (cross) {
    			this.cutflag = true;
    		}
    	}
    },
    cut_force:function() {
    	if (null != this.line){
			this.cutflag = true;
    	}
    },
    mul3pos: function(p1, p2, p0) {
    	return (p1.x-p0.x)*(p2.y-p0.y) - (p2.x-p0.x)*(p1.y-p0.y);
    },
    crossline: function(pa1,pa2,pb1,pb2) {
    	return (Math.max(pa1.x, pa2.x) >=Math.min(pb1.x,pb2.x)) &&
    	(Math.max(pb1.x, pb2.x) >=Math.min(pa1.x,pa2.x)) &&
    	(Math.max(pa1.y, pa2.y) >=Math.min(pb1.y,pb2.y)) &&
    	(Math.max(pb1.y, pb2.y) >=Math.min(pa1.y,pa2.y)) &&
    	(this.mul3pos(pb1,pa2,pa1)*this.mul3pos(pa2,pb2,pa1)>=0) && 
    	(this.mul3pos(pa1,pb2,pb1)*this.mul3pos(pb2,pa2,pb1)>=0);
    },
    init: function() {
    	PinNail.superclass.init.call(this);
    	this.obj_category = PhyObj.TYPE_PINNAIL;
    	this.line = null;
    }
});

exports.PinNail = PinNail;

}};
__resources__["/pointContainer.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
var cocos = require('cocos2d');
var geom = require('geometry');
function PointContainer(){
    this.startX=0;
    this.startY=0;
    this.stopX=0;
    this.stopY=0;
    this.startSetted=false;
    this.setFinished=false;
}

PointContainer.prototype.pushStart=function(x,y){
    if(this.setFinished){
		this.stopX=0;
		this.stopY=0;
		this.setFinished=false;
    }
    this.startX=x;
    this.startY=y;
    this.startSetted=true;
}
PointContainer.prototype.pushStop=function(x,y){
    if(this.startSetted && !(x==this.startX && this.startY==y) ){
		this.stopX=x;
		this.stopY=y;

        this.setFinished=true;
    }    
}
PointContainer.prototype.getPoints=function(){
    if(this.setFinished){
		return [[this.startX,this.startY],[this.stopX,this.stopY]];
    }
    return [];
}
exports.PointContainer = PointContainer;


}};
__resources__["/resources/backrope.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAICAYAAADwdn+XAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAERJREFUeNpi/P//PwMlgKW1pR2rCTW1VWC6pbkNrxwTuZphgImQAlwAZjgTLs2EnA4PA2I045NjIsZmfHKMlEYjQIABAJimJpw2VY1PAAAAAElFTkSuQmCC")};
__resources__["/resources/ball.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bg.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/bstar.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/candy.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/crate.jpg"] = {meta: {mimetype: "image/jpeg"}, data: __imageResource("data:image/jpeg;base64,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")};
__resources__["/resources/cutor.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/nail.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/ok.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/pet1.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/pet2.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/pipe.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/reset.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAA+nSURBVHja1FttcFvVmX7O1dWV5Fj+kCVHsSTbxE4IIU6cxB+EmmFbCGkXCGwLFNilu54lTNPpzAK7ZcqPZnYSZiDsLDBkdnYY6NKhA4WSDWzpbgjQJiEJtuSPJERxFH+hWP6QbUmxHMv6uvec/ZEr51q+tqTEJumdOWNd6fqc8zznOe953/OeSxhjWMqrs71dD6ACgAWACYBV/skCQCt/TgIYlz/7AYTk+wub6upiS9k/shQEdLa1FQOoBVCtFYSVppKSSoPBYBEEwSTodFYA0Gq1FkIIDwCMMTGZTI4DQCIe9ycSiVA0Gh0PBYPeZCLRD6AXwKlN9fUXb2gCOtraagDU5+fnry+1WmuXLVtWLQiCbdZDcnvp7RJCUh9mfZ9IJIYikUjvmN9/ampq6msAbZvr68/cMAR0tLVxABoB1Nvs9juLTaY6nU5XngJ7rfUTQmZIicfjAxdDofahwcGjANoAODfX19PrRkCHy7WZELLdXl6+yVRScjvP86aMoDO1l6YANTJEUQyFgsGvBgcGOhljf9jc0NDxrRLQ7nKZATSaSkoedDgc92kFwTov8GudYiqEpIhIJhJ+n8/3x1Aw+DEAZ11DQ2DJCWh3uTZzGs2D1dXVWwsKCxsBgFG6IOirpYBkIINwHABgMhx29vb2fk4l6eO6HNWQEwFtTufdxoKC7VVVVQ9rBcE6Azy9Dsaw2GsLUVODfE84DslEwt/X1/fhpcnJP9Q3Nn6x6AS0OZ3bLKWlj5ZXVDzGcZyOUZo98KudBmryn4cIwnGglMYHLlz43fjY2Pv1jY2HFo2AttbWvy6z2X5SZrf/iAA8Y2w2KDXgi+1fpMs//TtCQAgBA8ThwcH/Hh4aeqf+ttv+L1O1XKYHXK2t26xlZU/YHI5HsgKf/vtiXWn1snSSZSNMAN7mcDxiLSt7wtXauu2aCHC1tt5dunz543aH4yEwRmaBlxtkSw18ASJYyqFK6xMYI3aH46HS5csfd7W23n1VBJw4dqzOaDRuL6+o+HFq5FOAlcCV999qma8PCiWUV1T82Gg0bj9x7FhdTgQ4W1rMOp3ugapVqx7mOE7HlGu8kv2lmOs5qoEpl1mFm80YA8dxuqpVqx7W6XQPOFtazFkTwBhrqF69eqsgL3Vq4HG9waeDViOBUgiCYK1evXorY6whKwKOHT1aZ7ZYflhUVNQwC/xSW/lFIEFlIMEoRVFRUYPFYnno2NGjdQsS0HLiBKfVau8vr6i4d44jpmT6RgKvthrN7R9xVFT8QKvV3t9y4gQ3LwGiKN5WUVlZu6D0b0TwC5CgnAoVlZW1oijepkrAC3v2aHie32YpLW1Sk/0NDz6DN8oYg6W0tInn+W0v7NmjmUPAHU1NNY7y8nVzQtq/BNCZDKTsK/A8b3KUl6+7o6mpJvUIL4eX5OiRI3Vmi6VhxrFQOhcqc4syCRJNQqvRZ98fMESTkxif8sI98if0jLdgfMqLydgYppOTl+uX3VsDn4/iPBtshbegrvxB3Gy5HUa9JYe25kaTjDGYLZaG/v7+OkLIacYY4wHg0MGDpuKiovV6vd7OJCljQBMTp3Ck920MTrhxe+VjWGv9q4wdGp/y4uuRQ2gb+AjnRr8EZdKCzyekaYTjY/BePIkT3vdgL7oV997yLDY7tsOgLcg88mmxAwNAKIVer7cXFxWtP3TwoAlAkAcAQafbsMJmW5/tfDo/dgIfnv4VElIUnUN/xN9u/jd8p/Jx1b4EIgNo832Ew71vYWSye4Fgf+FrMHwWb7T+I24beQQPrf9XLDdWZacCFTJW2Gzrg6HQBgB/5gghhADVRqOxesa9TPOw0l3dvlAbEjQKEOBSIoB3Op7Bce+7c9zVNt/H+I+vnsB7J5/DyKXuy6CvsbQO/B7/2fIPGAyfy+gqp3usqe+NRmM1AaoJIYQ7sH+/wZCXV6UThLLUBgfLsJuTpFGk9ioJAaLJCbzb+c/4yvvezKi/d/Jf8IazGX3B1lnPLkbpD7nwa9dTCE77Miog/TOjFDpBKDPk5VUd2L/fwBsLChxms9l+ZV86s6dHOA7gZj8eESfw7ulfYORSN7rGjqA32CqvM2RJDHzfxTa8f/p5/LTxbWg4bW42gRBiNpvtk5OTDp5RuiI/P986L3AVIggBiEoUEUkG8cn5l2SSln6V6xz+GMcv3IU7b2rODrjiPj8/38ooXcFpNBqTXq8357zek+tfJIg46v01oslwzv6BXq83azQaE8cAkyAIJrbAvFEDT7gbo4xGetA1fhhJKZa9HQAgYzbxBCjktdrCnBRAstlMy/0SNHnQ8Xkw6iygVMSlRACRxMLpwGkpjPaRj1CaXwVHQU3WCuC12kICFPIgRMdxnI7lKv9FJKBQb0VVcQM2lW1HeeF6FOqskJiI0UgPvvT+Bu3DH807wgAwNHUWg5fcWRPAAHAcpwMhOp4xJnAcJ1BJmuMCz28ECcgiWHetRo+N1vtw100/xZqSO8EovVzk303FNtxqvgsfd7+AT86/BJHGVeuJiBMYj3pzils4jUZgjAk8S99pzcYOLIICTAY7Hrx5F5rsPwEoICaTqhEcpRT3Vv0C4bgff/a+oVpXEjFExJBqX4kCA1HECIwxiTEmcQASlNLEQklJVSN4DaXK1ICnNv4Gd9j+Hkykc1Nr6c1RDlsrf47SZStV6+MIAZ/JF0hbxxljCcZYkqOUxilVaCsbIlIKuMryHccTWF3UBCpJWfe5VL8Sayx3qtan1RqwTCjOKbkiSVKcMRbjRFGcTCaT4VxmNLnGZfBz7+s4G/g819QQSvR21fqKDStgM96akw0XRXFKFMUIJ1F6MR6Ph4icWsqUkrqiAHLVZTTWi//yPIWzoT/lRAEl0py6iEaD8oJalC1bk1XfUzjj8XhIovQil7x8HiegfJhkmgqL4AhNJv34bffPcDb0RZZLF0Mo7ptTT75QjHrrQzDpHAtKlqTdR6PRQDKRCHFTkcjoZDjsz02N7JpsQKqEkoN4p/dn8EwczdhkKO7DSNQzpw5bwa2oMjaCu7y5lfU1GQ77pyKRUa6jvX1wdHR0kM2TACCqhJJFC20nEkP4/TfPIRDzLtjh/ktODEa+nvW/Wo2ArfafQwMtsu27vLyy0dHRwY729kHu9X37IuFwuD8Wiw3Pd1Ir/d6WfyuIhlsUFYADhqJufDPVNi/4uDQFV+ADiEjM+r9G62OoNd2f0eIr7+X57w+Hw9+8vm9fhAfAYvF4fzgc7jVYrTYi5wNI+la4QiA1Rd/HfZXPo3X0XUwlg+CI5uo2bcEgcAbcUvQ9VBU0zuvJdQQP4Gz4s1kh9urCO/Cjm17IvJSm5j9jsgfLYWJiojsWj/cBYDwA1t/Xd8bhcHxttVrvZDJTLC3nxgiZ6aCOK8B9tudRa7oPETEE7irdQkYAgcvDCv3N0MGomobzx7rxv8N7QUFnRnFjyXY8ctNeLCMm9dSdDJopvT9CkMLm9Xq/Pu/xuGcI+OXzz4c+OnDAPT09PWjQ6+1UWakMnKQlIJkE2PUbcK0RgTKlPcdQJcewf+CXCCYuAAQoFmzYavsnbCn9OxhYwbx5SzLPNOAIwfT09KB/ZMT9q127gikCAICGw+GTw8PDrurqajsoTR03AVHuDCtUkNpfW8q0SSDxDb6JuLCyoB6bSh7EJtPfoESoBJUWSNqqLOdEcZhqeHjYFQ6HTwKgwOWDD4wQQl/au9f97xaLu6Ki4nsajaZoln+upoJv4aoybsG+LQEwSkEpBZUkUFHK6OWpjT7hOCSTyYnu8+fdL+3d6wZAGWMsNXmZx+MRA8HgEZ/P9yUnn79LHUgkaVb0W8tsUYpELIZkIgFJFDMeu1WuYumjz3EcfD7fl4Fg8IjH4xFTY6m0XnTP7t3Oc11dp2KxmJ/TaGbLKJN7fL0vNelfif0Ri8X857q6Tu3ZvduZkv8MAbITxHr7+pIjfv8hj8dzcCY2SDuKlpWrfB3Aq0pfxkAIgcfjOTji9x/q7etLypDnKIABoDt27Og863Z/MjY25pxRgdpUuFFISAM/R/oaDQLj4+1n3e5PduzY0SmPPpulAIUKKADpbFdXe1tb2+exWMyv4fkbl4QM4DU8j1gs5ne6XJ929/ScBCCljN8cAhQkSC+++OKYz+f7tKOjY78kSfFMSiDXgQSSxchLkhTv6OjY7/P5Pt29e/cIACk95uHm8U3EnTt3dvb09Hzqdrs/ACDNrAxqgYa8RM64zEtZUm0rcKT3Se6r5Ha7P+jp6fl0586dnQBEtVWcU4uU5KkgNjc3H+7s7Dxw7ty5/SCEcRx3JRRTqIDJTtPMfpt8v6hF0e7MvXIKyr/LfWTnzp3b39nZeaC5ufmwDJ6qRbzzHpYmhHC4fIJE+/bbb9/T2Nj42Jo1a34IQEMl6UqskHZ0VfVdgWs4LU4yzXuFfyJPVcnj8RxwOp2/a25u/gyX30gTGWNUfWtjfgJSWTgegPDWW2/dvXHjxgdqa2sf5zhOmOWYKM4VZALN1BKv6Wt4DgYvBV7D86CUJk6dOvXeyZMn/+fJJ5/8AkAiJf159zsW8q5kEjgAGgDCm2+++d3Vq1dvbWhoeFiv11slUZwdOS72iVLlaqPijaZbe5fL9WF3d/fnO3bsOCyDl+aTflYEqJCgfe211zatXLlyW2Nj47bS0tI6xthMTM7UXolTSbxks2ur6uGlAec0GhBCMDY21u50Og/19/cfevrppztl2WcEnxUBKtOBf+aZZ1asXbu2dsOGDT+oqam5X6/Xl1J6JcHB1E6YZauGBV6MUEZ1HMchFouNnTlz5pPTp08f7OrqOvXqq6+OyJJfUPY5E5BGgiZFxCuvvLK5srLyuzU1NZvKy8ubBEEoUiUiCzUsFGukA08kEhMDAwPHz5w50+n1eg8/++yzHQrgUrbgcyJAZUrwAHiz2Szs2rWrzmazNa1bt26DzWbbvGzZMjsAKMlQ5vuyiugUYWzKB4lEIoNDQ0Mdbrf79NDQ0PHdu3e3BwKBhAI8ZTkCuqr3BtPUoAHAl5SUCM8999zasrKydTabbc2qVatqTSZTdV5enk0JfsZOpBFDFCG4koTp6emhUCjU29PTc2poaMgzPDzsfvnll7uCwWBCMeI5jfo1EzCPgUypQvPoo4+ampqa1hYWFlYUFxc7ysvLK4uKikrz8vJMBoNhOSGEGAwGq7KuaDTqZ4yxaDQ6Oj09HZqYmBgbGBjwXrx40RcOhy8cP3686/333w/JYMVU3HI1o75oBKSpIZ0MDQBuy5YthnvuucduNpvNer2+SK/XmwghnCAIs97gSCQSAcYYjcVioVgsNhEIBAKfffbZYEtLS1QJVvGXXe2oK6//HwCnUbafyprohAAAAABJRU5ErkJggg==")};
__resources__["/resources/rope.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/score_bg.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAPACAIAAAAqgF+sAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAkwvSURBVHja7H1lmBzHtfY5Bd3Dy6QVky0z2zHGHLITJw7fJE5ih5kZb3JvPic3dMN0w5w4cRJTzEwy27LAYmmZB7q7qs73o2Z6ekHyClZa6PeZZ9Wa6emZ6e6qtw69BztLBDFixIgRI0aMAwsWn4IYMWLEiBEjJuAYMWLEiBEjJuAYMWLEiBEjRkzAMWLEiBEjRkzAMWLEiBEjRoyYgGPEiBEjRoyYgGPEiBEjRowYMQHHiBEjRowYMQHHiBEjRowYMWICjhEjRowYMWICjhEjRowYMWICjhEjRowYMWLEBBwjRowYMWLEBBwjRowYMWLEiAk4RowYMWLEiAk4RowYMWLEiBETcIwYMWLEiBETcIwYMWLEiBEjJuAYMWLEiBEjJuAYMWLEiBEjJuAYMWLEiBEjRkzAMWLEiBEjRkzAMWLEiBEjRoyYgGPEiBEjRoyYgGPEiBEjRowYMQHHiBEjRowYMQHHiBEjRowYMWICjhEjRowYMWICjhEjRowYMWICjhEjRowYMWLEBBwjRowYMWLEBBwjRowYMWLEiAk4RowYMWLEiAk4RowYMWLEiBETcIwYMWLEiBETcIwYMWLEiBEjJuAYMWLEiBEjJuAYMWLEmCq4Q79xRv4Zn4cY0xAiPgUxYsSYxZD5m4X3GPeeLNW9nVgmPiExYgs4RowYMaYQREREoIeZ2gEA7vCfMzvfwosPxmcmRkzAMWLEiDGF7Gv/smAz0332SR48k+16rzvwMyITn6IYMQHHiBEjxhRawMx7GoAizypZuJ2ozNAxYsQEHCNGjBj7mXqNMcYY7j015lXfOdoYU3ZQx4hxUBEnYcWIEWOWcrD2hf/EWALmK8kYQrT/xcpGjBgxAceIESPGfmBfMsaoIow2cwlECReB1oDIGIvZN8bBReyCjhEjxizkYGOMMs7O5OeH2Onh8wqbPFOvtaaKFzp2RMeICThGjBgx9pv5C0TGGK11SddsgXdvobcoyAJACeYHmmmtbRg4Pl0xDi5iF3SMGDFmJw0TGa211rorOG0Qli6RPyvAQsu+xhhORESxFzpGTMAxYsSIMSU0bI3domleQx9OSMWNgdj2jRETcIwYMWJMHTACQASUGlMiNnljxAQcI0aMGFNMvYwxJoQgImKs/H/GIK5BihETcIwYMWJMBfvaKiPOuWVfRDTGICIXgnMepeGYg2PEBBwjRozphXv6Hs2r4qJUW4NTW+fkZtaXZ4wB58YYISQiKsZszjPnnPMyB8fUGyMm4BgxYkxHfGPdrx7of5Ijq5O5pkT9wmTr/GTL4vS8F7SeUSOnb1O/kFaRMSGEfYYxbhOv7JOc82psOEaMmIBjxIgxHWAtRUWq1x8EAE2mxx/o8QeeGnrG7nBq/dHTmYBDGrYhYCEEYyys+kXEsvkbW8AxYgKOESPGdGNfIuoq9nd7/eN3WJBsbXbrQzKbtuxLRIwxACCbeWWq/Qexko0VW8AxYgKOMSNRCnRfPugcLG3pKS5uSh29sCY+J7OGg4moo9QzogrjX21xGyQIm9A0Izi4LIxViQFDpDYpvtYxYgKOMWPQN+Lfua5va19xe1+xe9jrGwkCbQDgnMOaYgKeNdRrlSu25Tsm3KfdbSJjgLGQ5KYzB0c3ogQ8ZiNGjJiAY0x3bOsr/viWTeOf7xwsjZ/dYsxQDjbGGK035rdPuMMCt0UpJYSwNuX0v9xRup3mnvMYcxBxM4YYk7WN2mrdpMMnIOAhr+CpMHwYn66ZfaGN0VpvLuyccIc2Wa+U0lofgD5C+K8NsK5//5JxzL4xYgKOMfPY1xiTS/D6tBy/Q38+6BkuxZ3dZsGFBgDbRGhHqWvCfZp5XbmVUCStaUqwvh/feQMEOr4uMWICjjGnJ2VLwEimOeuM30cb6ugvmrjB6mxZbBVUaUNxAhd0irn1LGuMDq/1VH0NT+EV18LOEXJ4fDvFiAk4xlyflK1nsq1GTrjPtr6i0dpMtVU0i8DXPYjFkel2lW0bXSB6z7xX/Ef9hWemjl4pFzSwnIMSAFIsUcPSU0u9RETEPn8n3r0dkgIw8t1ixJh1iJOwYkxiTjRGa62Uas3yCffZ2lfUWiMi7bO+QQHyKUjP8mXvpsedq75tGucH57/ezF853WhYAj8vd0JBHOaVSkEQFHRpiAo9OMQk58CmlH0BAP65Ab9+PwCA5CYlsJI5FffujRFbwDHmqAVsjNFKNaYmvmF2DHhhYs4+TtC/4/93F7t1Fp9MKAw71/8cAFjPNvcP/0/c/Xcwehpe8fC/SXRaed0x7vITU6sQcEo/lDYNsHdcD1R5zpipdnfHmGUYgeEu7IgJOMasog1jjDa6xgVXTDAFdw77JV+Fgn/7gm7sfL94cwHys5N9AeRNv8HB7vJTWsk7/uL88avYs336fE+MNvNjjHHOOA+bCIUaUpOyRx/rhvt2TvLMUKDZO27ArrIACAEYrSkm4Bh7gj/zX/+B/WKmfNvYBR1j0tYJUcaBpERPUUJAjYt1SWzJiPY6d0FDimE5iGj33wtvoZ1k05TehBs+Jz70leC7s8nlaE8gf/Iu8dTdY17iW55iv/1ycMbL1NHPRTzIa2JEZMgY50IIo3V4NYWUQgguBGN70koo67BX/Q3qEvTiFfT8ZXBE427OD/vy3ezmLdEntTHMGAaAnMcu6BiTwc/59xfQYpgh6fMxAcfYAwrhCK88MmmUXytNUhDnzHGEm5DJpMAqTe/xRBnaN6Gp83P+/eeYM1+iXwUzTTlBDWhRyydkXxzodm/+3cS0V8rjzmfoqLOsevHBZF9m+bfSSbciuCGEkFJGm+nu3gguX8hFOfPN89iL/oQPdOAX7qRjW+BFy+mFy+DwxjEnB67fyL96/5iDaK3J5hbE7BtjEnPIanbvE/hICUo++RLk9J89YgKOMal5OZxtVzQIz9MqMKFTMEqf+zh+os7Gj4t3H6WPXworpv/kqwb08MPFgTtHBu/O+9v8FVfOqzu/ZuxPM9q94edYmjjzWTfMK535SiQAOGhqTdE+9lJIqDTvs+efcS6lFEJOppnuqBXVOQvhwyexK++DwOB9O+G+nfifd9GJbfCiZfT8pXRIPRHRzhHxjhtAj75/CIxSYIwxBlkcLIvx7LPHL/gPAGALbtwMG5bRIdN/6RYTcIzJsq+dmm040IZ7w6Ag7A+B+zHpNv3Y+3755j94N7jMneQoCsCX4ByoQQ/5p0uDd+cHbxvJP1RQPYojCIYY+BvftSHxj0OTK1KRn6blvf8UW56c+EiMD5/5amKCG8MqTHNQZg3GGBDZNrqAGF7oSjyYWyMYJ9FKiCLQHz9Z3raV3VsJBvsa79wGd27Dz91BJ7SaFy1jN27GHWOXJpRgSoDYH4kFMeYC++6Ebf9kf7XzwKO4eqlZGVvAMWYJB7OKa1IIYet9LQFzIcom0d7mx4ZZ1vafqMTSvfyOr8rPfTz4EtutAdSFHbeyG+7Emz+ivzCP5k/12TAls/V/ugZvG/HWlJghztBlkEogZyAY5rXWA/72961b+tcjUVbaAAS+WPfgrg44dPS5xfp2qfVBbNQT7WPPK2RsjAlru20n3dD8fXbnc6SCnBj533yue/6fcdgftaun8c7t/M6JE9AI0VCFfWMOPkgwRGzaO//tBPJH+cthHLTPPIB3v5heOf72jgk4xswzf61nssy+UtrZORoaFEIwvie5ORPSsDFaa8NHqXl8R155ij7zHHre+FG0E7ffyW6+jv39Dry5D3u+rL59ANiXiApPFAd+1MMZZCVwhhyBM+AMOQPBUZeMFwTBg31939lU/97F1rI3yIde9E73rqtST98z5oCFpkW9h5wmVFDOOTaGDp5kcbl5LgBHZKMdEqEbJGymOynz115TY8zSrPncyakP3r4n3wZ0kos4BfoAQhsaKARdQ96O/tLWvuLW3kJfPvj4RSubc+40Z9+SKfxe/Dx88iF2v9EaK0n7sQUcY8rQW8QbNtGrVk31vMw5F0LaxJxoaFAIEYYGYa/II9Rg0uPktAyYDzlv+Vfp7lZot9+kA3fcym64Bq+6i906iGWx/pfr171JvZNgapsylTllh59LVEm3QsDAESQHjxtDSiCNfHND+pw6eXjWFrP6MjnynJcO1y9oeOgaUYkEa+luPfICUhqFPgASj896lUNvMwBQpYdutIlQ1EZ/9pNcuaZaa2O0/8ql/Jat7tWbJvl92KCf/ukac9EyWNEYj/IDgF/dtfWutX39Bb/gjcoh3jlQmrYEHN6iN/B/PcPWhc+v4091wI5WM4+mdxg4JuCZb6R+8CZgCFNGwKHpUw4NAtjQYEjMjHFRcUSzvU2WoV0QMADsZNs/5rzzs8GV9/Db/8Wvuh/vCnnXYplZ+XnvawaqXeKnYsiFRh0bCLIJFCH1InCOTACTKNJ8pAiloUAC8ZIZ+fTjtb8/ySBprY3WSql8+6q+ZF3bYzfUdm8EgC0rzigkahytxyhpH6wpI/qhY9roTvjqJC+rMdr2UOr99DEtq7v59kkVeWNJ5760mr7xmDmplS5ajs9bCkvr4vE+dTTWN+Jv7y+Of3VHf/GoBbkpXdruC2xrkF+6P4w+OYLDT8KjzaZ1mqfvxQQ8w/GHp/B3T9HbjpnSXqdhEpYQAhFDtrDPh9SLeyTRMCHDGWNoAkHp68TVt/Ebi1gY/5IE58riD3KmxqDZA+NsNLxNvtGUXOY+K/saY0Re51zgHJlE5iAmkKUYphimGK+Tjj/obPEFR4ZoHhwq/WabeHWblTGxHOy72TVHvWjeM/clioOdbauc0fbu3n3/qabhvXh7lLmJSGutldI53vXZo9vedjeYyVr5mA/4zVvh5q3wmTvolHa4eDldsAQW18RDf78bkUubUjdOtMPW3qIx5cF1gJeGJSgmIPmso/JxfPgeeduYV1fze89U5/G9rY2MCTjGs4wZWNvH33MjAJDLo8/v91vNsi8hQmUQhh8UDRLvSwJRxfojqSdOY56QfQHgfYVPHOudqFCV7e9Jh3x0vy48Xszfky/cmw/WloZ9c8gvF2dPzDyLMae1IOPOk5himC7zLqZ4mYAbpLtTintJCIGMM87Ud7fiWbWmkUetWwDYtuh4RKyKS9n1y76dw+nnnBm1GjPGKKW8k+udNy5r+Ol62FNH+0iA/94E/96EWYdOa4cXr6TzFkHFMouxLzOJXVK35SYeetv7i6aSn3+Ab87H2ENf4Z9JQbqJWpqgpYla6qmhHhobqCkLuQxk0ybDDPuV8yM9TnpjtbjPFKd7Cn1MwDN2xVpS/C3XwkAJACApwiXqVMyi4frRMhyNM9qiH73XGlhE9Axb94j7wOTfeLp39huH3hlgwDkvf/RuV7ukyFvr5e/NF+4e8R4vUq/iDAQDl2FhxNv4jvWr/nWYaJTj3x5NKRKNTB6ZxDTDFMckizIxb3ac9WkuJJeSMY4c2QjS93bSp9qjjgTOud0WQpQVpjhn+xBEn7bkG64tQvuJjOl5WXvdbzexgtrLQw/7eO1GuHYjcqSXrKRPnQqrGuJpYV/mE3tdGjNCcgz0WMbqGPQ8X7mOOMAJTUR0gn7OZfD2t8nXBOCPeTUBySzlMpTNUm4tm6DA7ynx2AZcO58W5KiOTVfR5ZiAZ+qYYZ++HSuFlWOyVfe7vyU85hjv4j76KkOsZU/d4l53ferqh8T9JSxO8l31uvEzvVcarTWvmv581yGf0ppSxwe3qo0eBxAMUwx4EsM47iBT/pbizk+uX/CDVWNOYLQpstaaNQlxpFOxfRmmGUtzTDNIMl4nnMVJwQWXsmLTMrxxhF5UxCOljaPbpZL9CC6E4zjSceTkBC5mEPuO4mDOOeeaMcaYBmj51tq9Z1+LuoQ5pY3OXwKntcOiHMQ6WfvMvlrrjKSapOgZCcbs05cP+ka81lpmE5oOgB0crWR7gbrkX/rutzmv2cCeHjWcoVjCYjd27uogPbzrkvrn1lJ9BrL10NgITXXUEJrRddBQT40uJLKQa6V5MQHPbYwEeMsWOqkNmlOTGTBw1Vr2v6vDJ61rFCs5UFNkB+8Xro3iaXziRnbNdezq1exeH7w9ffvHur7YWGhSXAEA262Esh3P6oG8u9VPOdXUZWHZlyMKcJkmCgp/7xg6vzb7stYxPzOap83bhJznYppjimESUTJgQJogIBo2qFC4DhcCLaHaLLUf9+mvt4ap46qibCyEkI4jpbSp5MhmlRfa0q9N2RNcaKG5Upk/bKm9dufeHdC0pvTp89SFS+CM+diWqeYc0EGTD5sNvjQiGx1goBvSfDwB+8p0DBSbss4BTmgKQ7yr6MjfqWvekfyP+/lde3SEPI7kcXddtw+no/9TfSMm4DmPlICHO9kV19CFS+DiFfTcBVCf3OUduaFfvOfGMc9rrTmAAbDO2GmLAIK1+OSN7Job2D8eZg/sBe9avLz3dWf0nau4EgDEOcGoUpkJZxne5ecSZeplHLlEdJElENMc08zpJp0POMDQF55KnV7LWxLjOdgaCzjPFekEAJAi8sgMKyoaKBoqGiCkAeIJyaVgnCHjjCFyzjaRub5UekESETXnXAggsuRk9R2FEGzWsS/YmAWAsMlrRvOnhpq+/tQe3zOLM6XTWrxz2s2JrVif5FxwzrlS5cq3itsg1ovea56ziita6+Y0f3qifbb0Fg9vz5IxdKCcNFV9HmOMMU3U8rPgLx9Nv+Ofzl/2y/GTkHqzetfb1QcboIkOnv5rTMDTYx2KQB8/hd21HX/3FPzuKWxJ09kL4eIVdPZCqEuMIhJf87dfjz2j/LR28CAin95Fb2vxyS/zT17Dr9rH42R09vXb36pBRwLPEydgR9f4bkGxHGMJhklkKQ42dptkmGYsJ9zHIOgIJCfWTcNfWlPzzaPHOPOrM0LJ6JGAioaKhkoGSoZKRCVDJQMKqEcL12GSM84YY8gZIiNA+buR4PQU1kjBRZjpHVZwWfN3lvFHuB4qF5EXKPuR+7A02T41JsG7Xzpv5Mxm/6h6lnaFEEIY7nlSGiIReinZgfKLzuYJqOLdaU6PtXElx1yCWY4+MEXqo7TlI6Xk0jhfK/2wMdf88/T39/Ejzlcv/Ij3+VV0FCKG1RMHZebkH/7U5+I7cDp4gQCBTp/Pfr8GCgHkA3y8B//8NP72SXisGxGhJQ0JTkTss3fw349dpPqntKjT5oU5L9PTiiKiHNUeb045UZ+agOQA9g3j0F6a0Sxw+hNHPHpicBdz5gs35wghxtQiR4nTrqPF4yWHMT7fqT7a7V9XLnZHVnerTYPCYZwjrS2I42rYwmR4Ju0RtNZKqcQO42wn0xWYroC6lOlSpisw5Q1lOgLTrbjg1gsNyAyhJjAFwgDwlDTjnHNhH1H2nW0p0OOufuKDt8nbdkz+LaX5yXVfWuW3JolXLmWE2lklJz8qRR5z8N5cmrBSW6l8yV/fE7RncUUdHNPKTl8ozluRfN5hNYe0pq0QKR6ou5QiywKttdZKa6WUOmXkjBSl70nevneHXaKXfyH/tQ8VP9tgmgDArhDDm+rA3z+xBTwt2LeM9jR97bny9f+q7rFjBH/1BPzqCWzPmvMXw5Ic//oEScI6LYzWxDnsW0uiqR5OnPh8WtRuFjzfvLif+u7jd94srr3duWkr3zTJ47StX7TqnuOOvOWUQ+47um+LYuj7t5QW/yjNE9XZAca7jo1RSiXahHA5phhLMUgxZtOY0wzTjDdKt90RwIS0XMj9/7dRnlhHKRz/K3RnoLZaw9c+iEqGPANFopIxg5pLiYwZAmOACEz5QXT1CJ6f4YcnozlK0QquWcwf8hdPyt+v3aO3GIlkiNAYROsjtf+UHaZkWFjiGU8le+uiGFOuvaxBfuA5SdK+bQXNBbouCqSoSsyBnzcsDQdBoJUyxryy8w11hYb/nvepPBuZ/KGSlHrdyBVvHnlXDdQFLLBeGQBgAHDwnE8xAU8LZjLGlJ0tFy3BNx4ufvbE2P22D7P/e2x3BwGi6aqaO0qdvyJ3ldaZM4vnnmaeO6QHHxL33Zq84Z7U7ZvcDePfXtNTv/jRQ4+4/cQjbz1l4ZMrcj11CGTcknFKDIx+0Ov/es+8Lywcb0SG57acPLVQynZuI77lwiGX2X4JKJnIulxKLiTjDBljm3z1y53yLfPDSSr8FaYr0BsCKhKVNJWo7Ij2iTwiRaSBkGkDhkL2pfK2Jvhqr/j+fJbmsKeyjjMaj3bLT9wxgSejXg4enes7MTfvqq7M2vyEDLEbQOx23l88HHaiZOhK5plRp/cAn+TosiBaeREmi2mlzuo+T5bEJ5a9x6CZzDFPHz77Hb0fOiQ4nHHuc59zLrgIPyKsXTzwXuiYgKcHPxGVNeuNUZ8+KX3nDr62fw9sBaesTjXN1xkhHSqltFZBECilhBLHBCce2X3sm/W7Hncf+WPrL+9quCX63sWPrPr8RT91i4nA8bRbCrKDDDQHI8EwMAxM4ZedpXNqMuc37urcWgIWS12ZdMBFZEhEoAA8YwaMKRhExhQTrhSyLKCBjNGvus3zG3Hh2Gw41RuodZpKRB5RQKSJNBABQfkBUDF5q+YvEIExYNb49LWezGdax6wVZiWRlBcuI7582/WQr+bW+vNTw8fX9p9U039Y2s8yIiosTh71/jXMGzWZIiCvSI0LIcZs2Nqm2PO8vzjPxm5sPboQQiMCQFiefuBPcrQLKov0VAgN4j7sJXz2GS+tMx/Y/OnzB18YUi9VihFAY7mpzME783EMeLpYwOHiTnFSR9Qn/rxh8nJ94GloTmFblickm64NQMLfaSM6ZQRB+NcE1FhsCsC7q/HW6Bs7l25lmh19+wlBZpgzJUBHHxK0AB2sHshe2sqSYsxMEQ5XpYJc0pHAKW9MvzLdynQp3RHoTmU6FfVq7/ERtbHEE5IJzgVngnPDsFfROTVR211rxe8pioeUKZLxyWgwBgyBBtAE2pClW23AGNCVR3mbQBMEazzi6B6fCmPVs5g/jDHs7dezG7cAgDq0Ln/Rwp53HbLzLUt6z6gvLEhot/zDgwZHJ1nd/YOj7ONGZ+DSReU6accJN6SUYfjckkbYQCJm4n1ZHNvxCURQbb4ihJRSSuk4YcOVAzO9jC8CjE6VgQmuXPL5PqfnWY+TMIl3bviIMLKarllFpb1mZIURW8Bzbu05iiqMVkp5R9bge4+o+eqjkzxI4u6uxN3/Notz5tyFcPEKOG0BZJxpPtqrwbwK7PMem6Aw6a8f+PHZfzl34doFxlUMNAPDK+av3cCt3vB/r639yhG7Sl02xqitflDQEIna2g0oGtCAeRAJyaSwqcvlEt47i+q+ETpplD6l1hAYILJWL1U2wNhqBgLEqP951DYRGKKBb3cTh9rLm2YxYRARGcLfP4WP93gfOaF0VuvIyoyvfN/ztO9DoMO2hvYadbysrfahofq7B6JDw3Ec6TqO45T1whi3tVus8hdiC3h/mr9CSmlVTWxPFCv/LmQlp/9ArexHNeYisgX0Eqrx4EdTD65Pr5nMoYbF0OOZh04ZPjOqnjtKAfagRjRiAp5GHFzNuVeq9w1LnTt2Ju/pnvxx2KYh9pPH4SeP09JaOG8xXLycTm2HlJxuPzYKVukva9u/72oArPQOE69WyU+T7wZR9o1u+7/d6l3cmji9aXwlUnncbvN1H4YlQ+RRuYioSOATDRiekExyZl3QyAjRENAPeuDoJMjqMTVRoKu8W/1LQAB+vWYAoo9PwL4V+9gQdH+1O+gzjR9oZpLNPv4IF1l0Umvp5kt9FQSBbzxPV/o+WYOVIQvTF4wxG9+/NPv0Y7Kv7KxGhtJxXNctK4VVTN7xmc9xPHhf5x9Ezrm9DLbH6CgC5kJIeYAd/uGnsIiwQTiWr2754+QPtSb7xHNGzgo7mvNyxYSImr8H6+THBDyNaKmcEE+ktVakd376iAVvvkd2FPf4aM8MwA8fhh8+jMvr6MIlcNFyOqntoDNxmW+JKh0MJ+hzpwBwnKZVSqXeuuZ9tcc3wGJPdgfjzF9iCMiQMe59eb3z5zqWFDCRhobZ5usdYCoWMHiGigQVMoYCCVcyzpExArQ5zIaA1vr09wH20towx81oCPRY3g03Ci166OzCvO/UGl3mWiDQYR5WhJV7ftQ78kix9eOtqSOTs5I8DJCZnzFBQGRC6gUAO5XzStJ+2OXCtKY2fWDZik+VLRtKCiGFkFIK6wIVE/JuTL37bmtaQ5NzDo6DigkuytoUgFZGNFqDdOAtE8Y5RHxam/iGu3K3jd/f1a5iSuPYQvOnco+JbiGktK4Ux3Gs9A2PhLfjLOi5a/uOSTeASq5BqdUdPrWh/i/b9v4D1vfj+n74zmpcXkfvPYEuOxIkO4jjPNRkgHFCwXZjwo7Cb1r7rrbifAAovMbPfVMxMBw0s9RrzSGbt8w4rPf8X253r1g4pr6ibLlu89Uzppy37BnybQoVkAEiAEQuZZl6bRyX7Eukf9ovn5OipvIXM0OgNBCBgQloWHEqHqJ6X5DP/i1NkVQsTeXdombx0N2FwZdtrHtxTcMr6jJHp5g7G4ikmjROFI0vlL2d1nUM1frL8opTKaXU0FnN3S8davqLLRdGHjFZ7H0C06Nj4yychRjjFXd02JM7Oi/hwUguqXIwY8C5lfy7OvsnD0tj9jy296TXr31rb6L7G0d8aUQOR1/alNrgJ/y0yNhMglHsG/lRsRLWHDZ/K5K5RvNwXZZ8sK/2mp37dGiOdGQTnbuIzllERzYhx4MoW1/+3Mg4Z4xxbgQXSijGOQ8CK48cfddZHRect/OFyBAAvNOB/mXkuoADWcYtjx9enSDM/3Xo5zXhwlS0bWLZvN7u802GAqJKeW7UgcwYwqjK3YjN2qf1V7rlV5rKdcA9ZHT5XdWDENkNr0EDwMDzitTPEjcnYKJIcLitDYGizt/27/xNv2gS2ZPT7W9tzB2fmiUu6EjxaNhPulx8yar9kcpFYkGAiFrrHe9cnn1kKLFhBBEY5wyrQd843Dt1YzPsN8oi7c6wonZyEF39VT8HY4yxoihcnf5TdIe2Yvsrn7nsrJ3nA8Di/LLPPnTlV4/8QmeyKvnSJ3u2pTc3U6vrujapLKoocnBvqpiAp8Xy0970nHNtawCEoO5C++cfZ0W9N9NfguvjmtV5C825i/DIJiY4lNNECeEg1LpFE6MQMRzn5TWHMUxVbd+oBdxWnP+W9e8N7R5ilH+1m/lPxRjHMCFzNAdjicF3d5ovLxljSRORyhMr0qioLZQtVAJgBEAYUu9Yvry7qH84IN6UhoD0TkN6VPpVlInVwnLn1KHXFDQH59pEOT+r4tMOU7GqB2eQXJWoe26m4fm5zJGJWaZpHHV7sAr7jiFgFQT2JyulTJZv/8zhy954HyoKCQBiq/eADE8bCZ7QSzeGDg8KBwPAde7fO3mZXB3jXrzz0pdtfm3ay4YFwSuGV33hof/52hFfWJsr9ygkoKfSj53snV5mXyHYwUt7jgl4+k5SwLltV8eFqPvPR53thT06iK6R3rEN3jntwRnzaFltuVZSKw7EOTcVbjvoQyiceQEAjeGRRodaa8bLxClIvH/dJ2tNHfJqMX5wfMI/Uacfoyr1jjWCObstT/cN08m5qEcUAAIX0FRN1THcyREQqqQ4OnkKDIH5vyGnDc1RGHRZAh4bADYAJEkvM+V8FqLCq4pBu5Z/SFI/Cw1rsu5oBN7O06tk5uRkzUnpzKokEwxZuW/p7ODg0M9BxKXAsBmUFe62d6Ml4GojZEQyJjiqofctK7I3dcYm70EZnrt59SD6VADAgPlt4mf2mZOHz7hs69uX9i/XRhs2Kn+zzWv/4mNf/8ahX7q7oRwqfiT5IA/KkWw2lV3jYgKewStQLMdDefb/1qav2z75IwwfU9P3kvbSSU3Uli7rFXie1lpKWW2UG1nnHqz5PbqODr8YEYlyQydeTrQBAIDXbrv86OHjQWA4WdtUnaFXp7JrPQ58FAeXw8CMcYbIzQ979TFp5o5qDFXNXp6IOw0C4hgjdcw2+f9vEI8SgbfLDCyzSrNWtHlkZefqWUodMcxudOABSUOMmgxbAolVzD1UJpe6bs6VUgqJyiiuue1nFRbnzGjusa6O0HU8RttojK5CNLiolAKAwbceytOuzaeJOfjA0/C0QphVcA+7/WF5/wK1+PLud5/b9Xzf9xVTjChctVt7l4iyJvepNf/9w+Xf+FvLHwBgjfN4wAIXEzDNcuZjAp5Gt76dmJyHehL/tXqP3t5xadvQWY2MMxEE41Vbq0le02lar3qkrUx0ZWVqO/seN3zyf3RcgaJasWcJWCmllmPhDKq9G8PcK5sCzThDREBmCMw6n/42YC6tg8h50AZIT1w7ZAiKS4LUEGeDbMLK3fJ2idTdgaZdETCxCzTnIrTtyBhttGk05uUevbSEJcayyDlHLsBBxRjzx/r3Zkdvn+ocxxgfHVYIE/7DH2i0jgbsywVpEkfefrgrecy+0x1kexpMOQcHxv+D+4vXFN70lp73JfOpAPxq4mrEr2ajWvaZ92z+eKtp/0Hb17fKTVv55lVwxHRbaswkAiai1dseP37BkbP5bh7w3HfehN4ehn5NtZjSGMMqqaeheH15dqssJKfbpBbNBveYlzTJj239gsMd4GUxPF5JgGSM+QD9l1Dd48gDFjWCo7VDhoB+3s/PzkBd1QhWHrAJkqfK0dzhQ/zBBbrlJ7kJNJxN1RqOFiCZqBAHAR6h5XPAVkxCpUkzama01qgNGsiUb+Pyb1FKMcYYU+UyaGZtwdlg+1ao1GrsRpcUY2Jv4Uox9NYoxozWtjLVLqpivclpi+6/DzZcmJvS7P3QogjAv6LwnkWFpZ7yfPDKd8jouvCo2rwtr3pd1xXzaP7n5334AXnXofrw6TYHipk1sL992y+uOPVVpy05frbe0OJDt7D1A2NvQclGDkn3nFqLmhb/ZIKqpHJeUzhPjatrGlVnPF0vbvk7A39v1yfa9SISFOrh2eQdrZSPSERei+k/n9pukDaVkQB1NFhribNX6W91y8+0VBYfoAdIV2O3ZMaUDzlQPNYfOLOUuilBQON90UTga1CWdcexONRS6p1aOMJxHFZxuoaqm6gUmbJSFkM2XmI+qgV2EKXhp8KfOWF8MfqktWA4kZTSvmQ4t04RewvHPDc9sfV/Ogsb/aaLaw6M9eVod3lwqE8eVAoaw1mOV0rUqFLSZrQuF1MhPn/oJTlesz79tFHlIRZbwHsJrfV7rvrCPy//SWu2cVZ5cext8cOH+R+qvX5NRuaPzA2eVNd3bGZkgWvvp9SmYvONvWPeHoq8jNes54yPqTfH6U3Dzy++OF3MGGEAgJflaIW1gFXFtau17js/aHyIOf3lvkMVjhydwHztiDkuyZ+XAgAaIdVHpGmM57lKwM0aEfsuHTF5cO9yx7OvMuCpCQSwAIAdrhNvVnIht6IRUkpr/Nm5wM4OWutoQY79aVFxXRzXl3Sms++YmW7Cn1OtAuCchy5orQkIKwVI01PbfC7DFM2Wr+zc+v2eQ3+0+ADwWdR7B7ZkmfPwzolKpJUHXRAopeyIs6Pp7MLzzqLzSUy7djUzg4BDP9XShgXXr7/jVb95z3cv+cKqpmWzY1iWPSx3b5fvvxkATFPSP6Fx+IzmoWNyI/VMBYHSCivOyWfesTD35EhipzeGgEO93CgHV5aGYxXXpud5s0Z6AzUpHhAjK9pgfw/jPNQvtKlYpbTecaHX/utkNLt4fP6UurLHbWuCVdx06aCv6i4elbpMQALMAoOIKHDwsnzKJeffiehxjIFSQJrAmr8AABxwoeZHKXZyIA+HcnW/EPZChF9VaK2CgCultQ5N2zDbjnNurxobvU6aHdP05H9IWAVgf76p+OFDweeY86aLCVTUg9cNbP925/ATnmx0a85IVXnxgHRoiKb12TvEDh87duzkwDlnlebBdh3PGEtQwhZhTquucTOAgKPdWOfVtADAU50bXvLrt3/ozDe/7qiXJGViprMvAFB3gf/XPerSFaUXLCoeV19Mked5vudREIQ+uvKedWzDB5ce9pE1GOmVxDkvi7xIKaUUQiCO0qzHad/yPXSah5WIVpTDUnAYGbV+XaWUEGLwJC97d5BcJyZIWg4dyHkKPtmb+N86tVkrBWbC1GUCWqRYGwJyACBGpdeVgiVa/ilJXeWcLMu+CMCaiK8y7AiFKwOYr4EBY4yz8oontIA5F1BO8dVKCKUURXJDxnBwyL72Ss21OT1aBWBvU+uNj7oZYwt4SgxZRapERpHxCJEYABIxB5lARACXW1lYUzSqx/fWF0fuHuy/YTC/1tfACVj9+VmeZdFyhim9TJWYGhcCQtM2amNAmFSvOGNMVdxO5RsJRnUKj2PAe24jEi2pn28NkMHS0Kdv+savn7z6Dcdc8rylZ85LN89oDjYC1PfO9WtEEPi+52nPq85BnKNBmxtMQMaY4eNrt79m3vxfVeuUWMpxHMdxXcdxQsYqT17jnM/Tdi5jFfYtO5ewIp7OeajOY4wRUkqlbHi186V++/8TpHbXesh0Kv8DfUEK/bHFu9WSJHaK5oIjYDWX7QxVOnoI7pawWgZ5xCZylhq+wuBig6kwzxztGpxX6LeyALJroHJOJudCSh1t2FyhFjYGOFf5JipHY+fLsnM/Zt+pweM/7b396kHqUlg0QpHwTQZ1Fvws+VlHZblKooaE1IIbYkEe/D6tSqCBa+Bga9UBGy7J2gYqB2JiqYR7hRDGMBjdwzjq3qPKV2KMG6PDrhI4Ld1L052Ao93rgGhBTZtkMiBlaXhN7zMfv/V//vuBHx3ffuRp7cce07hqYaa1wc2lRAphBlgS1ZKhrKMTaIJAa102lcKOMRWTKJKto3e+cVHtw0OZx8uSp5gKbd8JhNZg2svnYkQbCwDsAIt2CEdEKxYvhDBGCymtEewt0j3P92qucsf5n0c3P9ioiwFoU/YjjE6BBkhT6mziQtrzY/PGtdGmxpgLAjrfF5EcsdHmOrOrBCdsWFtpVWsJ2B7NCn5FfV/RWti4t88Yf3WYRE0RhZaYhvcj8h1B5+e3+R71gsgAJQASQAp8DYGGwIBP4BvQGnwNXAHXwA0wAk6ABECABJg8PJE6zjFaM8ZginUtqsPEShpUpPFCGyN8yS7gRFXUmoeWTBjiiQl4r/y0RFrrlkxDS6ZhW6EDAIGgbA37IzdtveemjntAsJq0OLzOPaROHFKbW5Ktm59qbnLbBc5HWiCgxaGGaWoB2wnaVJP0bAMQTgSRjNkwq9Yg2/yxQw5928N8RAEAZ4xVvLU2Z3jG9YoJORgiQsFRtfRyI52yQSm1UlprrfXw83yxhjtPiGoelhltBwP4ijxVDt+GiVdhNDfxaiWaqxog5fIha2SjjqoZj0o0r6wPrO0bds0rs284KVizLmL+wrha2Li3zxgaHqNdGlPm/pxIATr+OVjjqedC8RngG0xaE2PccCAO9i9xIAC0RBtemegGAdS9LKNJk7aJ/YhTXL9ua8pZZYqAsQNy1K1iJ09bUB4S8JiVbkzAe2Ym2lMpgC+tn78t31GeO6nyAAJCAMgH/s7SkJsvAC96rFDkxcAtcKl7gY9Qkw/zUK2UhWMa9fEL5JGNTsv0MYIrDtFROX5jNIO01kEQMMaCIPCXZne8Z/mCL6+BSDsHa/tOH6G1PZpzwwFWJbzRdnxIeNYIFkppIbTU/W8u1XwlybazCR3RxkDBB22qSctRyAtU4iVQdiALEZ5nzvmY8qFyDCniOLbWubRwHEeW8+BwtNYxAFAkij/GIRHz7pg7Yfw8Hp+Z/TnVGOr+c58DygF1Eg0eUl98mBqHdhqWIMao3N8TiKqTK0YNX7vB63n2Qtd6oSpdRmnqiC26LJtg3hg3iMo3EoYdUMfOJ7EFvDf3jjX/VjUuu23rA6H5a1+17AtEhlCZ6kMbNIQCAEEH2DEAHT3soR3+P7f35Ab72y+ue8cVS98wnSYgFvaKCXMHQgIuN43h3EO0fWMGXrKg5v6B3A0dDJFmuAMzpCsiivp5x7gfK+sMIaW0/gCtdVBrBt5VSH8jyXbw8WHgYkC+HqfVI4EdEYgLVOIM5CLsEips9LFcPhQEofc4/JIh94a9fbjNvarYvmwisdndVODEiE/LgVzo9z9aoEfyHBQnRUiLFuDys8STW1PPXNULnmYucSAEIEAoP0LD19q+SIDZCxMmo42xxRksHLNTdD/spp5tQuVqWzERFYEJ1wexC3qf/LRa61VNSyPUC6O2bUGnQUWoCJXBwKAymIBy5gAD4AiCG85MkQZu6rrl8iWvnw5jflTHmHA5CaOWbESktQpndqaUMabr40emHhlAz8z0Uo3d6DZE/1ZbVlip60rFvZlnhj9UcH+QZE+KMBHaOp99FZlFMoTLNTtG4bEBW2CklKzsQpbSccL6XWMMV0oIEVYTQiQQFXYvLtcRcVFNFovEmWauB1U8crNpX2Ea58e8Ncs42BjT+7cBoQMBWpASGQbzUqklyfPf1br5pfWPfGgtbPV4wiAQ2fZgowxfKHukGaQukVbGbUxaw1S7RiY5pqp59eP6gscEvE8rOGPMIXWLHCb9Sh5W2fyteKSJLOkyZf8SKoNYYV8GwJE4I8EMZzQQ9BVVKcHdg3hhcLSfJHpPV1XWAKwFbJPp7Q6BrdZokr2fP45n5IzOUtlNAGnMM6GzXUhpqKw5V470NAXFj+T5Px12rUt9zBApDb4G4MDaiK8y/DiFhyqqDSsTOKvSr81hk6ycBWYs+wqto4H5aNqy1WkaU+s1C8pm+DOPyut/TslMcPar9eGnxbw1m8xfXdBD/xoUoAUoAUo2J+SCJJ+XNCnRelKOPrVi63ef4U90ME4KIWoBR/3PyVc6OH9UWsOBudv36FN233UmjgHv5XknoqZU/ZuOvOT7T/yxEtPDUaYwgQ5d0NYdTQwIGFY4GIFzwzkJbnpVT0+prz3VenCvSlSzfuyKMjKVs0pedDkkiWiNM+/cdikdF2aJBfys+9gMtTAbyzqiy1lsktRFHp3p4SPSbGOUQKeZ2GLD2wlkJQRL5bA6ZzzCvFIKaWWcy+X8xnAuyBhDZlQSFoyvHmIQSWmeuU5UIsLCkLzh5wCAxRHnXz9Sm58MznolpHMxh80GDjZmx50jsLUkQAmjpAtOe9JpTzoLUwbYyMaSCTD1nPZCAeXmDkSKhn7LR0mj8xqRfA0fVdE+epqacbNKTMCTsI0iUxsR/cfhLyIwP1339wDUeC+0JtQGQxoODAIhRwq90IIZzgxnxof8zkJHW6L5IKanVz+XMYxkoIwPf9qbXlQWs4iISgERMsYFx9klovSsPgPOuZSSjDGOiTaAQkRdq+nMgEV2Dhu7W78CQ4aMCSFs+ZB1Poealzb53JYPlevfxrkrdlU7NKPZFwDkjb/CoarQqXjiTrZ9XXDua/WSo+LQ7Ey3gI0x/X8YsLavoEDWS7kgJRckZYvrDxmvR5W6Aq/LH4JcH2ON0JeAwFhHNAK1MzqZ8wu4WIxjigLGxFxizDYLGMbVTQLRK5dfeHjt0t9uvu6+oSd1WU+h/FDEFKEipg1qQmXQUMQFDcA5cW44I87NlsEdx9YeQQepB9xuyi3GTOihECNUmr1XCt3MtC1xm7r1SijfL6QkGMW+QVCVUopOE9Ec5krwVoT1u2UhyUhFv40KwLjGjjC6cGh25DDbEygev108ff+Yl9hAl/vnbwQnXBic9XJkPJ4xZ+jSyhJwpo48UIKUECTbk878pLMgBQnhbfW8Pu31Kq9bBb1B0ThbWHPt0mF2AbEM6fnMtCNzibNKc3Hbo2w26qfGBLxLx2M1K5gxADikZvGnD3/zuuEtd/c/8XB+Q7cZHKRhpcB4YHwBAUfDwDAEZAjCUm8lDCwYCW4Eo02Frdq2Iz1I99AkQxRRub6wDh2xLBhUzbydAyMh6ogWo5sf25tEKWbFNKLLt1EuY86jspFR9o0WfUGkcGj8p88C3o2yL/Z1OLf8fle7gFegShVXPNXOyEtsjDGm8UO1fd1D4vphkeNyflLOTzrtSVWkUrf2e5Xfq/1erYoGEBTgzs5cJlFInRoAEGOVVWllARsm/EPMvnPHAo5mnyqlEHFZev6S5LzXwPl38Hu/1/DDYV30Fe/l5KJhTPMA0kWWc3giqSVSAiAJkHJVMh24eSUTaltpu+0ye3A1eCcfAY12Z7MWMFQKZOeULyj0B4w5RYwxoVQYFYZxtUOh+VuBHJPAPF4LYk+v1Mwzj4x2b/g5eoUJ99EN7aUzXg5EbIY3Kp7TBEyktSaHEl9s0Mm8s07J+UlnQZLVOMVtgd+rvF7t9SqvT2sNhoEBgDz0fyNFrJg9U4Xt1sKcCcEn7uUVY5YScGUStbOmEkKaavDvr9m//ab516XECLi+cVW3o7oNPNKZ4F0Jd2sqN5hL54Vb4K5hMknogmLcQ1kyzsbUVhM5zjS/jaLGX+hotd7paBvgWX/XhuzIIgRcrhESQgWBDruBjtaMjTRAiGyPtn1nK9fuCkZreedVYtvTE8/dXAyd9WpgghtDsWbIjGVfO1cYYwwY7/0NQ7fm6xMpZ0FKayh1K69XeX3K71XBiKaKxqABIICe7yfSKz13Udlp5LhuWXN+dMgmxqwl4DGdp6wKkmOMvbMCVN9O/fD6zA2gFPgcQJbfJjUkjHZ1gZmCz6DPgZ1J6HHBc0A7oAWQSDrp17zweeWUV6KZcs3Khi9jDHGMZv3cGQyjZOcqp8Xyr5ZyQgIOHdDVWt7RtUNzjVoqtSmKdW/d1T4DR59frGuTStkVHudxGHjmeThGXW4iIho4mW/IDx1V12r6tddjnc/K69XaL5u/4UMXsPOX7sovMFFWexuVMxGbv3PGAq6qLQrHcezzgzD8ObjyAf4gaAaGASEYBMPAMAANjgbXQEJDUkNaQS6AEgeOoAE1nL30mDee+sIjFi+jSp3JTDGCqzovEZEXmHuC9eOlXxljWnPb0CLs24swqnQo5GMYncA51yaRapsTwKELL3cevD6z+jrUQXSffPOSnuUnO0EQnj+KvdAzf9RY9Lule9c+tQQX6l70+rTXo/xBbSq2b/TRdxf6W2Tm8ERFMG5Ux5f4lM5+AobRxSfltbke+nj/Vx7FR4FjhXorGxrBIDim/HArG47mvvOc+Uddsuq5xyxYmUgmyYwqYpkppyKq8zKXJYUnlH4VQozRjxxVLzGLaof2Hdb9owwVDj9zsHZe4/1/Twx02JeUTGw54nzQmmtt27oZYzDm4Bk7UqJJiNb5U/C9x/XaRt5oelyvV6sSEQMT8T9bAiaC/vtY63FuNGORxebvnLKAwbpeAWx1ZkEXP9zx5UfVGnBYmXrLtm9Iwwy4hoQus69rUknn1EUnP6/5rEMaF8tK77kZevfsSudlDg6GMdKvliHGBhRGq2THvBsawWDjglorpbya1v7nvLr5yVtbNq8GgM0rzyi6WdeYMa2cYsy40RFVUbVJNEZKYwwBadBdi7rkSUn//oQxVf9zyMF2Y3g9jel2ymLzd05ZwDDaEf2FTf97//Bj4I7m3ei2RhAArgHXNLi1Z2fOOzf73DanJRr5m4bdqfaChmOMr5mGXbQeik/aGAIuJ+aQsYJiAbCNy08byDRlBzu6Ww91JvI0xCdwxo2OKvtyYeVrqqXzgACgjizBxzz8TspsEGacC1oBuAbCAoIo+8Y3w1wh4OhS7urOW/6883pwWYR6x3Bw+b8rvUPO6X/hqcUzcm4udGILXtY8qiQRxI6UvYMBYNPqDhlzq8SM+yzmbyQSHF2y9DUv72tezqMeS4yrTWY4B1daeY5iX0Tfls5rBYt14nN59bWU/7AcQ8AE0HK0DNXf4jthjlrAFgVd+vraX1SDvqM4uLwtA/fkwdPP7T3/6P7jGbIw/sd5WX8/7H5j27DPzXJyBI/A3bv3JvhPlTlG0XGxb2B2WEhhnpqNoCNiWPUZBvxiyYUZfYmt/OqoZxAtB9v/64zOfLjg/1faf1yE1KsBJIPaU2QchpjTBBwu0nuG+7Zs3Q4tbCIORjDs1MHTLu172dLSMgBgnEWyD8ouFFtI7ji2fXqZg+fgzCLZXZLdUlCfJHD25H0qKz7o8l/1eevi8TPjJ2U7OpBVavyMrS+3FV12jEgh547W6ay80FUh23DGr1z78B6wGq6Y1g2fznd8OONv4ZZ9NUDzSuYsq5RdxDQ8Zy1gG69qTtYtHG5eD1thHgOIpFwZzKrc5UP/8dyRMwEAWbXpTeh+sTEQu7Qfn08/1/wqgTkhJ17uyH8Pq29P0pZF2JaTb3HZNSX9Ck11ALE24QyfnSvV05KM9dsrzu2GEKJc9CmlEAJjzaOZCW/EeEM6yGsKSJU0kuFGk1YgtNAGDTDkCMQ8EwwY0WFoEzZCaROkQyO47VxmwJRlPHbd4y/GLLeAbcYIA3bq/GPWP7oZCggLONSVe9EvNAs+3PfORXq+DemWU614VXmw3O5GAjrKiJFhVD5oHXAKEovSC1OYnDtXvexOgExRX5EW/13nnJlXn8irDyE6u3mLZHfWyDdyXA8Anj4/HIfxgJzRRjCvtPcAq2kqREjAoVTnLFMcNESKlMPkLL/ABm7/4JZbbyk6I0qUSGpyDGUhyIGfBT/HVQ79JNcohOAcibECaM018BqADKhekATkJCFzFkZVPOKBM+cI2F71cs2iUuctP/UXj/4NegFGBNRxaOLJ+uQV7LJFcj4wsMEqnwcBHyExyBJdqXR3TWYbJLr6RF8/7+vH4R4o7hhiW3qcnb2ZHX2509IXf+fkz8wt9iUCgKJ+ZVp8FSGfEZ902HUj6quKTpzwLQn2k5zzPoQ8ABC4nj692hVxF7LJMaY/AYelfWX25cIYXann4qHfyEqfzpof/tTwM+99+Cvzkk3tyebFqfaFqdYFqdYmp67eqZFMzJphPvxQPvfbrStBrKGUSygZMCAePrTmoEEReabSSY5XNrAOVA8IAqg5npzWeGjHFnCkZvGIxuUr6hatG94CBDDAYCTh7WBXOn9wXSeZcKSUAfdq00MN6e727MhCWVzoFhcli7UpP8zrYwCO66QS2WQiSLr+9R03bey7fEn9vLnDvhaePswXJzv8TgBw2G11zll59dGC+hhgJDmLvKz4UEr8b/iE0of5wSJkJs40ntHsGza1DMmYcx5KeFa1w2ZXgIaINua3byrs2FTYEX0+J9Ovmv+8jxzyxlkzxrv+1CNBn0pDi1OFB3VDYQhSLnEkS8MMiFUjuuUrS4AEaABSYBygAmDzOXEJ3xSCzawby9YsIsELl54JhsDYG4aMMUN6uDvo21Ls3FDcvqXUu6OUHwpgJODhgzS6AE7lkXRU0g1Sjko5AU/l/7T+hjniY6n6kowhQ3n/5dVJGYoZ8bk65xyB95TbPMCWWueFUfYFgGJwhtZkrOJj7JKayRxczcOqSDTICsr95iYheISFQvJH359Bd/7WQsf4V4eCvGRydswARKSGVOmaXgbKkF41T732FXD02QnyDATasi8HYgBgJ9AK9YY0zAFdINlM9SeGMnJzMVEmJuCxg8c6os9bfEqNyET0WmiMflo+4PlA5ANeCEQ+EPlAeJo5EQJ2uUm5QdINkq5KOeqqrmuLvjdH6CQ8j0qp4dILDeWir0p2V51zdop/ReINdc5ZDrtxzNuHi2cqpUykoDDGTKfhaqGAENW/nE9mwkWvlPnCZ9P//Z8zxfezOb9jwn2Wptp31Qd6xs2TgzcPUkdBkJIuQFuq7pDky7/ZetH3FqbqOJWU9ULbXi4h+0Y2EAAcoJbzyMlU9BIqSq6xKTxHLeAoap3M+QtPKQuVmtHsSwREnmIjvmVfXgj4SMDzgeAEoRHsIiRdlXRVyg1SjtoJm27d9OCcMoK11lrrkteQL507dkqFUlZ+vN69kOOmMS9pU1/wjrTvDbMi44E0e0zhaKuoSXTZIiLo7yfGUj/5YfYTH8burunuQjNmc2HnhDvMcxrtDjN6ErA/c+DP3QK0NErWS7kgxVqTrCGx6qX1p39xSf2hGRZoDgYBCDD0P0NkmwB4BtovgjCTNW79O6cJGMdo6CNevPS5LorRsmkEhuy2MZgPePQx4nOj2SgvtNSpsgUcJBPB77ZeY7SeO0awKesPqv78Syf/xnzpWM/P2VSdePzMShrGifpV7GoZBwA4PIyCg+u6N/277t1vTVx9FRQK03bdWQpKHaWe8a+mebJR1M7oGSD0EZY2F4t3DgoKhDCyPeHMTzoLU+TyoWc86YjW8+fJpQ2MAIFGG74Ra1hg4zsp2czDLtox+851C7ja04YxzvmCXOuZ844fZfiObuRRUCH7ikIgRgJRVMyBiBHMTTJhvdBBylF35+/dOtA5RzyrFVeb0VoPDJ/sBQsn+cah/Kla66irIB6TcxChq9aajCAluS64LhseTv/ip7X/9fnkbTfzwYFpxUxEZLTuKvb1BoPj96mXuRymdCWzYYbOAJaBB/7Rz4u+ICVzXM5PyflJpz2piuR3q2KH7/WqIJHrYi1FchmYiOFbpmFYCvzzmDsHK4kBwnbRjvsPzmkLuCJDGhb38kuXn8+AgaHR7GvtYPIVGwlEPuB5xfMBLyieDwQSuAAJgBRABqA269XWlrI5P5UIjDv8p6dvhDnAvmHtkJ1AlXL6hp43mTcacvqHzwpzr+L0yDnOwWUCTqcpnQbXBdclx4FUigd++qH7a/99Tc3jDyWH+gWZacJMxpiOYk9Bl8bv0CTqmAEbWJmJkeDq5VBm5G+9gpRALVtdZ37SWZBkNdLrUV6v8nq136P87mBEJzbivD7IMrTBYDR1aE5C+gBjVyI7Fq3tO1o2P07C2s+YMe0Iw5KJkH0Z5yvqFn7s6Df84Om/9JqhSvoVgUFLxmQwH4i8L4qeKDki8IVW3CXkSCMAhRGxc9DZ1Jnc9Eztjk21gx1ZbyTR85wRrbVtaTcreSX6i0IaNsZ09V3cWv8TRP1sg1xIvl2rlZP0UsaY3QRsGyn5tbW6voGrgFwXEgnI5bCmBmpqWCbtGOUERWRpNTCoBoYCQyqZVo2NJOTB+sIb8lsnfHWebNBac26MMWzGmr9AZMikz0kFT3TLNMr5STk/6SxIaY1et/L7lN+nvB4VjGhACIBtgYbcknzqdQHmwDQjZBGROIMwL54LwXlViSW+7eciAcPoXM2wq6VW6uwFJx1ev+z6Hffc0//4Fr+zSH6ZiQNEYkXBRzTvY8Sk7gf98BAvdWW7e+XmraneLenhrSkaToCSoAWQOGfVCe8962V2TqFZzSvhmcRyo5RCa8PPEZ990uGscMjCy7sG3zJY/DBiYm6y70hJuZJJzubyxBHWJGitdTLlHXZ46umnwHEgnYbaWqipKT9qa7G2Fkol0dUptm1LbN0K27YpbbylK0rnnKfb5h3gL2yM4cAWuq39wdCwGRWobuF1VfN3xhKwLdRMv72hUBiWNw7IBSk5P8kb3VK/9nuU16vtQ/lgGNjf2b05k3m6UPsKD4AYlGvSQunA0AKO/c9TMhV3lmgGDXittVbK933PK5WKxVKp5Hte4PtKKyLqLPV1Bf0DwYiPQZAu/b72D90120W2BJmSTnmU59DlQmcCuhPQ40KfAz0uDEswEpR80WFnfvpFb8pls47jOo7DZ2+HhvBMqiDwfR/0k211780kH9ijg3jB4f3Fr2g8n81qmX4iGPFU74i/o7+0ra+4ra+4Y6DUM+y949ylJy2rm8sThw39aqWUUkEQ4M7tdf+6uubJx1ldHba1QVsbtrXBvHnY3g65HOzYAVu3wtatsG0bbNtmN0w+n/+Py4rveT9IeQC+rZ06PM/zvNJIYaQr39NR7N3p93Sa/g7T12UGX9V43pmNxyfchOO6Uko7A8ysKxL9jaVikV/f3xZkas5tlsuyg095A48WBx4rDj5aGniq5BdIMQgAFIACCABq3+A1vjSw5GubxSUSCcd1XTfhOI6UksUNOea4BQwAjDEKNQOkFErZRF5OpLRqduuanFrrPf5e0w97Gp8BoZSjgBkwCCkNOQVeAIqBQlAIHgOfocffdPIL3njyxRzRLoFnrg9q8mfSGsGZxL+bMu8WvGNPD+LKJ1rli0f8d+f1ZwFqZuu5uubRzt/fs22wGIy5Hbb2FU5cWjvHJ6NIXb72auuGX/Ea2d3VsHljbamQqMmV7eBsFoaHoa8P+vvLD7vd18e2b0988qPmhutK3/sRLll64Kx2IkZYi5mUcBZBEwAwzh3HSSSTM/pajPmNxpjCaY7q82taZDBivG7l9yq/V5d6lSqRYVHRBCCAnl+5uWMwu4qFTTjKrTiEiM3fmICr5FGpSxNSSlPhS/uqNuXK1D+l/n6tvBGKAhzbsAeAEbgKMgEUOZR4+W+J15ia9x5y2RmLT6DRauOh0PEspuGc+41c4tMIam+PoTPONxLm38PqG745Z5adK3sbOBwHCsH4V7f1FcMpby5PTFUO1lop5eVqhg4/ihPltKpNOLlMLhEo0dMDfX2jOLi/H/r6tOcFAHTLTXjhOeZ3f8Jjjz8AZzK6+rSTCRCNqnCt/J251wMi81h/qnT/lnVLnYVBL3i92utVfp82BiwBRzlYa9jxS3nklVy6jrWAbb84K4gWZ3vEBDzOCOZCS+kYY19SjKFSZMyTuPY3zp9Bs+pDMWAMGIOEgWwQEvAhdMh7V16xJLdgrk2aCMM1zrtS4pf74QZij9c5Fxb0u0bUZwHqZs0psn/n1yewsoSLYnt/KUzTm8uNKKI/3FTqyjVAL7L+wLCOHleKJIlkfbPLZIIw2T/oDo9gXx8NDysAbV2gWzb7l1wk/3q1OCAcHApcCyHsx4U5JbOk2rWyyLDrjLxXerTwdKNpol7H61FBwRCOUk8IObj/ISxtlpkjXek4stIrPW4FHRPwBEawEMIu9iDSVY1zXtKl7wa/UgqAcWA09iEI0hqKCorsBaUXXJZ9fUokbTdyDKXnZ/WtRkQCn8rJN0l27/47qk7xb7rszyPqa55+8ahGDjOZfY0xDSmecnneG5sc3jXk5Yt+KiHn8tw0oWRH1c3LGGqtlSpxPugmWVuatS/kpz83+dLO3N13Zv7xd3b33cr3yjHIzo7iqy7N3XCLWLho6s5nNYtTCCmlJWMAYJzboG+UbGbkZa1Y9mGdCOfcaB6YoGPBTveItHeHa5RNv6ryblnMF4AIBlfjvBNcKaRtAj1ne6XHBPwsRjAACGuCVNL2VBBwpa4evnG93jzK/I0+AgaOziQTl5feczY7N7xNy8Xms11ujYgS/I85cQXi0F68XekUkQAQhpJECVtNTZgCcAGzAELiLQEeo2nFTD97YYFN2sG6lBhPwENF1TVUWuRwmquV0FFfbnkIaW2M4URWp8UYExa5lXsuITLGgvqGkYteIi65NPHMhtRVf8Y//l51d2sAf8vmnje9vvmf1zPXnYqTGamhEEJo63m2ESvGmO1BYeUmZuKiKvTEhOxrFxkmUtbsH12g95XguymzlY+xfcP/Fjugyr6VRNSYfWMCnmAsAecQiQoHnAf+yO9Hril7m8c8uPVF81X5w9+x9oOLSksYZ4ILLkSYbiCl5FzMVtE1Ip1gP8uIL2lqJLPYUEIbV2updDIIHPvwgyRjI8sW/A5xrHJCR89pT67/IGKS8ZSUKS5TjpOSTiLqqsLy5DXjS6jDAhujdXNGbuv3xpr8hnb2FxfUJwHRNtOdoxaw7WAohKikXwSIiBjNzAhtYkS08qfImNZaL1pc+uBHnTddIf7vp+pnP1b5vH/n7T1f+nzT57+03++fUOqac27ZyNrBIQFbwrK3MczMsR/6nC39Oo4T1RRCRKUVHKITXxrRP0r6tzvjORgAsgtEVPw5Zt+YgCdeelvHEURF5JHdOHj3Nq8bHA6axj4UAaNLOi99bccbHHJsCHkU+zqOFHK2pvzZkVjSzy/4L1ZKBgpVoP3AD3zf8zzf83zfVyqwIbyG2ofrck+OJeDuMwqlZju2DUlJAKAA/Og+HIAirsgZeg5DwrCVWi3Zifl1W3/xeK0ZY3M2BhzaWyG/WvNRcV4uqB2n6Vjes5K6JYyhmlr9oY/KS14afOFz+tabu7/+1dQLL06fdPIUcTCvrNrL5q/9bhXeEqKsODFDV5DhIkPKUX0VEdGv5JfprM68r0A5Gv6nG+Vgu2vb8U40GS1m35iAd8vBo9dodww+BKpi7Nrcq8p2wk++e+c7Tx86gzHGRTmJOkz2c1xXCikdRwgRxjzKAWaY8fdfmBSpTbPRWmmlVBCoQAVBEARaKR0RoEfEbR3njiFgY2Tf0FHhaTeVVobV8x8ZrzTzG5aFEsfa6ObMxMWgz3QX7T7I5qIiRxgMMgBVVkMmhFBKWeeBqaBaXxCScaUXSPloy1emfv179dlPFX/yw+0f//Dy625iQuzfu6hMugC8QrcmoqgaNkWe0axjfwURWQ6GioJv+AODABFRa517c8nLM+8WGY0B17az1CF8wpk2RkzAE4x/G/moeAX1mp5NwDgoU/U8KwaMJTD90e73Hl86jvFqCdPoWjcppSSZ7+Fbtqt16waeeaJvx5reEb+U+cmpX2xJNMwSI9gYrbVSSlsBBTtRVlyFNpoOAJ09z1217MeCF8P3DueXlEoLbLQvOj2VWUprO50ZY2aNRRhycGOKjb7xIONgfUq05WSUWuasERzai9a+1FpzLmyTjyoBGxOez3J8PZLpprVGpRBRrDzEByjdfWfvX//ceOkr9i/7hjZ6aK3zaHH3zJdWjf7G8flxYSuFIEAE1Kib3lPwOzL+Gh76n5tPZSCrV2dG+7FiAj5wN1x4i9T0pMFBaOBAVeczanpf/h0neMczzjgrW75CSsu+ItljEmt63Ye65AM7+ZrttLNrMLnTy3R46Q4/0zGY+dZTv/rPY94zc+/CaFlzmFsUdQ+GcSO7NkZEX7X19J/Y2nhbeJC+weMZl6EO95iWsRDpTDfLGkkZY+oSuLyepyU1JKApBQ1p3pR16nOpRDJpGYXP1bljFKshAiInCpdiEdu3yrt2vTa+567RWjMmbrxBAgwCbPvqV+ovejEmEvvRCItOF1GCGbOgn7mWnzdigrwJ8hoIdEmDrxE1dwwqcgwwxpgRDIAVIOg1fKehddhc8oYgZSory/pzym75mSvGGRPwgZ4CqlaIoRcvPeeumx+CIQYtHGoMSERgryu88rTgFF6p9XMcZ4QPjMhnfOdhJ31/Q+6xRKK/HyAPQAAphEzSzya9fErmS/5w0f/Vxn+8YemLV+QWzVyHTHmWifoBiaBisoRxI621sX+13tH1gtEEfJJNUbG54iH72kyWMcUbs2zJnEuwt5yY8jxPKwUAjIMjYJRi8ByeqqKMVWY4a2NWRmXUSVBe/FG1YDgaJGZbtyTvvCMLkAfoeeyR7n9e3fLSS/cvHY7h1/Hm3Qy9dYc61R/fu3XgaQ8LhnnkELnKZLRXy4KcVFnwc+hLCcQE44wrhALTimlgOdBZUF0gGVB6MWRWYXV+iM3fmIAnb97ZNfU5S05ecF/r1o4O6BeQ5VAj3Rx33Zp/mwcNhzwrdVKPJ7aSu74p3TcfSvOdIvNKbQ6mGXkAPoAHkHGDbMofKfmZpJ9N+YVS4confvaDUz47OyQXrDsqzAW1G6GBYrVkgyDoH35O0WtJup0AEKiafOnossMgUq8VJt2wSt7k7CiKHeu4q/xMwxhUTKgxP3Mue6HHEFt5SFpPLxGPrvxCIzi0hbUuB0GImn76I8qPZAByAEWAjT/8XtNLXjqld9TsuF5E9NBf+9ffMuIC2IcBQDAcCI1BTzPQCNqUbLIVJ+B25UiAANAAqhsEADScDjhnnTkxAe8TB1cGt0TxxiNe/IV7fwAGYBih6JS68UfOP8EhkAgcQWJNIliQC6SQWUdlHZl1VI3P0wmVBPAAEgDJshHs55P+SNIfSfr/2HnzfVsvPWnB4TNdHyfsJRVmgYb2R6itHwQBIvp+rqvvnEVtvwWAwZEjCBodx3Fdt1qej2wMUZWPPFsSyMPfJYQIOBeiPFJYpEgDYvtgHJ9F16nRrrplPh5Nw1prrZXW2l3zZNO//lEAKABkrBF8952Djz5ce/Sxs7Ux6P4yP7Qyq/88gADhgwFwoMrDMCAEIEAqvw6VHUEDpoBcIF9g89kQTaiMz/mBAZsdNyIRGTJkzHmLTjk0txiM9QoSMANgwABoAALQNBKIQU8O+WLQF4O+GPLkgCdJY7KyfnQB0o7KJj1Lw9mkL7i6cuOPzbiaiplo0lVE92wQ3HUc2+3Edd2E67qO67puWYiuu++FBAwABoZPEZWMcdd1K+9ynUrxtJx1ojnVkkpWFjQoJw1UEgiihZIQl2rs4n5jEYTqEFyISgWCvXOko3Xrv66GpqYE5xmANEAWIKXUMz/5EUUSgmJM6Pzb8lBx5+MlBhB5EAdilQcHQiAALMtdAVJ5GwmQAySAao6mzOLylYqqYcc3dkzAe3Y7cuRvOeKlqK3aKYEO68wJNIEBrXDQE4OeGPLkkCcGfTHoyXwgXIAkQCI0glNBNmm90F4mEdzZ89AN2+6OdmuYie7BapW+EKOLsNyQWcsysFIWvCNHCocAwHDhZFF5Qzh3CstDQti/jHM2WsBkRg/dMC5uZZPKKw/XdRMJx3XL3vi4S/me83GVlSsrQYnY+ND9gqFub+d1dRkA+8gC9P7xd4UdO2bioDtgk54x5uG/DgDBri1g4mAqeuahBRwaxACAAmDei2FMZmVcAXxgIGbNIA//HtN06JkLjrt124PAKjRsAEx1Ox+IQU/mHJV1ZM5Rg44Y8ERaqhSnEoAH4AGkpcqmS0UlPOIFJfJFeeXqX5zVdkJCujP6/NhY5YSDucwlRFqW5et6By5IOF2lYJUN/laM53J3lDEEP57yZ+69FCb3WslxALDJvfbVUMVFRJpGx7PVHt+HRFAsZu6+TXpFam6m1lbT3u4ODGSUKjuiS57Kj5AxFJPBhD4/Y0pD6vFrhrFi+1YImMYYwVC1eqPUa7chcTg0noIVHwWPl5UxAe+VwxBZ6PO6fNUlD3WtGdJ5YAAagVWMYINlI9gXOV/mfDXoyayjco6scVQ2GSSh3JwPEQqJYPtm3vNYpm9drdqeaVjQSsoYbmacUE40LLerr21pRgAYY6QpS8gOFs51Bwc5T4a9YnjE0p39RhtjVmKCMaa1HqOaZIGzVzl8qsE3b8r+4ddMCrNwoWlqwtZW7O4WHR3pzs40QAGgdsEC0dw8Z6VOJsPBa28dHupQMmL7YtkFbaJGcMV7gBM4ohtwwbtJyHBocxbf0jEB79maOjJdWrQlGt+88iVff+LXlV6XFGFiAgOFQAx6IueIrCNyvhzydN5RzQnFkHo89uSO5Oonap56tK5za04Pu2Dk/Lrm/3zFGxniDF2PT+YLM8aAyA5EISURBerQjr532RCvXd3MnZEZlZhgFSYOT1SobHDA1iIIgFhxM47bgMo27TqqZGdeBLBNxMpZEpVtim4TTKnDl4ic66/N/ufnqKVZr1yJNTVUX0/NzaatzbS3u/39Gd8vANALXgTSMcawigs6ZoVRFrDW9/1mEGBi/zOrcDACRC3gqCMaj0PxdnQWs2pDmkpZQ3y2YwLeA9suGldSQnClnrfo1Ls6H7m3//Gy/1kDMAIN1i+tFQ56To3QeU55bvodNezxmzsTj3Y5jz6T6duUho4EDDpgDCSDGid95Wve2pTNWcmnCcNRWwo7P/jo11oSDYtSbYtT7QtTra2JxkanNiUSM0XM0i5lyv1iSNgmNgAJFjF850hqRlTrdDKqSft+QhCAYfkvQ2CRDcSKdxHLe07hzD6ahk3lr6FKJKfy5F4zNBElvvOt3Mc/DI6jgbC+HuvqKJs1DQ3Y3Gza20VnZ3r79lR9g/cfbzBGh9IQMR9EnVVENNwTcBdWXejqYa36NeQJ8yBLJDxiqmr+IhABi1q9pgHNYYzOYfxEZLzi0QldXLEFHBPwnnoLq9lFUgqltBDGmI8c/fpfbvjXrd2r+80IGCpbwBoAAQyWBOuVOqjNr20ZHKzN95XAdLkwLEEQ1PsAAIJgwElh4ovPu3xFU3sorYcTqS1uK3Y9NLAm+ozDZKNT+7zW0z5x6OUzhXIYY1TpGCMlacbAtivngs9wmdy9vrWitTQwkVjSHp0Qy6McgCFwBI7ljZCAD/JPhkhpFe6SpEM+tnJzlQTHSvHBbphDKefD709+/zsEwIKAdXRQYyPV12NtLTU2mpYW7O3V7e1uf//wxz5JDQ0zt/Rgyi1gY9wsXPqtulKpVCoWvZL2ioE/olVRU4mgaFiBmZLMe9zzXDBICo2DJs10I1ILQgYYI9vLKwwwlf3PcQA4JuA9nigr/mebrmsL/HOJ7NsOedkrl5y/ZmjTlmJnnx42aCSTran6nbVb/t72587cSGfKB0eB0CAJNCs7bAyAQghYghKfOf7yY+atiErrhWMgqmm3Ob9jzLfyTbCj1F1QpRnkPRvfsg0AEFnVNzWX2HdX/538ScAK0YoK3VrGndEnEaH8Q8YgSsnhw1Do6ybq62WXX8av+acpi0UAdndjZyerr6faWqqpobY2UyjgyMjG5547eMHzEhEVrZiDR7GvPSFIVreu3HsKDUtp7urwdGlADRyAj7l1EYFhOWXGep6jSR5xCnRMwHs8UYY5q1rrkIEtZdbIzIl1h51Quyo0Zfpx8OOtv9CJEhgGngRCMAiugpwPAULA7F/HuB9e9sbj2lZFp4CoSmpUYWA8AVsszywIqXqa39Njsn8R0UbfwpyjuVnwukc/OaRbMVvodo9+OwMQONZW1gSBgdKmzUOvvDSx+kENoMN0oVKJrV9PmQyrrYVkEj0PH37Y37SJ9fY333m7RtTSKbS0ekcelTjr7PTxJ8Tz9RgOHtNzcHxMJLpwiU6VDFlY4G5R9nLF5m9MwHttulXqRozWWlaUZqGi9GRvRx/9L9V+bafuA08CqXIxug2OuApqAggQFCZ1+qPpd5+UPjbaXQQqgdIxI8EYs7mwc8IvtsBtscHUGVGsUs3+rbRVD0csMhYHh3bDuBJBsHLsNsYYWzlY/UDnq17FN2wQAEGoF5FOw8qVeOihYtkyCAJ44AFcvZo2bDAADQClyiMAyP/u192cO+ddMP+b33EXL5nR5+SGXnVomi1I7GVe9xhPQDQAZ0crQ1b10o2O1NuloKVYUZHjKQvvhK3QZ/IAx/wQ63hGLzsmJuCDYKMwxsg2QjPGcRyKNvtUymhtyBDRn9g169QWYBXSLQu0ESABI0hoqA2SQfpjQx88XhxjuxdGK+QQsTfoumXnPVdvuc9B8e0TP+miVFptL3ZNNDuzZllntI4Wzk7/k2nl9FllI0zOiqk3JBWBIFhZ3jRm3N2j5/bbH3/JS2RfXw2AcRzW0CAPOUSccgo7+2w87TQIAnjoIXj0Uejrg7Y2HBiQvb0aQIx+aK2L112z9lWXHnLdTU5NzcH9Rdf3Bgh4fsMeT57/vbH0t67gxhMy+3Go2gRmO06jYbIxVP1YdvWRw8dFhVCqDdGlYyVmZ/oiW97yO/7kXeqYs9WZLyc3FRPwQWAOqNyOxjEQCWoqpYwxm/S2v6obQHFgBMgA7QYBsjIlM8o5mY/2fO5oONaKLUTVB7eLe+8Y+ftNXfds6PW7B9KFknThym8e/9G8X+jwesd/pVqRqWNZrfVMaVM/RlWfiDDiuZq7zQYAOIJkIBnIueRV3lco1XPbbfe//OV1fX1tdXW1TU3Jtja+cCE79FBatgxzORoZwWwWamuhsRGam6G3F7q7+eCgUGoMASsADuA/vHrdRz9w2Pd+fHCH0sIEO//BkcvmuR9Z7GbFpL7GoKKPrC1e1RW8rs1Jsn1tNBSR+eRSSmt+2MzTsfGyCv7U/uuO4R0X97/CKslUMlZltMvZzF1kExFfcy9/8i4AEA/fzLat9c99HS08NCbgA8cc5WafjIW6+VH25UoZrf8y+G9fG2AV3mUR2xcBkOpV/cfWf/aw0pH2BrWig9wNenLXrM3+6mn1YLefFqlUvZ9SminD/rrzxqUPL3zJorNGID/+WzWK2hQ4WmtbwGOTm6b/Lb6bRN85xcEiQro8pty94N/OTv7Sl541OJjK5aCmBtJpQjRDQ2bHDkwkIJGATAayWWhpge5u6OmB7m5obsaeHtHbK8YbwQAKoPB/P+255NKG8y88KHejpbRDUuz0WvHDbd5t/cEXlyXOrJe7f8uTef3eNaXHRjQAnF3Ho/mbe/cTQl13qEiz6fFdliPhYSISXHy77b9P02cv0IsjSjKV/OfRHUVnFvUCAAx2Ozf+uup67Nme+OOVwSkvCk5+EQo5nb8///CnPjc9v9n2khEIctIOvmiMNlSf5bwcvBSc95uhr/X8nw9+tSMIQLRBSEvQ+qlnPndI8TC7OnQcx0kPm6Y/7mz5xI70r/N8G0oDSERoiBExY7Dki7t7H+spDG3UO8Ynah6WXHxe3Umhz2dGuHei4eox+ZBzgX0ZgsMgxSEjIC3AZSCmjZP5gOUB76+fa9LpkYcfrnvySSAizoFzEgIYA84xkYBkEhMJSKexthaKRcjnoVCAQgHyeRwcJGNMqOMOYGxKFwABDD+8uvE/3oBSHuB7MmpWSsR/9KiegP7cGQwrOj7HXTaxwus/uoPLnyxuLhkAyAr8xCKZ5jhmrO3F4hjGNr0os6kUQkhr2pajvLYy5JbUdU86jz2TWPvS4FWOcKV0rHePj1Zxn4nsS2QS//gB69k25jW+9Wm2dY1pWQzpmuk74UzpfLF6SAd7NW38vTv46Loi3/O7ISTeSvsAx3UTiUTCcd01weYR3wPFIeCVvyz8b4PX+NmNn19eWmnbtVCyL9/4Q7X4Emj8khQb0gBpgAxAbdKvy5TqMqW6TLEuW6pJlUjov/fdxHxIO8kxp7NF1FfXpDOqlAInwuw2dlMcaiXUS6iRkOQgDuzPpUk8ps+XmexZ5Tz5la/01dSA70OpZB/oeTA8TP390NcH/f3Q2wsA0NICjY3lR3Mz5nJR29dW0oTb3pqndnzrfyaMdB4A9rVJl2fVYouDAGAAvr/Nv+ih/K19wZgvQ0Rf3eRd/mSxvzIJHpXGJlHuxjjKgNvz4VnOi6xMdE6ISleVsNGZfQBjAHCve8f3ar4e9vWybVRmtPgGEYkHruebHp/Yvty+DgrD07mMbQotYAS4ujv40jPe8TnR4OzBpf3mFu8ja4sXNIjzGuSe3pfVdSUiqyYwM0S4qev+e0YeBYBqZ8xy+hUkuPxsx6eW6WWCiyHe83TiT5vS3/CS93CezwgtWXUBDgggjAEwxIxBIhZo7gc8aZyP5l53TvK4lc68dt6U42mHyTOzR69ILZRC8NHd+mLn5LRYZAA4DJIVY9dhwHHKO/zSHDirUbh1dYOI7r//zY0BKVEIkBKEmMAILpWgUICRERgchL4+HBqyI84wRowR59oYHTGCl7721W5dLSHQgYrIV+t+jJFAm0r0aL58PXsC+lNn0K/o+BxPcCSi/oDetab4851B9AivbGInZiCcpPbFCB7VY6pCxpZL+ei2ChbXulet5U8BwIPynhPp1CWwPEq9M9G/VabVzs2Ja36ERk+4T+nki4LDT4PR3Xqm19J/Sk/QJc3yP58pvfChkY8uSbxpnvOsrrwhZT62tvTnrgAALmgQ4+WHJnN3hsWs9h/7XmNMquBCP0ItB24FAhgYBoZxgCs6L1+sl9zvrXmM7u9xHqjHwVbhEXckM5JRY9LPMgpdYVoYlSkpzQLNlOZKMwPYrwZ/tulfXzn0ilXQDg4wxqUr3URiQu9ujL2Bpv0SiUUAycBlZcadiVw7RUfGKfhuCFD73vf2//rXzY89VjaCi0V0XRoepr4+rKuDmhqorYVsFpqboasL5s+HZBJOOQXr6px582RLSyaVIsbU5z7n/eUvvQC9AAbAGxp6+oPvP+WqqwBAGfAJPAOBOSCTfkWT5+I6+lVn9fcSwE+2+7f3qy+vSNQKfPea4lN5M+ZUnJzSShHnnAPsi6T8+KjQeOPbTnpAZEb3VNagP5x42z9LdzdD67PSkg/ew+yBw8xRGchOR/YtDieu+xkqf8J9gtal+WPPF1qzaZx8I6bo7NiNBgEXNck/dQafXFe8vif43LLEYRm+q7c8nTfvXlN8dEQDQIuDh6WqeQp7dPrGp/LaNeDFK87+3SP/3NC9DXIcMggJDlIAJ6kTd5U2/Nq7q48PJR09L20MOoIZyUgyIzk5zOQSgUKwGgIaQDtaZUpKcUIkDoU+p7g6u7anu699uCVbAwCMMY5cMDGmbjjGXs4433iAXn841Cf3kXcTDOSU8S5NgyMcgE/HPTxmIpHI/8//FC64IDU8TIwhABkDSgHnkMtRSwsqBVpDUxOccgqcfjqk0/a9YTzHrF7NBgaSNTXO4KBtbFYE2HH11X333lt/8smCgQBIcVAEvplCJg79z1Zo7wjXHJLENcVR+6wtmFc+WnAZFMaZZPMcWuForXlY6bevg2K36mwhB4cF/SG2s60fc97xU/8vu+HdR9nqa9nfrmZ/OttceKw5aXpawGzHM7x7y4SvGun2PedlpA1GilCmoRG8/13Q0dgMESUZ/rlLAcDmkvlLZ+AyODbH2eizQET/6lGXP1nYVCrfKGfW8kub+L7YjlEhXztmOLAVNQuuWXO7zhsYZjAooV9Cv6uG+c6gt4glAFDENCBnwJA4AkfiCIxRglNaGBMJg0lpREr1dSTX3tLYfWcN9cjnH3LCuauODrP8w7CMDdLMhS5+U8W+v3gcv3gXvf9EkHwveDdMqkpxEGx/ZlTRAX/jVNE1Tu0x3KVL+9avd9asEW1tsGIFHHssnnUWXnABnn8+HnccLlwIySRwDokEOM5Yx8fOnf6f/gT5PJRKvK9PEwUAPkAfkayvbzv//HBPhiAZJDm4HBiW20hMHQEbrYYU3ZNn4y/LhIkvZ6b1hVllKzNCz/CUesWi9vo/5V/XiafCl9azpzMmewI9J/oFfPDuY3f9mH/rs+KD/8u/ch+7swlaf+j/PgGJaUVdYShAZRtKLUt49xZeGhmzT9exz8+3rQjPM4zWU5r9FnCIkzOwNInPFAkAhjV9ZkPp333B55clQ1OYiP5ns3flJi96056WRWOrdyqNsfbahxAuBYwxhzUse9+xr/3K6p8BIZApKz8DgUFQCECAMOzJLkZVC5iR5MZh1MZMVhqropcAeHpQ3nlz8+qb2rzBBHCdqeGvPvnM8HqHCquxvOq+3ktr+9iHboKkJATYk3tAICQ4OGx/plPRAXgLTe33mZg4aY/23oMvY3fnAJn/+q/ie97jrlwJmQxyvps3Rj9Bb9zo3XMP1NebefOwr090dmZ6egoABYAkQDAysqtLLzikOQQGPAOeAb0/zlTU32vl9s5JBd9DXqJJ3WEnJQKtza7aqU21yZ4yY4Up/tv99EnF046jk0tQfIDffS372y3shvVY7SiTgvT3/F+nKE0w7cR07Q/TWvvNS4YueGvu/n/UPvNg+OpA64ruBUe5SmkhbAs7NlEHnVlLwNHFlyB6QR3+b7F6z93Wry9+KP/+Re47FjhDij64tnh1txozfk5MG60rbqh9PneR5AnzgkWnbxnY+duN15YbqGqqdFUl0AhIhDBQkg43DjMOMw43DjcOI8lMO/PaOD1R4n9dk73+rsaRjWkgA0kPjHj18We31TTYTIiqyoyUcYPrffGjQEmxK66FIZ/qElYV5FmrJzmCU3E1HxTepf206wFzRz/rB+EkaXbXByeA7Pz5MH++mYSxXY2qXnttcNNNsGgRNTRQczO1tpp589yBgYxSBYAcQMvRR+/+ULaMOw3gG/A0eGa/nVUi0lrPY+r4RHBn0XnW/ZNIxzueMXy8luSB4GCtmRnrPfKg9D73Tafrc24VNzyD68a/9xPelw8NjjBowlDxdOCw6GRuHREBE9uOurA/19b+1C2ON+K7mU2HPJeFPSqmd/nJFFrA1vWhtX5+jfn+TlCRkzCs6QvPlG7qC4YVPTIy1lG01KUFXGldLjPH/fet7MYbD724t9R/fce9Nh+xkhRtLWAEBAPYW3RC81cycpGySOuZubmAf96Q6duegqSGBQXod2BArkwveukRZ9lCPKsvU5bQChVWY+fzXl0v9tk78N4d1r1o/Ri7mgjCEK+zn5zMtH/3pIPMslN3KnByrGwmOtquk398+tSnzPXX49FHY10d1daapiZsaUHbLbizMwXQmMu1vuAFkzTaXQYuA01lGt6L2siq1E/kxtNaX5wqTIaAs8wwMgB8TA7zAbh8xhhDhmgCf/w6tmYdWzPhu54XvPh1xSsMVt2QMM280CG/2JZQPc3L+5P1i9bf2du83HdS7rguFHOIgEMS1lorpZYKfWxK3J8fexbuGJg4d/z4pAZjtAbrN9gv65doTwVEfPfhrxoJinf1PRaSLiCV5cqRACEIWE/RdRg5SElCJfWtiZH7UA96DmQUtBUh4YA0wEBw9o5jXu5KRwghHcfqVtoaeEvJ5SBEjD1cwOFV69i3Km6llDAM0JjxeZscwWWQ2B+Vu7S/dqOZyrX766RNzMr4LO8tv75zJ112Gbv+elq0iPX1UU8P1tZSXR21tJieHtPe7vb3p30/+853JubP36OvyhFSAlJQztXyzLM0MB4/h1QrfxABQAOsLk2qVLJL8ys6az7QHLwweUCDkVV7kfTk39WuF3xu6KuKlJ2BOQBMJxMibLEzph+Ul8w9ffiFyJhkzGogVpuoTlcf5JTUAY/OVlBKKU+b2/KTJfvL673FDlXkXbjtZLB3HBaqstnVkqkItiHBiY2rnhnavqPQUykIxvIcgGWpX2W41oxS/ta2wTtbB9amfc8xkNDAbSs1sn9f3nzx89rOkpVieOk4rmOFZsoyb48PbUgKNykSc9oIJsDrnsE1fTA/u/tcqvKI2jjAX/l3LJRjE9SUUpcdjiwqc4YOgzSHrAR3H6ze/UO6NCe4dp9WwJN4CgH06tXqJS/Be+9FAFSK0mlKpSCZpGyWEgkslbBUYtu3O4cemv7Zz9Bx9nLWs4s2BqxSW7gXtlenbz7Wkby2kJjkG4cNu35YdAZ4bJbnnPK0NqVzAhH1Ue/t4qYfp755Y+raEitO5l0M2Nf6frTSX2XVg6ahIM8YD6vWWmlNtnUbY5xzpzIVh2LX01bqSxyAk6W1PjPhZ5kzbJ79x+cYHSY8Y+T+MnyjHbts32mrWp6i5EePesMXH/nJI4Pryl7oiDs6Ae6xmeU75j29ftFOSHlgGJQkSAWOhnoPGNnHMrH4tcmXhMrm0dYijLEHBx/91po/3Nx535F1K390yucWZ9rn8gRMS2rZ2b/FOpcuXAoXLaeT2yAlJ1wwka/5W6/DnmLkea2NBoMMABkmOSb5PkV5aR/3OYCMSwfzok3hr8DRzmgGULr66tJll8m+PrskZvk86+ighgaqq8PaWmpspJYWs3Mnnnqq87//C5lM9OB78VVZxSD2DJQ0+M8WIS57oRljjK0usI9tSWz29/hj/9iHd+X1pxbzl7RM4YXrx9672K3/Elfdkbyxg+3Yo/deNvCOE4dPDVggBAGIaRhADS3aUH1ESglE1khjjMlQ6ouLaA7sXEnCipr8drVSA+rsZOnv+Wev41wpg1rURNWGCrBvTvywJQPnQkoZGsHGmDQkP3P05TftvP+xwQ2dqp8YpZ1ka7JhRWrBYenFxgk+2noDaAZFB6SuVCAhOArqfOAkUbw7eHuCJ0WktbVl30HY+ZvOH/xu07W9QwkC59G+py+97f0/OPmzxzccPhetXzuGV9aZ71/AXvE3/O5q+O5qXFFH5y+Bi5fTc9rB5dGd2X/exe7YPuoIgjQZCZRzeUoyvnf58PuPdPfvnDRtLeZnj/7uj4MjAgPo/853R9733oRSrNIwGACwqwsbGlhdHdXXU2OjaWnBVavwQx9StbVm40YCwHRa1NUxKfeFiW2EWBEUNXkGd+OXthPR77rN5zZB0ezlCdju0duf9m4eMJ9cmmh19ycl9GDXXXjrdezvd7Kbd+L2vTjC0cXj39z5LoUBF4IxxhnthRrSgeFgFs7qjmOf0VoDgLWzHNcVMyEFBztL+3/4l50DSvm+7/ue53m+5/2w3/3J8LPLqWSYeXWu9JZmyiUS1qm7LxW01RCI1kEQ2O/je16pVLL/0Vpprcc38CKir9R+8+7EfSA1SAVCg6w8hAZHAdDr1739tX2XScdxE4lEIpFIJh3HdRz5mPz53wa/sXlwpG8k2TeU7BlKDuddAszJzLdP/MSF806bU77oMXXh/MO3sO8+NGqPVQ10wRJ60TI6sY0cBv/aIF7+t9Fsp+Hk9sS/L02nXbbnp472eof9bebOEdc07tlMCgiw/TOfGfjiF1MAKQAXwIkoP5vmZn3CCbRgAQYBrV+vBgf9UqnU3V3yvBKAn0jo5mZ5zDH1F1/ccskl3HVpb79Jee4iKGkomVFJo+GdHBB8fn3xxzuC/XKi5ifYZ5a6FzfJfZwQtuOWm9l1N7Fr78Hbe7F7r49THzR+b/2v56tFotIITsqyKTl9esmE0g7WAR0EgQoCpZVtOAtErOzolLYjBY/4n6fhYJkqCzjSpoMR4v8OpH8zPCkZoxHDfjSQus8zn5gPJyfYPgbPq6pYjNk+wTBRv8yoPLrFFrb9PvMYBLxq+BJG1eiPLB75ir7XhhVHQkrBRdFZc0/mk+v4TQlwmjDJGDG0DxjKu0P+yOX3fOZLR7/n9ctePEc4mEbnShCR+cwpzu1b8bGe6k5P9eJTvfjNB2hVgzl7Ibtq3TimIlnS2XRijybU/cK7+0KZM9dKxv39VXE37Eu05r3v7f72t7MAAYBnuy8zxhcsgBNPpEMPZdksy+dh7Vp45BF46ilr44ZWMuXzXm9v/1NPbfntb3Onnnri3/7mNjbSeCN70l/e+qWTAJ6GYkRUi4h2eOZ9Txdv69f76zxvK5m3PFn8S2PwqSWJFWm+10OsF7sfwHsewLv3hX0BgBGTqhL7i0zg08p/GxUbBgBho9SKCS4MmYpxzMMmx9Ncg2EKmzEQABF1euYj28Tfh509mkE6FV49gJrwhJyQfJ+yiKtFbNVtqG6Xxyciq+Y3Msb+ATc/Rk9DtWlDOJARADMq+9kNX66nRtt+xHVdxxVDuR8+nX3rMF/DEISjGTe2czsi2HvGV1xpuqHjbuJ0asOxMGfa61I0a4KjPqZZ/n4tqLG5L9hTZPd34PB4ZVctltQnLj9y34lqSkl3/7M1eYBsGkqZ4v54OwIYo+9957vWf/c7DoDLWCqdzixcmH3ucxOXXSY/8AH2nvfgWWeB65bbFPo+eB4OD4/pThieuv6tW4fWrGl/5St34ybBSX9DwSDJQTAwRJrgngH1uscLj43svbgWAxBISQYZBjUCGyQ2OdjqskFFG4rmuBzP8D2eECxZNpvWC9RFbwje9lx1fp2pz+NID+vai29Y4PkNybUXDL7IEU45oFahsWllREbFhsNVQuiRDrNfZ0SbxamygO0i5aE8fHADe6a0NwfxDHxju751qPS5pYmTa/f1DEZXTGOImTFbtK2jdtpDpaeBBEDE6i0bwQiEV3S/Y4G/SJRbakqT2FBo/GzevS0NQADMsnTKZ0i2lUt5A2kgn1CIX3v4F4Nrgy++6C1zgYOjSmTltuGH18LHT0h+9p49OMokEq5oj+ltX7lzat+FACP3UN//YeunwV06rfzXtG/0RhVbc/uPfzz4/e+tct2mmppcU5Pb0oJtbbh0KTU2QrFI27ZhayvU1EBDAzQ1QU8PNDXx3l5RKgkAHelXaB8pgJ1XX732G9849AMf2P1HT37IuQy4xJ9u8z+2pqQZtUswmgQDyUCQcdE4pB3SCVKDxFabCUJsp7ChS2RfirOk4DlXJB2ZcmTKcZKOTEnhynKQ0qpp7ZHSRXRkEZFjnOP0yceYE9+rP/EoW32b++9b3RuedB4zsAcm+wO5u3/Z8qO3D31ACGHJbHoakdFyaoOIjNks6GradoR6p/McO1VlSADwu47g3ev8rn0Ll3T49OeuwDdwQo5Lhvt4taCi7FHuWBgavJW1k82pG4T8L0eu9iEAqlq94axzSuHkNw+8WQhpzd+diT91pD+EYm1GGIERMxmAS8OFLn8eABeEgoobk3RvxvSL15x1LqsIbc5+CzhSM6C18o6ul4/08I3Dk2MipGGPBjyWc1hrZkzJ0YHk3anef8zPpuF/Q/8vYfhWYFlMHmZ5Y0qJGA/gMQkhOzBwyK9/3SJEJpeTySRIade66Djguui6WFMDqRTk81AolP+OjIwxgqMPAOi+++55l16aaGiYDNdO5vdqApfDuxa5b5vvvKQBLmtQ/1HnvSxTuDgxfKEYPJsNnMH6T8HBk2DgBlPvjeuw/nq283ieb2S6jpksozSDJJLLQDJgEO28XVW83yMODnNcykMrCIw2DV7TscMnXtR36akDZ7WU2nz0BkSfxkkx8SOpB04MTl2My6TjhG0Np+E0NUFbxrBN8vTznB9QAg4IPr/B+/ImP9gfs4UBuGdQ39SnlifZgiTbl6tVvWDRGAfnoiJiZdWbe/TA7/uvp5BMKZwR0QHnYwMfqscGx3GGeM9t9NWN8DsNgSEQSGlhJJbdTfbzmDBcGobkJIzyWccdNcWHUxjg68+54OQVh+/FkJu5LuiKBayVUkqr0vH1qX9sYgU9qTm8pII7Nno/ecL/x3qzbQQzElszuIsF2e55d0pJdB/vdxpDDn2/gWAbgIKRG8HfBMmjgGdmh/+5vL1sKWzdivffT0JA+GAMXBeTSUwmIZnE+npQCkZGyo7oQoENDpJSExIwAXi+P7Jx44LXvAb35Jvv5iWO0Oqyeol1DpuXkhnJgyAYHslrpZRSulJVwcnsAGcDjZJcToF+g+hMMap0JR9NGuE8NNpW26PZwOa1VOhXKa1sXpLv+0EQ1BRrVw0cdd7OF25LbN6YXj+pAyKtTtz74uAVWZ6b5hlMOLqtcpWDZ4LtOyUETEQ7PXrLk8W/dAX794t2+vTX7kAbODbH9s4UHhs5COmXlxmYC2HVU4Z04Y/dNxJBJFyFQAgIFwTnPF+dP4Kl64r//kvhe136GUPlluAGkANkKhwcvlNwk0oFOzen7vvjvIF1KXCM64jPv+yK+kwOZs6Nsu93RqX4y84Syk+gv6o2fe0W1DipqwcCAPTOoeC2ChNvH8G0ZG2Z8PTRfuJdmoI99+xdCKA96PsxmCFAB1BC6QkYuQ0yzwWenRJDGA/GARDgxBPZL36BQ0PguiAECgGcgxBl9k0msaYGksmy+WsfESN4PAEDQO/atZmVh9QdeSTRxHIf+/ITHMHrMqmadNLz/ZFC0ZjwYyEJ5iZTF935UFa8SPazqF0WbiIiIufMErPt2DP52SCa3hj1LSmljCXi8v/sEkGvrrlvXfapSV6WITa4nW+52Lx8RvRww11j+s+L+zMGrIlu7FXvfbrYN87yRQCJJIAcMCViJZjAkD2EFQ9lxSTHNGdpyXKSpxyRlTwtRUbylGAJwQgZEuy1Jnj4rnCVZBnYVKGDIGhJNNSruh7orWRb2mQqEAFflj/058PXXV+4bxh7G5NBc8o1BIbQEGhCQ2gIG1J+rhzTAQcgAfCve+qv/f0Cf1BA2gfDTl1xXHtto640qpzF7BvWgkNEwA8qaefuKfPctx3nf+t+JDHZ49l4H5FavVOt3lb8z7vFCS3Oi5bL5y9lhzdiSuw179J+3W3v3xJ6ToPtEHQAioobPgl6pDxgaT9T8B40RNqTbkiToBGgtjb92c/xd70TCgV0XUokoFSCwUHq68O6Oujro74+bGuD5mbo6oK6OshmIZ3mQgjXlQ0NkM2ydFoA8CefhJERBSAAJMATn/h46wte4NbW0LhM6N2kRk8+azqbSh6+bNG8poZNOzq6+was//hwLC3Q3lZyw92OYXnOue3IwiuIppRGCwT2r+h9tKISAAxOkD5W69cdOnDkU3WPDsqBMS9d4171c/r+m8y7IMaMIGAiGgrM2rx+6zxRy0mSkaSlCaQOUPki8CnwUAdMBY/o1JV64fgjvJHvPIIXy90MIsqOjuNUSqqRcWBYzZPfa0qoSqvbBiXVVSQjoqyTeVP2ov+35v8gwyGBIBmAAI3aF98NrjacQABw3kWupV5DaAAM2G3QBI2poIabDMAzJf6zOxrvvacBkgqQoCQA+cuOO1trpTW3y+Fn7fAzC2h4TL5iXTbdUpfLJBPBCyH49gNAtOflo5aJTXD/Zv/+9ezzWfeyI5JfPIPNywDtZ96dEuuZnu0Vbz2aEWAVlyYpcJeRaJqKIPAekO+e5F9NkpLNW65gv/g53n8/JZNQKmGpRPk89PVBTQ1ls5jNQm0tNDVBWxspDQsX0itfSW3z+Pz2VGMTplLAGWzaDC94fumppzoBugA0wODmzeu//a0jPv3pkHZwz5n4We/IulymLre8p39w446OgaERpvVZOPgrag53OE6WQjkIa03y8G/EuNyLsR9tDjEmE9gYw4lsUWy55HIX7P7Wp95/SveZQ+7AmvrH72u689Ha1d1OZ/jql9xPnFA69Wg6HuZMvcZMJWB7mXMc3jqPGw1KqSBQSgVWhyPQvg9+AIEGpVGfzAZbtN8Jo3Rc6yBYjEW7JrZcyJRSo8MPdpsiGlt7zcHRe7fMfxWhf6M5Ir5s2Xk7B7p+ufafIBC4AI7AkQSQ1OHADIB1k2sIiNAQkEFjkAg1IQIuSPl3jPD/frh2e0cC5hVhRMCwhBGzIrHsxPmrrMOIc85o9sszRJ0NDnfb67KZhAMApqc48s4bwOyFfpEh0AAGnaQ8bp68YIm8YDE/vBFz7iRPJ+3zDnuw5171ZsDiaqBoHEeBuxIY7ucu8/uDpyfZEAkm7L5AAFLqr35VnHkmdHRgEFAQoDGUTJLvg+tSJgOcQy5HJ54Izzl1ghS8IDC/+iVPJlPJZEOxqAAUQBFgww9+sPzd73Zqa4lGc+o4dqV9o+HGupqG2lxHb/+GrTsvweE/DzYUOQeAZgxWSOU4jgjreUa5ohlnnFVs4r12mZaHFlG007A9oGIskgw81un4/G0vOaX7TESsDepP7X7umf3nlZKldXVP3l1/232Zu7aLLUUsvMN97TXevTVQOz2b6cYEDGN8HWSi6XiB5WGbpxD2knOQTmWDfzVN0YMcyoppJMY4QrXrtdaaMcaUspETzcq1uvtuMkbfW12EWjXRyg17xeEvFcB+tv5qQAIGQAQGQUElNZqAQBH2gFu2gAmtEcwMI4Lf+PDHLqldU2Zf14BrIKFfuvwcIKjKb812Ag6XO1LwugRPRTox5N92g1rXieDuCe8qAGCZtDip1XnhUnnBEn5EI4aVYrSXFLKfvdC0z45rAnCWA8+BKQJLlk24xKr96BifUp3niVl5V3xMQGecof/rv/Dee2nJUlq+HJYto0WLoLUVcrkq43IO4xSkgSi45RYYHobFi7G/P7lxYwagAJAH6Ni+veu++xZecIGe0Mk8aYN4Mn5pRGxrrG+qq3lia+dpRv17hAODI4SXcUTZhycrdjBWZ5gIFzPcK6mDaC1lSL2McWM055wrxYNgwuMvGV7+hvVvj0biEDATZE8eOOOM4nk6qZ7KPX5n6uZ/J/71GfH+rwTfTbAkxJjmFnCotWAqPRptgVq4TOMVY+i5MPg3v9FEbuljed52PgrbSIUcWS50g6o7ZT8ux6KfMj4J4tXLnlcrM995+k++CoCwojUbrowJADRgLzmGUBskQqZ4nzN0V664CRU0ELgmyr6tmYZz2k8JezTNkZuMIaQEpvgogYTiNx4s/fmxSbOvIdCsISvPaHdetEyes4gtqTmQvHuAuyERAdVfiomV2PkVKD0MLAksRc7K/eh/3qMj4f44Pu6Wj/XHPjbxi7s6twjgefra68xAPy5YQCMjpr1ddndnRkbyABmA1G7X6GOZeH8YxILzoxfPe630/v1wERBPdwrRaJptDBCW9IzCXtXMhN47xpgBsIcwxnDOtdacCyFUUJlLOVYXvq5OvOfpj6chjbySMwxoGdqaPW6QOGnktDOCcz5U/NwTiYeLWHApETuipy8BQyUbvszBZEK5R7u8EkLYmwONYWiWY7BSFdeYVOVL0FGiZBvoWozq5jg6DW8/ZivsajkZjaxc0H5Ks1v39TW/7Qr6ARCIKkxcleExAH0laQySYduaOzfO69dSAyeQPiQ1JLRlX3D1xeaCBEtE6/5gtt/TCUZpgXz0r1T37Mh//BYEObmpXPPl9akvnylOn8/b0nCgePcAdEPa3RsNUOooWvhj7Pke9v0fyFZwFkw35/MecTPtho/HRSGeRdIZATZvpu99j7SGww6jujrT0oJtbayjI7lhQ4YoD9BUU1N3xJFmct9qVwbxXtDwi5qduqQ3FNCJ9a4AX9geadIpNwYotz0dpUwAAHtXgxTNKgUAsv17jbGRYKVs+igQUQaqBWyXbXr7ysIqJhhDNkawohyGqxhRrnZP9k8XQhCn0JUVs+Z0JODQDg7vDMY5J0JEY/MCjLEGslIKFJ4thtf4ZQKez/wljnHsPSpElHrD7EGbSTh1+eVj6snCLAmG7Kj6FV859l3fevr3Dw2srRi+WMkbskyMZHCZPCLdPHjbvKdJcSAEYUAoSGtwDCQMJHS9qH1+6fxRfqdIeHv23VsSKSNwfM0Y9ZeGL7uGSv5EBDxhPFjzQxoTLz+kLLZwsHh335Sz9oakDQBLUssHKHE0Fu4Flp6G/RwmF/x9ljfibil3FDla/vrnv9iHPqhrathxx0Ffn2lvp6Ym09qq29tFd3dmcHAYIPuSS1JtrdHWRjiJLzPGIN4LGm6UeH6DeHhIv+iwhX3D+d7hIlT0EVlIwOMYdK/ngTFZpUQEjBGRTWpxiw+li+u65YUJKE+2p/aedcnOVyFH27SATZRnA5G2x9aLSfvV7xhjSgg4EtjgQgAi2oVYaByXM4+CgDF2BhV/HpgCMQA4WpTciqMm7F8RodsoDU+hNG6VfSsNNYyU9vu3pBo+f/Rbf/nMv/649cZRvmhCJDg8ueT5Naecmjn8ow0fpYIDXIMwYAxoBGFAKqgJwNUvyr+gxq8J7/vob5xtPmegtMAkn/h3jbzrRvX0ToTEGA8zACFISztjL43DzLOZvPvCu/uddPcLUVJo7NecS9lzD8qlxL3+5ntynN0Zx1HnsGXfb32LffCDTCk67DDq7sbaWqytpZoaammhefOoqys5OFibTmc//nGCXRP5nhjEuw8Pjz/aK1plm4sAUJ9N16RTQyW/oGGqa2rHMLE1iYzb1r7z+Wl5fmOKAKDZb33vpk/aCVZKaWe5MBc1NJ+qlnqkSiomy2lNwDY/OcwFMIYxxq1jGiJSwFopu08r+cd7hduDDACc6HhhAyzHcWxy4LgoCQvpfeqMYOv6tvETx3HCLklaKUS8bNmLDqtZcl3HPT3BIHJsSNSuzCw4Krt8eaIdAJ5ynl4LG8EXIBCMAWMqGwhC50TuhYUXhwthzsWsZF8iSnFIi12pVEHp+4+UfvNIJfRrk6qIJVPixAXOi5aL58zLv+0G9cTOscbxbrWgaa9egv2qVTm1LRymX+bzvvqfJ28cV/6DDCgI1Ic+xL/1LWZF1zs6qLGR6uuxro7mz6emJtPSoltb+TPP1P6/K9khKw1N/EHP6kbeVco0TY6GL2gQx+fKMVfOsC7lZjQNKwoOCItVORjRyHa/5oja4t8+0gWDkp/c9YUm08wk45zbrvWh1lWYxAOVuOEYaye2gKcvAVeT8SrEOWbdRBULWPEAEC2xXegWbg8yaTRHJrSQMhosiZJTGDXZF8G2yZpujAHnQojQ8WI/KEBUSgHASY2Hn9hwmCFT9j1HFoarnUfAkyA0GARuwIQbCIZd1PXyRtPEHB4265jmnaL35mZCykrcDVeq1Z0jH7wRAAkCAGB1WXnqPOeiZeKcRXxFXbnt1A/OHzr7txCMtoP3sJLnAPDuAfJCT/P11t6y8uS79pY7NzAwvX35y97A/vEPp6K1zgYHsaMDGxqwrg5raiibpZYWamgwV36Vv+PtUI60VnOtYQ8N4r2m4azArBj1uuRYz7GkYUSRgQM65JXbABzqNXyvi3bqm58RxwMvOxyl4wghrBQXAFAlfac8mVfStGOanAEWcJURGeOMwWg1FrutlCpzszHGmJOSQS5vFoug0UHbQNkWre8mWDJ1QdMJOgdHLWNERFQKEbQ2mgGzln3U7bMWN0MgwCAYA8JUNjQYrPGzL+59eZl6hRCVfMhZo0OJQGmOKbG7H2K6C0MvvcoURsS8JnnWfPnCZfKsBWx+Npy/bF6VPK09+enTC5+5cTcJ0rS/eHcqSXd/0S0dzMu6f77wnvmfx+3AGXgbnul9xSvY6gcTAByAARgA1Jp1dFB9PdXVYWMj1deb2jp84Qv16Wfoe+81fmAQWU2NmDfPbahnCBqAaI/zqvYoPLz7QyU4OAzzigp6CtM+qkpYNnDr+uBYrU7TZn6bVFs3qP/lMi1Hp4aFFnAY7o0WSs0JudwZSsBRXQsax7vjPRi2VlhKmSY6I1Gq4ybMvbItiSYMlhyYyx/6u4UQ4wkYERUiaqSKax0AbJ6hB16H6gWcyP/MzXkjz2ugRl5eZJR/IMyWe9phlBEoditSiMoUv/eIOGNe+lvnytPaWUOSRjdzjeaVJz5+UnDLluCmdWM4eO9M3n3k3QPghZ62xjHtipZpz7h57/3PAILB0IOrt176MrFpUxrAik2yygOHhnBoiPf3s/vvh7//Xe3YUSqVSv39xUKhBFAC8ITQDQ3y6KMbX/6Kea9+lUynDU38HSZrEO8bDTOErESXw4giRVPIwWEHMp7oLn8nA2Cg1tyxQr1vm/mRkBnHcWy26ai3jcmlnUUz1ay1gCdDlvaicmOMEEILozURXZrzELEiE1P2yh6sBZddQIQuFzkmBG0zwYJAj65vtj9t2BSKvgLio/3PGgwyAecMn88rDZdENM17ht/ZCJQVmODPXm1JiMn3HcdybjgVjNkjysQoWPoHFwyd1EH9RQAOti52+vHugewifKApeleXlAHmN7ChO3TrG8Z/Jdzzn7L7t3AGvffc++SLL5ZdXRkAr9zWHkV7Ox5/PBxxBOZyvFSCTZvg0UfhscfQ9xUAjzQJVkr5nZ0j11+/4/rrN/zgB6f84x/plmZNe69DuZssrcnTsMOgzsG8ooKCKcoqtQSM1CNTW6MEDAZy5pY679oif4O1eMIZL9rgYULzI+bLaUrAk7RTQyITXBhpAOBIphEhLD066O35Qg62fZ7F6K/NOVdCKKVCYa/wxpXKgQIHEmA0CAQCMAgCgfQSf/EhtFJUYOvxZ3r0l4gSHDLjCnx3yRccMeeaiXaiCQ4OfHlt6pvnjbz+bwgMgDAt9wv1HhTepSnc+8AavwhAINe9xaSPBHzDswp+7VEweELP845777v7xRc7XV2NiDyVSjc3Z1etSpxyijjtNHbyyZBOw6OPwiOPQKEA8+bBwADfuFEYIyIEbHsz2I5F/Q/c/8Dll5/x978hItGz0OSkaBhG1c3tioZxF+cyI9BlMDwFpnDof5ZsLXcRIAOkABSQBkNAQLrWhnijU+6EXRxwXMlyjOlLwM9KbyGVCRIAYHmo0hGQTwejMPSo24WhrAZCuFV3k1ZZc7Srp47XZHXNkC4Ar3qerR18jDlG8HKz4dlh/jKgjMQE34PZmyZHvdHXndcd5t6w2fvlgwAIDntWhtpr3t2/pEv7eb8DRNM4uQsvNn+Nd95kVpw2GUt2rz3PAIAIxlD3Bz7Q3tXVXl/f0NSUamnhLS2wZAk0N4Pv09atuGgR1NRAfT00NkJTEzQ3Y0+PHBxUowlYACgACZAG6PjH1Wt/+KPD3vqWYHJ0uwfW8K5peDcHkQzqHCwoyCvaj6ZwWMWbTKwHOAzAA/QASoAeMI8IfDoKGcJog2cMEx+UIGBMwFNIbPZvtTi4IhpuJcmnT+PJqL4MVSSrLAMLoY3RoZemXF6lFGNsFV+5vdgVKT0q52EdBquEW4n+sgOe/Eyq0tLuYBi+e069ENa/IiS/cba6e7tav902ONq/1LsfeZf214EOng387B/KgfXfJTZ+EhgAOs/+/sl0YtjdnQaG4ZGvfrVz153gOsAYBYEZGoKODkylIJXCXA4aGqChAZqboacHuruhqQkaG/nw8HgjWABoAA7gAjz16U+1X3RRZl6bpsk6jfeOhid5cARIC3AY7i9TuOpJNirj9gOsAvCij1LQ7qv5Lt9lZX3MtQfQmDng3GY5WAghhBRCcl5Vv8LpZBdG47/RHomum7APx3Edx7VK65zzN9Ze0qibwBfgc/CFfaAvF+D8g2X+Jrd/hQWd+89IopzEGjkx+9Kzsi/B7nkUxqVlsfrE/2fvPeMkucqz7+s+51ToOGlnc9auVjmCIoogEUQGAcYGbMAEhwdsbAyYx2CQTTBgMAZeTJIND2CMwCQBksggoRxXu4qrzTu7O3k6VdU59/uhumtqenp6unt6wkp9fq1VT3V1dXV11fnXdcfkF55NkNBmppW51iLGjB9U56WqFRpch2d9mRvayKwfusjzRGnQeuhPoEsgsEyZWXd4ti8261cmRvDmN/sXXIgjR7hQ4EKBSiWMj/PQEIaHMTTEg4OQEsuXlxXwsmVYvpwymen0VRXHsAN4R47s+MA/ironLaPRM7z6VZ5y89f4xkMpnJTtKXkRKgTHGnSsXuCE2ONE4MTR3HOilN9OhY2nHoArZa1Cn6gV9QlZelbZKbH4UpYhPFlf3bYsK/weQsrjEus+svzty/Qy+KqMYV/ZntstuiolrhfU++sc+WrywEdZuG25nm3iXpsSsgn0csvorQzDUJeuc/7iAh73Z1l5btzlOYK5Jdy2S7m2+JBg0cRu2I/+hZh4GFK0/tWahTGDLBV89KNMAhMTKBZRLCKfx8gIhod5eBiDg5iYKIvg/v7yY9kyRRTnroxFTUsgATzx5S8fuvn3imY/gRsn6JQ7zpYwHHqFe2zIuZ8dzMzc5RZD4sYeJxg+aWjs9NAGGVkiO2Oxhvzb975/4U27iBW3KovCRY1/npXBVYI43NvwC0Tx/kEQZDl5mtxyS257QXtgApND9tWZq3rdbttxwixnMf/GdmaWxYe7HnoZi0Rh5duY7DmZlZgzijJW7eJWs6vellyw8aY36sI1JEmc0o8ZDNpoY4ZS4+vMoS5mGwzCczNlIBiRR74N0QW7m0WsxdcMxmdr37+rJ/4FigAiw7rv2abrfOLmPrOFlwng9etw8JD69a+QTkMpUgpSwrYpkaBEAokE9fSACBMTmBjHyAhGhmlsHMkkH3ccnXCCOuss6/TTnb5l9u7dBtCABnxjxh96aMNrXze9CSA1s4PUyBeieuvXCD0jciUZZt+0cs1GUSkCelk6TdQL9AI9lX97BkdXHB1bFqV9RqWTOixclKEW/iOjeh1gltOacy3Nw1SzAAgz69CNLUQklI9z1l7T85YPDH3loDcAYzzmvF8s93ZYEPQCIFPKPPYG0mPGWsmVn7iFSnLMrASyMxS3agS9LfBvOmKpy7ZefSLzwnG3BeguaErS3FWznRX5nc7OP9V9VwbLXmJ6nsWJtQyQmdboSUKO3G499k7ISV5wY3WV63xTqvNyvPgzA4Tgfe9T1/+IhkfgunBd5PMYGkJXF2cylMmguxs9PVi50nger1rNL3qxWbWaN25U/f3Ksco1sz7wAXX/ffnh4YPAIYCBw7/77e7vfGfzK64OzJQPbcoNXMc33GCYdM0tCAovOp4ImNEig7uVT1qBMqBuEAADCpj9fYePxMv8dRTwU0gBV5Gsus7zko90n963Kwz3j3ogB1obrbNInuOctD2/eygYN+Bbd9w5XBrMZjLLk8ssZc93dTdmTu19lzv4bQBG9RaWvykMwmr28DJzQqLbruHxnR2cDQQ5N7eQGkVvm+tTthW6CzDVNVy6mXTPpXL0F2rgp3Loe2rgWjl2O4wPqx92hkVlTQHyR50HXkilA6ictLMq4GYvYKr/GoMzKfT2qW9+g4KgfO/uOOjr47Vree063dunMxm/f0Vw4kn6jNPNySfx+nXIZqDK/hJz08/ws5+R1tbQkNCaAQ3kgfzhgQ2vfS2HGmCGvWlc+M6uhqm5LViCHEmBYc2NXraR/FVmolfsJT0OnYPOQxfBGoYOHi0eGip3Ka5UXxDiyVUQt6OAG8XwTPHux9Coal8YDqPUGur/55Vv/cTRb/zee2C/PPLFR776paFrt65ef9bqU0/vO/X49PErrJVdoivBCRduAL9I4xMYmKADHh0BcqwpMIJ0Kskrs7SmR65JimyDl5899L/Jg5+MFhpjQKZZ+hI4Y6FmO6M52py5tYU8X+htlrsLUxhrnoA9xSsvRGnbl0XuXPIOUzCsDl8nD1/HzjLTdUmw7CW6+3JOrALgPPp/5Ph2VlW3jM31xmiq9NX018hA/+EfeSOjGB3B2rVm4yZeuwbLl3M6A0nhCuV2HWbyfRQuuOdefuxRWrfOjI2pgYHkvn0pIA2kgfGHHymN5dyerOG5dl9oSA3H1mgwY1gRemyaCDgXcOMMBpvu4H7SEyALZIFU+MQz6vH9IGFXVdTv0PepBeDo944bRY9pBlc6MCrLsrTWzKyJepG9Zu1bvjz8o68XfwSTY6kf9h5+eOSBb+I/oX2rm7tTqWVw+uAkEdiUkxjqArqADMPTKu9b+ZIqlKxCybH1qhU45ez0i67qe2l9+oriruyut8aXGq2JDCqm/kYuYEsga9UoLbk46J1ty+3k7tygO78Nkdo+DExyo7fl35ztr4IglgQw+UcjEuueK9laoQb+i1W1KmSZ4flphVQbxgwQ+f/nL6rfG6+pxtV3CGyYvvtdPLELq1fzihVmcFCvWWMNDqYLhRyQBtyVK6xMimtCdH4w3JpFOq3IIh6frYtDVEXS8va5xftBFsQkfUHWzoHlvk7ZSizNiNcOgBeNxMfumGyALGVIX9sYACIIwopaf77q5Rf0nP6xRz/9BHZAGSgOH77ljVFRABroqjzCqj1g0oa0IWPCJzzoHdlb+s31R247S5dW9z2fZabGbS/Axss+/kYRHI0v10YLYwRAUjZC36RCWhG1VfguMHrbwt15gu6ScriRhr/ylXL4Rmv/l1gRQCBiiZDE1qGvA2BJMxFzvlshVTUlJD3jh1U7pAXo4EH5wWv44AE+/XT2PNPbSytWmNWrxaFDyd2700ASyD77OVJJbWpDFHMo+zyLI7mBjOGqJY4kJTDuc6luZFZogE7kb4O3rwrA+3JrBsYdxykX219qpReesmOhfcBPpjElqHvqxRM5t6WUG5Krnrf6mYM0+DDtRDJAUiMVIKldgSRqPEiLUiD9QHqB8gIZPvxA5XyVO3L9Swa/IAuPgJSxlkM48WsvtfcfEoNfj++hlv1jPX8CKl9p9a+30OycmkbfJy16W+XuQlqhUc6umseTOOi6WA19X5SOYDLMnUAEQRA16EvMwfJX6cypDc7cjU/w1PI6sR2HgLjtNvvFLxa//S2vWIFUipNJdHWBiIpFKhSU1uqZz8y+9rWr3vUuZSmLoGIPSRCAIBCV/R5U64MbdAPP0TEcXyIIriQwvFoMjuSv0V7X8Nekfwg6BzMBnYPOeX5w7/DZFHYhdBzbccpdXztS+KmsgBd/MLxDgb1KzW0Go7CLcLx/sBAi7NkQntldKvvPm/7xmYVLPhN88hFrO5QRgq0ZygVoQ8aIUAFHT7Qhi/ET3fVXxUc3DXzWHficdjb7Pc8u9bzIT5/HImUNX58++LFqKyPZgRGqku03UyB0aHbOqOpo57bbnOeI3kXk7vxboRdJGxtmu7t0/BcS914O9sqO0/q7SqQOfZmlo7suYacPtWKn6xyTpu3PM8nT6UsFQKBv/rd8y5tpdBSOIwYGuK+Purs5m8W6dXLrVvnOd9LGjeGd7kxcpBjOGTAMzS0apRuySGNGx/B0KZy2SAkeD9jUisxiY8gfVoX7wT5IQZSNz3u9SwIkbFUuiFtOQOr0GewAeHHH8I/H/cFg+Wt65i6CQ7EbR7IOgtAfDMBoHQCXOZde6F5wvfzed+jrO+kOhRpV44lRsT9XM5gMHdLWL5DdZB8Gkyw9Lg99zj30Oe1sKnVd6Yz8KN5kKLqCjdHMqqrDSRV9XYmMqk7zba/wXWD0toW782aFbp6186qBAw56LvTWv9d5/B9YNeDbFSSHb5JDN7G7Wvc8M+h7se4ukxgGsyYHt2J/boTEEgT4H/qweM+7w27BolSiQ4do2TJ17rnioovkli2tHBxAEiSBAc0wbcXwTKlK9d/rSlICYz77Zsr9dDm5yBui4q6wiEkI4ICy+/1TwspHYREhKVWUPNlBYAfAizO8/f7Afw73viA71/mLCICIRTmVOwcLQUEQdl1kZh0EhkiAXkAveWHppTvHH3jQ/f1B5wFPDkgx3s1ur0lnWClGzvfGg8JokPPNxIQpxmHMhn5tMq+3D8cLJ8jSruThz88018dz/mrSN62QUvSUQu/C9mbgxlddeATT2LjYsQNEAZ4lD/5Ujt/ND6caeucJefCI4uskroPdp0+/2N/4CtN1sbG7Y5qYqX7cUJMwnlFKSsD3x//y/+Dz/58DyBDAgMhm6cMfpqc/vQ0HClAEJgRcqaDcZBOkxh3Ds0phReixaMznouEwl6Q8yWgNXULpAGBACkKBrCN0pS977ErdwUpPNtlpMtgB8OIMZmafD/zbUfZYZkW8+/QcGWwApVSU3kxEWggdBKaSKYxKwNTG4paN2BLfpap/NfkFGhmlIwdo1w65/QHsnDDj0tA9OlUwKkG6kQx9ZoT8rXkQBKHLgiMXlL5zRO8icrdhQcyNrLRgiJW33hb9S/v30/79AMSOnTQ2Nn1lg7WNbvd7PfF9Frjdwe0AkFJm2waoLrNuI69ZDUCfew4Ac+45c4dxTRILiWB09MhrXmt+8P1krPYk3v9+vO997cULARbBAEEDRummuhNyk1KYCF02qYAngsqkEZZ3NoTAlPsuEEA47JxTJX+jtusd/nUAvAj0BXD4qyOFh70Ix4h1IZwjg3lqpREhAiIKgqBsizamXH+1ctNak77hcNC1grpX0vFPE8+dSE/cad/xLf2TvaVD+429ReXRQOMUJ9i9YvADxa4XsHVeGGEdHYSauUb8ZETvXLjbHuhyi5ttgbW0fx/tOyB27sTYWAjdBZbUyAV012MA5G13TZ9izLnncDbLJ55g1qzG2rXm3HNbg3G0gpIoHTj4+NVX65t/lwF8QABq48bkd79LZ5wxT19REGyCzzDcShOkNkrhlCJFPOYVjWFjhDFGU5c2aWVK4Ts90TsqzyyX3LessCdMJw2pA+DF077MYzfnh384Hi2JQqXmeDpONjGUsrpo1tQCllzBcH0GRzcEROQK92J1yTkrzvuC+N8ngke3qHxDMzJP9I1+HqOf9w9v87qf5/W+UGfPY1iOQHZqbed6vOTmuDiXOllzQm8znGuHFbqJElltbL0web7t3y8e3CF27BA7d4oHd4TSdiEQO5dr5NZbCcCNN0Ypcbx2jTnxRJx4ojnxRD7xRF67phHVG2nf3IGDdz//+f7dd2UBG7Bd1335y7Of/zwlk/P9XSyCDqVwS0U22iWFHUk9/JA38LGx7F+W+ASfsiWsVsFguMa4vY1Vz6T8VWqh26F2xpMbwOwzGGQ3VGKCmb2D/uEvDE8uNIaNQcwaM5dTM95IGPHSlSAi8uMkJgoxHIG2Sn9HCxGrMGcJ9Rd9rxgrrkDwl03Nr1bxIevQQ6lD/xq4pwT9L0/2XwHr7EgTL5zwbQd65yJ552yFbqhUx1zIV/+94tZbxY4d4rbbxIM7xP4DT4IJiPbtl/v248abQiSbtav5xJP4nHP4pBOr9HEViUmgNDh0y0te4t9915pMpr+3t3v9+syb3qT+6I8WbOdD703AjYrXuUjhOvwm7zHl3dsz9A6RePUAv2TcOSeVvz98ecI9KSxRIJUq922raN8Og9tsFxnz5EDe39r9lAPwoS8OqR6ZOT+V2GzPVCOvbAEOzKHPDOmxyWhhU+4cArTprjAeh2Xixa4DIYQIpBRShgHSVebo+H5ybMT/DN+Vsp6xG69f513bwlSvig+o3feZPf+A9GnUdxX6rkLqVKhMvM7+MYPehoXm3KzQ8wXdBt8iduwQt94qb/qZuPXWJS5w28Jj2rcfN95YvjzPPZfPPcdccQWfeGL1FydgZOzchx/q6u+3V69Gby+/9KW0gPStYjBarXVVB8PxrdUxR3PhQYAJQXfhv5R6MJdYjkMCyoBQtDaV275WKj83In9J5ykYh/FBklWGVfqpAtGRkr1zuHjeyqbn1QO57OceyD9/o/9UU8AiKbqvSO9+z8Dgd8bczXbm3GT6aQl3kz39jGbmo18fLezw4guNLsdGibn5gKsYHG6q7BKuNEoKgrBkltRKaa1DBRxvix3HcKR6udK5M2rhCeAonr4W/0mtTcJCgA1G7uPB++B8GCv/kDZdA3dDy8K3ZXdvu9A7Hz2RGuFuU0e/qZVpbEzcequ46SZx0000Nv4kJu4sx+HWW+nWW8W/fRrZjLniCj7nHHPFFchmAbCGOm5j5t3vUe/9e+7uxvnn01/8xaLsZBWDgRYdwy1IYQYIhkuPgMrWrLS+K5XwWBgKAIJWy1U597fcd6Gm95e4JIuPW+O/V6O/UxMPidxBKgyTV4JWRvRqZ4Pff0lp4yuD7hOf3OebydiJG/c6tw1MvHqbXtZoJ3XnnqOZrzxIJV06qadZiNBA8Vi9ruO4Gv7R+OEvj0QmKvc4O3NOMn12mcQhzMZvyx/46GDVNNb1OjdzeaJ8e9ju2mwRVkOOhoHQ4b/RoqocoWoFHDVa0rr8P61FMHS29ydJ3tv8DhmE+SGWi8xZ6H0e9V6J1ImQqSkx1bw4wreN6G0zd5uHbosX1diYvPEm+tlNsiIBO6PGsb3iCj7nHL7iCl6/FvlC8rJLhe/Rr3+NTGYR9yoI63XE51ZUY7aRUln1amzV2hQHh4Ndr4IeB8nyRS57zK7R5KHfQ+H+zd/we893EwnHcW3blpUEpHALkouWv9/O368mbpPjt6L4OIp74Wv4QIDJf30gAHMyf/Lf5p72/iftecUMIPHbg9mv7DBd9sTLjis+Y/Wsb0n96In0d3eBuXRq3/DbTmu2u4E6pg9WRK+u56Zy9xRzdxXDya/4qFd81DvyjRH3ODvz9ETq3AQED3x+uIbRUpj6mbJtlMKhEDbGKKWMMTN15Sw/D9uaRNjW2vf9IAjI948vfaQZ+jKYyyU67C5kz6e+q9B7BZLbatCijcJ3iaF3LtydP+hOJnNfd5246SZx401PWbHbxLjhRrrhRrrmn/iKZ/Gzryi9693JLZsXl76hDjZTT6MGa101J4Wnq+rS49AjkQIGe9JZa217C/a/JNwrLWU87FnSkC3GLGFb6FOlffAegz4EBLB6oUcQDEOPljOpo3xqGXYTzqfu+ccgtbl4wmueZP7juJYrnt6XTlti1Mt+eYd93+DE1ceZ/mTNt1Ah6PrqQ+6tA+Xf4cTueEZrg1JYHdNHLa4Ul70xU3yPp0dM/LQNSXz022MiQXHXbzS0Ltt458uGFrsh4gqNmVlOC4GefipMamCttdFCSun7q4r/1R80LI9CyeuupO6L0fd86r6E3fXzhMxGNrXU0Mt13cjtrchRc2XasUNee6248UaMjXW42/S48Ua68Ubr7W/DS1+86PsSVurweAa+chPdF+p5haeZo03hHpgcZG/lqgtIrZIrX4yeM3DwHgkjhBBUcunelP0b137MEjZhG3AmcBasPgTD0CNQPVAjUL1QwwgmoDUEyo+pMM7c/FfeymeY7k14UnTTma7ogqQsntqbvGUAgHvHYfuhkYmXbi5cvLoqQlbtz2W/9KC1u+wegqDi1myYUNNUTo061o/apCc1y71/nDryyfEaq/ms/RlKQREbni8FXBPD0+X7dPqGf6Bivg4RLIRI+feuzX2i0U81BqnjafOHqfsZsPoxW7TzvArf+qCVBJtQNNNqaXITG5k7dyVBL1RdaHHddfLaa2nHgx2MzunKWrvWevv/WSI7IwgSZUM01dSv7ZDCVZFZ5GyDWgU9CJEqT2nOVhBwyt9g6I9WlL5K3v8k6R5LPQECRBdwBpABVgCrII+D1YtgGFZPWf6Gf+qRcqvHKilMEGYofcu7R5/zDWpf0MwSGVFIbO6c/hDAAMS4l/3PnfZ9RydesdWsSIZzsnPXkex/7hQTkxFX/jKntNyF1kKIpuJ55xfAR0bzy7LJefqN4hoxdI6qU5G8zMr/oolINDNm5hW9ddTwTH0Rqp4LZjZGCCH0yKojbxdcakJwpU6h/pfMwtF2Cd/m0SsIDgHAkF96eHzPSdlNllA8b+htRO+2ZsFuYrWxMXntV8S113Ykb1uG8w//d0ntj6oYomeUuXOWwlU4p8xl0tlkBv6Fx38F4YIcck4EgM1XY/ij3fmfYCKU54ANqDHIA8Aq4CCwH2IlVB/UEFQP5AisXgQjsHoQTMAEkyI4LoUZib3/k9v3lmDtJfNNX3F0v1m2ZoEtqcaY/KaUvyJhDRSiddy7j9qPjk687LjiOStSP92T/v6uqku3sDnjQwvNaDKed34BfM3XfjM4XviXNz1rVW96/g6fMSYIgpDCzouo9DDp/Y3ObMUfsn6gmDybs08jtdFauDv3GX6eKkNH+fwgAtBz6O9s79Emj44/f/Rt2eYsCC4BQE7r24Yf+sHB3/3g4M2azW8u+5wrVWAWFL316wyjfYZo2rePPv1v4rpvd7jbtgn6pJPUlVcsLUUOSJoaEd28FG6kZEcc52RvlOs+bQa/Zo5+BpBwNjFAZGPjB3Dvi1ECbMACSoDNkAPAQWAlcBA4BHVc2RBtjSAYhuqB7IUagR6ulr+TD87c8d7BVb8QUmHeDNHi6D7n/12jN57iP/OPON29ABhGhBI246d3995QmLI/43722p3J63erw4Xpb5/YkgqCIEz0QjOKTs3nV8L23Ufu33X4+e/95gded8lV526dJ4aFx05rHQSBEdp+pSn8GyFobCs+/EfM6COFsW8X3a1W9vxU+mnJOTYonI8vmDzyhdTIt6pW0EgM46QBc/6QOfFU+aluenhWNrTm9G2jx5cAw+a2kceuP3jLjw/dev/Y44WgCKINyZWe9slaBPSGQ1JDG2xWEwPAvn3i0/9GHfS2e9iv/5MluFeSEO9T1IIUbskcLUTfaylxGo9dT7K7vJFlL6K+yzD8CziAV2GwNQ65H1gJrAT2g1ZC9ca0b/hvD/Q4TFAVhxUx2Dlyc+KRbxS3/dE8GaI58K2fXguvKB++Qww84V/+ar3lrAVgcMXfF4ycmun52SHS1ddrTfoaW4yvtdloY0Sz9lQ1T98EwKHhiScOjQDYd2Ts9R/7wR8/+/R3vfKCnkyi7YiKHKsmZPAqLa8U+nrV5E/OhR1eYYd3+GsjiW1O5txk+qzEopM4tIuo3N3Zfe+KFgaiZ1SceRjnHzGnj+sVhg2D79N/fYF4mxKlRpnBCy18AQhCYPQb7/zw/+7/TVGXlFCOsDNWKmBd1F7R+NQkeufO3apV2lIaOo5e+vSnOuidl9vTbNZ6+cuX4o4BgqrDoecuhRtxCVPyDEqeMWWFTf9Iw79Eicsi2AM8RiISwSuBg5BbyuFXqhcqDMjqRTAMMTxpfI5fGwYwyNx1TWHTi9nJtJe+ITusm78nDpStfTR61P7uvwVnXeFd9DKy3fb/XtMKDmqtS70ytz6R3tVQxd/8KqeQIrulbJr2AybaiYf3Do4XJqteXPvTe3cdHP7m378sLMzYrmMX1ZoK/x+Wi+ILPTzs4tFWvh17nL+/mL+/eNgi9zg7fXYic07SWWdhwaMNyl0i/MPdj1xNJh9Ya3POucPWJUf59Jyf8T0vQBCW2wIwim0PWe88OfjHqT3VqQY85lP41n8LAYB4ZHx/yfgZa7LtnQB5xs8FBaI51euog95ZM4N5blbo6vXHxuiaD4YG586Yj2G97OULFr3RtAgGewxBhLoEbUQKN+ESrrmRrovQ/yIc+V84EYABewLywKQIDj3B1lBF/vZqlcvJTE7KAi33ZXdAaSsobT7wRVXKlZGsoHKPJh7+WuHkN8c7sbaFHXLvTuu266tBddeNYt9D/qWv0utPIGpzH6cpccuVxJOjp6QaBPDIZjcq79/sR7cZwPFbiXseG6g+L4Uox9LP2WoRqV6qlHeRUgZh+BmzmWAem+sZwT57+/1il3A3WfZatSjxfkZ7ycNfLqWfMZZ56bg6veDbpWLRK5WY/bDAVnQHZ1tq5Ql/iQN3YOBHUJUTVGXmhb6tZhkZhiOoz85O60xHPgcTQYHaiN7GJO9U4yH5zK1xd8p9xqc+Sdd+GWNjHdU7f0Nd8awlC2ARzuOhQmheCrdojp5hI7zx/XT0ehS9SQB7jMShigheAayC2hpQ34Q3NjKBwfENI8VUXneFGVUkiYjWej+X+QLGQiM24AI20ts/VTj+NWyn2khfFHP2jf8JrpEyKg7vUXffpNedwGi/0bsq+MYYc/QEd/UvpD2hZ31voVuGRIsV/l+8KOgonOyeRw9VvfS041eGmVJCiLZ4DsJNQUpjjA4TzqUkIfA9mw7L1m+uV8nkaU7qbNfd5sikEEJwZXpfMAxHecITy97sacf3PM8r6aAU3WeF9BUkAFhKnXXy8V3pFNKfM2PnonSw0l6C2gLOOQrf+BJJSFuJKlgSITB6IiiI9qG3pWJY3BR3a6x540/pmg9i374OeufXzJvNinPPXbIArmgRQURNZBxxO83Rk+ukT+dVr6F9XypbocuPCZaPlLwN47nSyPjg8KgZHSvkSwpYMR1ISbP35PzHKGkQALrcaxgKVvERa/8v/I1XRR1d537MnF/+txgeqP1qMlu46BXgch/W9k7Fk0X7hShLmqNeg+/d+NOhgSLGLlkV73KxaFHQIX3zRe/OaQA+eV2v0VpI2S76lp8IIaVUSoWB0LjZxoPN2ygE5DpyTpGJ0yx7k61cKYSANGEpi0VpHsLMDKGRNMbXRkeVs4goLG0TruPa9ilbNmRSSQDsrMPxn8b9L48i8biecXaBhC9PnSOyKlUNYJDPQS7IozkHcHPWZq53nBHOlaaBqaT2dvbtwzUfwI0/7aB3IWy8J56wpOkLELMpZzAQGs84mqXscz2KY5o5enKdDe/F8C/A45DLYK2DdVK+dNadO7rGcyk/COMex6rgEV0Ckopn8TWWPQYX8AAf5WR5DeTgPPYTb/1zec7TY9n4vOP31vbfzrTOxDOu1qluYYyoMLKNrszQmBpheNn9ubU/OiJLpiHBljdrf3w092hx6KUbscFp6uag/SboqIDxlWes/+ovdkQvJRy1aUVWa01E3CaehRsRQrCU0hgpFe/2/R81Q1+beY0W24zcBmudUDaMogBgX0qpIoMStemmoUn5O1lmJPKsCyGglKjsjGNbJ25Yk3Sdyeut/2W89q3Y87mYEapRTTl/wjf+Rzbm/Y2GYTMW5FtE72zW5jpTtak4TQQIPKUL5BSrVH0af+VL/Ol/jbomdMa823iXuPwFwKzZxEk2dyncujna3chPuwvsQXWDLAISjI1rD9+z4+HKZFzVvTzabT41+eHu0na4gA8kKtWhS5UPLuSNMWF1v5ZVaXmuK+adm7870zq548+dWH+KXcFH22fjCL0CtPLHA72/PNzsFlKPTCQ+tWP8qvX5K9c3/i7V1lNusniTJLzr6rPP3Nz7L9+5++BwHsD6ZZm+jBVWdJrjD1bz2EkpqShy/xU0moAEACg9bxSn+FJKVgq+MmyU1sYYy7Kq7o/QTIXP9luzgNDPHe0DEdmW2rJ6uWtb1YQ47iMY+Q1GHpgNY4392ZjwbQS9ZZOYSk738TAw5ufbi97ZA69ipUCjLcfPTJ6N57xjO1/zAbr1FnTinBdSX55w4hIHsCQYbYwQVNXnu3Ep3HBkVkPmaNU15VXCupXLLSXv3vFIeLYLElHftgqHzfG9H1zFN2IcCCqPSm8GBACh1LU5nNJb1lST1JDW+LP+OPmbb1uHn6hax8v0HT79ChX40b7x/Jgk1bjf95+PJLaPtHhfWNRd1+1yHxyZeNVWva6h4uTzEIQVKjettdYXn7ji+Lc+45M/fOCm+w5sWp4OF0opRfsunjiQRv4zHxwyTb3dJAMYPXkrUH0rKEIBSu02ejT3uwohKxI8Tt8Ny7odS9WY+mUGJ3wRt18A48+Vne0TvtHIqlTNiOMxP9cseudeF3qSwUySEMYooOavPL1s1le+iE//ayfYahFGJm14qR/1stggEg2GYtVXsbMye1YGT3t15bK+s08S9z/6RKVTjIicoFKUtqx5d5/8CcYr0K165AFGbuV54ZROovXI5HLyjzH+svUTz3lT6o6fdO/4zaQTjcTe054TQCIIlFRGynm697IfG+36yk41UJjjdpwdw/aH78pdtSH37PUkxYICeNKegHJCVXdSvf/q009Z39OTdqPutmBuO8xGfprL/b52Fqzu9cGQw7UKXZnqvZ/pWy3OnX7lwgAUkSiDAqSkWNubsZWsgsrk8+y52PR3KOxqlr6z5gq3ELFV9TRr1QqbZB4LJmbY/rygt+qMBZhAHJqj41bomiJ7bIzf+ka+9ZYOChfnuli9ho1Z6jtpjNFGSomWKl7N3RzdCIOX9/WcJsQjew+QKDdNEkIoMbGx623Z9C/BU6EbTHnkUmfkek6J8l9bntKjKlQ6CHymQyddOpxduer+G93cMICDm5421rXK0doYE9Xt57YShJnd3xzIfuMRKun2/PSFIP3tx5y7joy/cmuwtXtBAVylLcInLz9vg2VZXGFv23lffMwb/H9TPXAEXh74mwr+hry/okgTIvv1NVSsvh8RJCDK4dOVztWTI7orRDOBbe0U90RCiLB9YeQGloJWZhP16BsiasPfY+jnLdJ37mbnmdsKZVRCoMaN4ViQ53ajlxs4ecIjq4gAGGOEEDy1klH1u278iXnnX4fFnDtjccbq1XwsKGAIafSkJ7jZFKPZzNHMKBIS9RmMqWFZ0z+uv6dLSLnv6DAJKYRQGF6v3pQUN8MDXCAxFb0xHu8/+U2aKYxTkRVLUguT5GSsCxsdBFrr4Z51Q2e9bMNDv3RKub0bnmZNLXBB7Z2NfZ351qPJn+1rx5QNFsRKwBIsSR4tZr7xcO5Fm0un9c20t+0HcKXbM5XNL0IYYNKvAGp7x3ud04c+NcQlBkAWxDrwFt/fUPD7CgEHWmswTLfOXz6Yur5/mnVXCkWWZUlVHpNPpIr30Vx4+pb/FUJWErfCy3V52ralmIW+AGQK/S+oA8Km6Dt34TsJYCsliKrmAiIa9/MGoMnKGDx/6EWlto+J9YUkAhtmMAiY4ec217yfv/LFDgEXdyx9+gIIAg2hlVJsmAQ1nmKExszRAh9nnM24rNGwrBmUNAF92bSUamAsp3hkTeE1Lu6ED0hAAjaQrEYvfAymLh5c8cyEMZGmaoG+8dJRIYajf3078fBJVyoTkLIiz7SomPPblXksDxey1+6wHxoBwJJYCVZkBIyEFtCSAwktufeQEdO0sW9j53mWTii4SriWSNoy6ciErVxbOJZ0LOFYwpJkygbUmvs8Lwo4dCSEmjJSFUqp0FXQ3vsXXdKHPjPkH9XOKco6hWiL9rqKXqlkPJ8DJlNGFzP7J+a93RP29iltIZQtLcdSlhUxWEopxKQCju/zwovgaOepHKnLvQllS9EQO1tAb2Nm59aEb7jEAGmVkkJWzRUEGg/ymptAb8udi3iahYa1IcASIhTEggjTZ5OxMf2W13fMzh0AN6yAA2GUMWUr9FyKP083JgvcIunvA/5FI9Zp1K/UARDQnXJFaaez/02OuBMAJCYZHCUgVQzRJdP38Ip3z4fqiHujAXA4I1dEEcW81G05hdgLJq5cG7x4gy8RkPE5KBm/pP1S4JWM7/leoAOt9Zk/99c+Xu3yGF4udm+TUgophVJk22TZsG1YNiwLSkFJlsTCLvuBa96gqPYfwUpdKqVUmFzFxhCRVJOCsi0W3TJWjwTuKXb2Va7JBqVSySsFuqSNMRXzcjlKKxyly0fVAVcMT35rlVCWrWzHsSwrVL0iNigmfxcSvVUBX+GfgqjHEY6k9tqN69O3jcI3qviYlK4tLG1M/IgS0USQD1rt1NSQwXn6EsPhwzBbspxXTdPcSwzwg9vNW9/A+/Z24LcUhhkdRTa71AFsjNBaGyOiPu0zx1WhwUir8tIRSX8MeEC2wbejrkuYART3Zh//E/j3IFHhroiJ4ETFBK3h6e57nI+X7NVu+6bEeB2M0B0YKTeplGVZqjw/yzATpD30ZfZXJUvLHa217/tB4HsefI9LJe1rHRgdCfS9W8R0AB9ZU2nuXqkgTUEwmUsdC+jlmXnXTgBH0jbUu8xMICllVP1KKStu1G3LEVQrRPpyx/M87eswyjrULmWTReUIchgAljKl5w0nvtEfxV5JJW3btm1bKcuyYrsX20laJAfwlD+BLpvmkb7tMzvXfxcDKeXYpPKTuYShPY1yQcE3RpJgbq67cNPojdm44yZohNkjlSDByeLz1/23vuZ9HafvEmLbzgfF089d4juZLxTTshK9UVWWfW7maEV/SXgYkDztEmyNwVzYq3//fFm6T6Qr1mY5VQQnAAN4QIGOmnOyZue6kZ86Q3nJTKrbJDebvqcFKy6A090aMsI8Uq1lGCoEQEsZmU4t27YsSylrUgS3qfRH6HwOgkDrIAgCHQRBEBito6s/FOJDa5DL6lQs3YEJQ2tkFCFUlnnlZkqahNBSky4LuTrG+XnxAZMQMjSZCiEqX0ZUDLttMSBgStEPExWsCPcgsmBEa4bHRQeB2aD9Cyas36Yrx7ccfBUqYBFp9EXi7kzftMsity59257p2xaz8/R3aUZCJmxh5XSx6rQp6FJRe2npNhh9jRaaBsbuEjh+Gyeoch+AgFlUXiUi/ZUv6Gve12He0lLAzLTko6C11lHeR9TVe3pVjmbN0YI+L+hrjevm2TtAFI8Ub3opjd9HXUQ+k6y0HQz3Q0rwMkx0YYQweBQTQ6u9G1YHN5Qjs6LoaB/a3VDY+sbCaX/NVrIVZFSMpiEsQgoSkZDSsizLslXchtqmeTVW6yiUb2XrablespRkiIg0cHCz3HLPZImJfJbyy6zQSVkTbTxt1ExknRcAh4FXYeyurKRtRRYG0VYAl532lapvZfEtZdxuHB7fwPcDIYIgMBcXeI9De6zotiA8fiJm31gK3I2+Y8aihJpH+s7Rat2gXEY56AlJ5bjSZo/jc4OAKOhSMfAy0m0h92n2V2cyaDOH5v3KDRlxYKKss+Cdb9fX/XcHeEuObbfdKs5++lLew4l8QWsdaG2mRvBOl8Ics3LNylHC3YregSZt1zMxmAjsTYz/4BUYuMPqkbrIBJbhy4l1SJ0P52SYPowVkNuPwqMwBDEBWYJBdatgCZnfnb7z/1r7bxu56jqSVrP2ZxIijBkK5+TQckBEUsiySmpTCFG8Y9AUiFQIwlJOgixUtKBDW/i4e4NoFh5eJclSk1bxkCMVEjeu0dvvA578GkTlilfMscPcVpdq7MwOPc9WdJdRsUKXAay1L6XwPCIy0pgX5eUXsiiSmDoWpeZzffqmFFJtpW9TTt9yBwXAxJy4LQjf+BKLVFJN78dAeV0qGm8yDLot6K1zf8AcainDLEW5dYcSgrns+wn+7q/4O9/q0G4pAvihnWppx2GVvFIkraYzOMKt4Lul+JHmlxqcFKYAUD2OTljij4HclAmwsUodNRhMYGPGr39T6cFfqqyiHJML7k7z6uOp7zKkXgR5EUojKGxH8AicUZgsuAfBEPTh6fQt/yngHPhB8s5P5p/+Nw1iMo4MABZRFYBFhW2iTe7L6XNsRP0QKNGnR7o4CIL8chpZ4fccKgdDD623LcsKndOyot+iCLIoknfWJJr5SkPC1EbHVRb/uR+16MPK6BVSqSlVsaLiagCYTRAE5VotRDoIeDmL53nmOw4IS0fvTv+OCYmMJdoiXsNvaJo3O1sEAZS40XirWX3AtrBS0q2qZESgkvGK2mutIVJT6I3J8Uoh6MrvXw6EHhvFe9/JN/20g7olaoLeuWOJV8IancgxxKTCmgGKBidaeK8l/kHzJRovNPwcgxOjq7XKHK3orwj3xa3RDBWtVD8WumZ6UvHOT5bu/4bqUfYadrYYtZGpqxc4DlgGjAEHoLqgMrC6EfTA6kUwAqsXwRhMsQZ9K09Sd/9TcevLTPemBhOT4p7gMFyIY41nKBYb3XaBFPEy3IEIvZEuDukrPA/AoW12z6ECAG3RxFrHtm3Ltm3bjscXh8ov6pdTFbM971HQ0zFc81PbeBBDF7cs331IxAPqYiZoIWTkFSYiNobOZdprCHLJ0tcm7rJFG03HiqAZumH6EmATBMHnFs3O01cwgCVESrlmahEyAgITTAT5WO2pOaG3kXCtyPTkqooClkKPjog/fY3ZuaPDuSU7+MB+s3MHbTthye7h+EQukUpFzUMr9canu3tdz/ynK8+W9EuJX4Leo/k8g5dqfg5jK1fS4gmQdK2kqgR0G3AbKXc1kyy23AN9T4NYGVAfkAYcAIeBJ4BeoBtYDtkNqw/BMFQP1AisHgQ9sIahizPRFwIiGE3d8v7RZ3+l8bazU0ynzKiUPZhio25v76NKWYqIvsaIKcGXzGFYr/T98BccPN4Nbikqj8f7pe51bMsKGWwpS0wVu/H7hoVWwPME2hmPoBAyprarTN1lBWxM1LwvZLbWGoD9UlKWDDPkl5TlGYACd7eFvpV76dCGLCmMM5pWgnMaJiVgi/K7Nc9V+E7uMsOWlJJudSonYSIojPgTYkHQO8WeaYyqlGx1lJRv/CN+qEPfpT6CO25VW49fmvs2kc+XPM9NJhGL9aspTAEYLCuZL7ni2YABiiGJLUpqvtDgRZqvNNgq8KCit9W5ClpjsDj+b+TEfyE4glzF/C2LsA4Aq4CVwH5gFVQPVA+sHgQjlSc9UKMwxdqGaAMIJHd/IzfwNr3yzMbn1SqZOL30FeahB3AY5UxEVbdK5ZlBax0EIVyMMX6WhzbZyx8qja53wuQoy7Yty46nz8RNs43cN6hj+iIsfzchZFVK6dRvbqIw8YpZQwQBAOEIaZeDyJcUfQWbbldU2Yxa1L4GPOEhYwMwjPB2wxIIGJrrmZ2tWNEAM2fhy7HqIALIqFTkUfaNXzKeJaxtmfXdVlovIHqZWRtDgCVltNDt7Sl2OhstfQB//avyVX+0NPft0JEj8TIvM5mXJr8LP8s377TEh2PL8pJulLjRoqTmS4h2E+plwTXFYEQrOyvNyr8Se94DG/AqD3UUdABYCawEDkD2wlqGYBjWCIIQxr0IhhEUy8HSNaWwDtJ3fWj4Od8MlU9rGG5jx7x6HxT2uQnto5VwpfC5lDIQIrShWloz89GTkssfKo1vSsRrJlalz9S5q3hSATjyHFRpqek3HVFUdjweO97Zfnob6sX8XuBuR4ipe9Ki35dQ/PTdtCZtv2wrcxnAkTk6lMJci74q9uGao1CPOQjf2GsEZKwUG388YEnyuNTqS/vPvmrVhef2npxSblFzu9Bbn8dcCcGI7M9lEXz+hcVbftch3NK3Qus7bqOlFwsdBMHAkaOJVAp1oRv/kwCP3y/4F5Junba9vKQfz3wtVLesJkZTYVm89s/50OepuHuSwXYpJoIPAKuheqB6KyboXqgRqF7IqSJYTDVESyR2f2di/6+DtZe0PKnO32wct6HOZCRnZhCp0FHFJsxQGt+YGFubK65wy9wVMqSvrOTdNLsnxyqA4weuER9z5CqucFdXyoNMKc61+PKXucumKC11jvQN7j9afNdNya++OHzBAIYRbVsQbELAkxiOnL5TLLStlbScgb7hlZ+Ubr/b87xVF1216oIL+k5b6aYNUNQImJsQsnMrlRVZnBLWlJSJ5JXPHfnERzqEW/rD/4/PWv/fl5faXg0cOarLTS3B4PjcUjfl1ymZLyXkBfWV7rTT2eaahaMbZDADVpbXvocef3O53mRZBA/GRPB+yJ6yJ1j2wBquBGQNQx/2ZMbnroDSRrkpesI2Q2UMM2A4c8cHB1dftKQSOxvXphFfpDEhaNmYIE17n91HGVvGynLNJTrsmFfAja8phEDM3x4mXMfTthadvsycsWDLNtAXBJPz86+7ngt5OJN9kzSq+xCpMMzKADGnb3wYnhKT2TCMZ6znnNf8+o0veOtxL92U6gNQ1BgPuHFwzh298QOujUm7dny5ffIplO0yY6Mdwi11EXzX7fqO25ZaQvDje/ZIqahSlrcqz6JOnQ2Dk33zEVu8teGPKlj0JxqvMvwsYH2LDAZ49ev40L9T8X44cRF8EDgY8wT3QXVDdfml7oJZM+yvHQxeOI5lRbUiUAkmx5beM3Kvs81QeQsaILgDv7T3/cJfd3mzhuglZWGNKiuHyCitS4V/huJNzKERMo51H3CzB5QqEVuRyz20QtNiAziEQVIipQS3g74Ain/7K333HsCOv9eE/YSrzAOAM8NZZBjcSoXLet0UAsbm9EoAEwE3zc66yUVNLGQO05BsKeIO4HCkr37V6Bf/vw7hlv7QX/gsnfmlpbM/j+x6olTykikrTEApx5dQjXNyOggJ8Pktgm9SdF2D04agGwVuZOpmvtjgxYafyVjfFIPBgHTMhg/KnS9GCbAiEXwAlAYywDJgHUQ/nPXsrNp+aO0TA/lJ+RhGsIJPsD6ZtPfCBXygBOQAH3CQevDzw2sva3v394WkRiUvWVlWuZpV1FsoqkPZ8rcTT5ELdTKXTJbrqqhYh41FaThYRV9HIGuLmSpmNItA7//tKH3udoIzfTummQAjXSteuin61uS3Z9gzXGebtZfzjCs3vhCxOpTMnHXs6Stkrv6DDtuOiWHuuiP44fcqPTUW+TGRz+/eu29KcT2qGCcJMyfST/nTM58xMTnb0OSGEUHfV/R6S5xu0YsEfYWwn2MXwCxleRjofxF3XY4JoAiUAD8DfTLjMsbLGS9gnMLkstUNq//4raemk4l4zyIhxPrs9etT34db6R+cBJIAARNwnvg18kd5asX1Y0wHT4pgKxpVzWo7CrhRkwIq/mCqWPkXN/aqnHRE6LJn1r6BIUtMXi31EUjQDw0V//JGggBAEJRQVUyVDX9d3Qz1p9C34W4KjQvfuareaYeeDuzLnrBt+pr2yac4519YvOW3HcIdAyL4kx+liy5FJrPoe3Lv9ge1MU68MrAQImoFDFSZn2qWzmCs8PSXXPkiIN/0FIcRou8LfJ+pl/lSgxcyX8hYX9tVHH9OMFu/QKM3wO1GYi1bGyFWEqtopWjlhOs+/dSTbr3vwbKfG+jL3n5q/8cxUWmXFO8crEGFEnt5JAwvpWSTppBBsVzhSAG3q3KieKpdrvF7t0ZKhS0AfcGm257y+VWlY83e8dzbfu7dsIvzAdHUgnXT6MtFXXjdj83wBCDLi9QU/5NBo0k2BtANxz8zuD59uYElNZbzjDJ6LguZmcdGM/fdKUXt3733r/+OI63ceSzlx8R48K6382KPhx59bHhklKJywFPLF8cZPOvNosEJjMScZjkMCfqOoj+W9Fbiu2e9fpnByc286i3c8yp2nwGxtqzNanl8spn0adu2KGUpZfV333vG8X8vkh4SKCvg+MNBkFjmW12Ry+9YHFELg/A3Ddv2VNWm7ijgJu5oZnJILBaDuy0Rx0B1kyKG3NxFCWvs2V9Vx6+2nr3JeuEWdcFqSloc08TRXW3x3b8Jbt1FcGeyAzMQ8GSab92dm9xso2bnuQnfeVe9sRnHf/fbu//tczN99cT5F2Ze8Qdj3/p6R2Iu/cF338HX/F/5nn9crB04dPjww48/blt2mbtKWZYlxWS7urjqDC8WqtGfMBy+I/6IMDiH3UkYPsfgeYavYJwEOA35g7nGtTNTbvGKZb2Fkpcbu/HENX8lrTxETPVG/ZECIEC+/6wASlSqTOEYDMWKmjLF81fb1SpePQUv1yXV6Sit4KiZ6Vt5mvjnZwR3HPR/tkM/PFD69B3i+D7r2ZvUS7aq89eQK0O1SoD37YdLn/x96PqtA6EG7R6CkBAoMQKukT7RIH3ba3Oec+xV+UnpUx/p/4M/FNmuOl+///3/nL/lt/7ePR3CHQMM/vEPcMbZ9NwXLPxHj42P37P9wVAkleszWJaopKlU4rCoHBiFSQxPZzADDr1P0q9aOQLoZb5A47mGn8U4vsq4Tc3XyarP4I3dN0G+hXQePmADiWr0hn8Obn6ZMdoYg0oRpGOXF2HJjskijO1AiepcuotIX0dwypL16Rs+I0GpLzxn7JzDfHQCkPrho/rhAfr0neKkPus5m9ULt8gL1+i948W33kBArbrrk9ePI5pwPAhCguCbac0YptvTWmoqvPDoBeD//jddfT3pZ181y3fPdq3+4tf2Xv183UlJOhaG/tD7BPMCM3hsfPz3d96ljVHKCmM7rbBEsGWJaQWSpvFsihQ2gEXX21PqYTXC3dWGL9J4geFLGWto5kuMmqqTVZ/Bw/9BR/8MjoYEPEACTozBXvnJqPP0sb7z3UpnITEt3eAYYnAkhevUn2hlywPFTtW9xaGvIvQ6oobrdybTK6H09Z25P/wuQcXapYTtFSx1+gouab3zME25qWKAEz/7A3X5OmMgCRahtbPGAEUzRQrPk/BtkKmtoRcAj406P7++5xWvbvCLl7bfv+fqqzppwcfMXPnyV9Of//XCfNahI0fue3CHNkZIaVu2m0ikUqlMNtvV1ZVOZ5KplOu6lm0rWd3xhaZSrpLMsy8lzyEcbBi9XZ75ksHljB6q2nit51WfW+OlGd41uSS8uz/0KTrw9ipfL1wgAMaA8fKDx+X9vV/ze85LJJOO40Zdg45FEVzHgd3xAR+TvyWBu+xJ+nIj+o/hvPqE4Gdnlb58R8XITIAiKICDew8SQNN/UCIkFQOKGvP7ziQHgaSAZ+CVE5OaoG97hW/L6A2PV1ZRomH6AnBOPnX9//xo3xte3bFFHxvX1/98HQcP0N+9D+n0vH7Qo7t3P/zY40QkhZCiHJ5jO47tOMq2w1Cd0HFYW1ZOMUcD0AnxhsbpCwDIarxsJkNXTUU7J1t0uGj3x2nX3yABKMAHJCArRSinGqJ30Z+OOae5zEszB0ntC/RyyXZDc2Kcsu01pIvOFbsoDM5Y1fUmG0EOA+7HL5XbVjL8aZhVNW+nmDUMW5gTfaNhCyQlFDG3kb4zxDk3GDVdeyFjWrMlpCQtsynR3dXst3ZOPnXjDb/teeNbOyHHx8bjt780f/pqvvuOeQp4LoyM3Hr7HQ8/vqtcXSCsK2BZjuPY4bBsaVlVDeRrXxeVK8ihf1J0w0wn4IxmKZ5o5KKrkfjbyGrTJLDe+XF9999wAOiKu9efknQEF0gCadpHL9yl3lTVmm9J0TfzrXxrxsA2d2TqmKAXGL1hxauMLWqiaNZu9kTwf7M/98yvw+dZ758YRXXmuux1L5abutr7RTzmkq6u0dEgfdslfBtRvQTYAo6gpjzfM43i9vsH3veu3C2/6ZzJx8Z49vPptW/EytXt2l5QKOz/+c93P/pY7swzhAERCSksZTmum0gm0+l0OpPJZLPpVDqRTNq2rSxLTs1UqTV5k6IbU/K5VVn3jC7N52m+KuArbPH/WfSpaef/moLeCaQbsSpjupG5GVs0EUr3fkLf9Q6VgUqRSvAU43PoAE4AFjAO72D3E4f+MOmNuGbEMgGJJDurTPdpwcpnmN6TFp3E5HPPR0YRYOh93Vjsu4KOCXqh6auI07Zsjb4hYKyL1jj/96LiP/yMZrw1Dlf03Vefkf78syltzWm3q9hGYIYE2YKLZm7Cd+pqgiABQRBEfqxOls+NcZ3LuAUQplXbYkpbp7kP9+RTN3z7R8Xt9w9+8TPjP/lhJzhriY+BJ3btuO/BleP5jWtWJ1x3TujN5wfvuGP3d79bOnjQu/SyshQSIkw5sm3bcRzHdV3XdWzHsu3I/oxabc1ixl4SOJgQb4joy1ge8EWaXxDwZWFdSQJK5p+l+LWgu2e8qKjmxusamRu2RROhcMenS796h8qS8YXxjJGYLIEsAdENncEgY2wIo3m7MHp88JmySo6EcgA2rrf6ubmn/UPQf8ZizcAA0t/Nq/3a26K4Mucu4j1BRwEv6G8PNn3OZNZvs/SN7ks5MLln/U/wq8cIdu0r0qHkey5I/O050IZzPkqaSxqe5gmfCwHnfc75tKlbnr2iZlUsj8vtGaYaiRsrxdUO4SsJIkQyUUhlRVhqwRvjP/nh2E9/OPaTH3ZCtJba8N3EjiteuP+0yT4NK5b1rV6xfMWyvmY3lXviicM33nD4V78O8vmQpsWrX8kb1gkmKaVt267rJhLJVCadzmTSmUwqmUokEmUGx+RvLaFJQCEln6Po1wYbAvPMAM/X/AyDfpq2vsRdSfkMoBAtMby1YO6fvAunWVRsazqYCKX7/2vi+38iLMiUVE6gEqzSUL391Hc60idCLofvoXAQ+cdQfASl/Qh40jodVP/LnBq94hvelhcsygzs3Fnq/lIOgHecGvrrDGLlrjoAfpID2BjTbZOrxJzoWzFE6yfGchd+jQ+MVypeTVmFHCVP6uMxjwsBSpo9zSUNX4MZ4LAzIYSyrtjc9b8vJrfaEJLTYTuTaaycO33nZnMOuyVKImsOEd1tH8Xt9+Vu+U3ult8Ut9/v7d3dOdsXd4ytWPPAC145tmJNzVdX9PVl0qmermw2nVKqtglwaHS0WCwNj44OjY95Ox9yv/kNyufhumCG65be8Eb0L5MQYdRVIpFMpVLpTCadSSeTqUQy6TiOZVnTW+VMO13JpusU/dTnqzWfy8gCk60Lp5/dNv2rI/46BuATC+YewJ6yZZqFwQ3GRVOFvt6un49/4/nwSxBKZtlZk7Q3bVVrLhe9V8M+G4X9KOxA/mEUH0PxcRR2ofgYvNxM9A2fGLFi8A/vNOnVC4a90Pooj5q+fxkTEwzAO04efXs67p9eFAZ3ALxwP78ruMuRc6dvWQQfKeTO+S/zxEgtAANghq5czlTr0mPAYwRdP3qt/bzN8RcMI2dq7R3Psm+zL2mMvg1tlstfyRawiCyCvTQCCr29e/x9u3O3/Kaw/T5v757i9vs65/9Cjv2nPX3nFS8K3EZLOWZSKcuaxPDw6DRjhiSxd1/iv78pDhyA6yKVKv3l26i/zxbKdpyEm0gkk6l0OpVOp9PpRCLpuI4KQ6BrRR5N41+J4VaWM1VDtPqaTYgXKPpR5To9oWDuRcUG1n4GE3h839jXLkRpj7VaWeuNtVmo/hNB5wNnA6cCp8ArovBIBb0VABcPwDfTuRv/t7DxNaPPu3ZOwVkMOWJ0j2hk+gXAvun9twn7sSBcWNosj74tiVg330UBcMcHvFA3X+BsLfqiAdhMpy8MCn/yE/3E4AwmaFTioqcPHXqbqDstzttMV23Wp/ZPX6NSl6e6r1HrwhcNdVRsir7hSyWDUmWBK2ARuaKJbhNtH/a69fa69anzL4qWFLbfZ8ZGJ275jR4dKW6/z9u7x9vXUcnzMh54wR/Ezc6NnAXjuVx0wdQems26tfk3v9n9/vft3/+eSiUVaGHbtrRcN5FIJpOpVDKVSiSTtuNGfXImq1/VOpljTlZ3krvRq1y7WhZAJfM5KZ9OGKhPpunOXa7vG57hLTBj3Sfsl/1Ab4AskDSgg8ATQA/QBSyHWgOrF8EIrBEEPbBGEPRCjcBMwAASMJUkJTPl38Rj/y+/70/9tRfORXra93vubaXiOY53sq37RP1JOP2DfETfcInWWghhwmrPi2SC7gB43ukb/r/bmZZ11KQ5l2PTSvEjt/k/erBuEFbVZgwjIAha2SUuXitfsEVcso7WZVDpzRDft4Cn4nKhzM485YhVpoOqGBaut5GiQYHNGGATEpKSC8Jhb+9ub98eAIUH7q3vDJbZrtT5F6XOn3yXt3e310kvbscI3MQ9V//J0IYtVXehVH0l1rlUZ8QwGVBXl/e619HpZyS/c5144nGxbYurHDeRSFTo6zpuGPYspCRQdfWr2ohEFFYxMxGnVMvSWFc0n02Il9XE6iTa28JgBrpOEhvegOH/QL5SKjM1DHEAWAmsBPZD9EMtgxqG6oHqgRqB6oHqhs5DG4hp9BWVhzTpm983dPUNYSpHC/xjcP5Cx7nTy3wjx27eP06VTre9k6pJHOof+95S+mfelOXEWmsAclGjsjsAnvdhjIln/XJjYndG+hL8X+4rve9XBKvRExVMm3vVs9aL5x0nzl9DyxPhpcSmfH0HYjJLuNIweE70ndXsXKMDTJRazPGPn5w3jZmljQzHtuAzTzCDOVPMdbmWzLYzC6uw/b6Jm389cctvvL27OxbmpTAK3b13X/368RVrAIiYP28yBzdKDA/PrplhzDyFwZFxUkBIUnTeufrMs52RYctJJCryN5FMum7CcV2rkvsLIkyts1GXwTMTEdVSmACfX6r4rRZ9bkZ4t1UHB6vebQ1+E8Ux2KH1WMM+CBwEVgIHgNVQa2H1IhiuSOEeBH0IRiAnJolbSwo7A7+wHr/B3/zseH3HZlQNmHj0dcm+j46LUWNv9+3tPrt5b4vyTrO9k23dK8qlmweDrm8WquYLrVhrHfVX6AD4ySl/mdmRSFlzCrzimE3NHM4X3nA9+0FjAGYoYV/7PPWiLUhbFZTFGweWJW8EYMPQbaVv4x7fSdZOrZsz+Vds9jRTV4gf8PDtxhg2ZvQf3nHontvW/ONHu54z16hLPTZ65Av/PvStr3XCrJbUGF+x5vbX/Hno9A0Nv2F1KooXwQjPofCsCGFcj8QEoNJFkMTUVnR2tstetzphuYlkMpFIhNrXcV1lWVGpRYqMzzMkCDXK4ClbmGRw0XxUyhuBIJzA28XgGm9hILHR9L9VHP0IXMADSoAagTgArAIOVkRwH6whBMOwehD0ls3RoQiOC18Z3uBPwjh9x0cGNz6rBf8rV34+P4uRq93eL5Z7J1ORnQd85wGfE3lvq1U83fI2y+x/F+TYdNMZG63NotK3A+B5py+xydpzCryqWrPwlhvN40dqGZ9NdaPg8N1SiGesRdpiPeM2Ay5fEQAC5slrr6laOQ2YnWf61tPRW8naCmfLyYURX6M/I3FjjOHwX2bDxhhj9u2hH3xLA4+//hW9r3jN2g/8S8tS+ODH/+nIFz7dSfxdgvS9I0bfsHe6iDXljStgY4zWOjw14vURo9NPxHRz2HKuvLFKlwXHduww3TeRCB8Jx7Vs27IsWUn8jRufEZOVmKHEI2bN3J3GYEa6aP7DoXdXUDY7g2cCf43n07CtV7+Dhq6l4gAswAJsDecgcABYMSmCVR/UCNQI1BBkBsIFYMjSSPgq64sslOBAZiYeliiUScxwD//a3vMrf8NlYbh4IxiOmcRMeKOdO5nsC63076YUB6QCO/d5zn0e20RejbnKMJvyXNIB8JORvuG/XbaQVYXoWqYvofSJO/3vbp9KX8MIAIiuDBcCeH6N8ljFoP72GfANHAHEygG03enLsxmQp0jhsoqdAtpI2kZShitXka4sDCfZ8F/r8x+PrASD3/pqfvu9x193Q7MM1mOjD7/sykLH1Lwk6Xvna/4icBNUafmnpBRSWspSlgqpGc7s4XmjK6PMYFNj/o3BtyJ8LaWkssIak45jO04ikXBdNyy9YVmWbVkigv20wKvpZZ/rm6NrI3kqgwnQfFmJ/ykUpLPoaQao0crPNRjMgN1vVvy1PPB3cAAP8ABrNOYJ3gfRD6sX/lHIDKw+kMWZM+Fu2T/ev30fadhMNhF1md3nHf1TjFWkuwIU0nd/cmjdJdyMCJ4sChreUTEffS7Zj5N9sFYLG682X5nKvz8aiA/oAPiYZHBCIsr6rQOu2b3CDAgENx8ovecXldhmXQ6q6s/Ki9eqq46Tz9oQ/HhX6c0/rI6LtiWSVv3PIiBgOJXmSrTg9A2XxBVtTKKUh67c8IYMLmvcygihG06xQRBorfXoSN/Nv4h/lfz2ex9+2ZVNMTikb377vZ3zeamNwE3ce/UbIvpSCMtKXSrbtq2wEqSUKGfha6N1EARBEITnSdSkNj7/hgGxEX3L2ldZthMWu3LCf8NyV1HHhXjN5waEbHMu4Zl0sMYz0YgRu/GPmFEzw6x4qzj6eSo+DhvwQhH8BJAFskAfsIblergbYa9hlYTqJrIArFgWPDp073guDzZEOHHs40rlYAFFoFDu3+AevEEdukuvflq5S01jGI6bNLTWTObgi3n9F0BBw+TLQY4x9y1yFm4HwPNlfBbgzHTjc8MlGxEv1y5ghorFP76eS4VyVaiN3erS9eqq48Qz1tLKZBhUZb3pNP2LPcE37602UNPs8V8arJkYbOqGGaN5p28jPmCuiI/KDemUIxmhtzy4bEgMKkrXaG2MCSdWPwjCWTb93a+J3HjVR+e33/Pon7x823U3NvhTPvSyKwod+i7Jcedr/rLQ3Vt2+gqhVEWnOo7juo7rOrZj27aUEoLCk8f3fRMEvu9ro6sYXC1/w1wiIaVSllVBumPbth3+EWb6RlbumiUn6zMYzbiEZ2Jw80bshhkc1Z0Nn6uMWfVe+cTrYQMW4KTYWgtxFvMzgdMZq0EunNVVW7OUOvPkbb+78z5jzAn4Yp+4E4lKKnCYfVEEBUHyvi+MrTyLm/QEx6YEHQRBabk5dJlYdWOjREsdkFs+i8JmUzo98E6S6OkA+ElEX2bOOiQI9Y3PDXlYCVzSxddcrx85KE9aIy/foK7aLM5fI7psrsRBlh2mAvannml+v5+fGMK0EK26NwHMgF/LDtMETecWsVWhb7lwCFXkiGEW4cVWsa2zZiIyU43V4WQaaK2DwPf9wPeTv76hpmFp/OZfH/j4Navf8d5Zf8oDH78m/0CHvktxPHzlS8dXrImkqpAy5GKI3rABbRiWrJQKT61I/+rwEbdFM4N5quu3PMItKMuyLEuF/9ll9Jb9w9OdvjMbk9GAS7gFBjciYevr70Z4bJa9BioNEcBdxdZ60GqwS9Nuvmmqsb0rnd6yfkX+8Le3mv+c0j0pAEoAARpydLcxhirxUM1iuOxXCIIDZ5nUo4nsrkahJvNIP8DpBzyT8b3jLe8M29tmmcyCFvTpAHheGJyUcKTAbK7f2QHJgID+/UFxfE/qPa8XT1tJjgwXGzPt7QZiecL+3LNLz/sWOH4tzELfcDXfLCh9eYpEp1CHTF57RGwMEQlmIjLGEJEJdQYRNJEQ4ewbVBxvhllUYl+Td96sjg7MdMD3f+wDfa94jbNuQ52fo7R39/6PfaBzMi/BcWTbaXvPvTSMTw5BaFtl4esmEslEMgyPsh0nNEELElzx+uqYCToSUPEgrBCpUspQVYcYDuW1rPwpVczmXNPpW//Pui7h+gxGvTIds6F0tqDoGhuJv4WU6b0a0T40APtwbF15J/H7y67fiL7RgxAkVhhjhDENiuDpLQ5DS1gQBI9c7p/6zW471xxExTi7d3runZ7JCu945Z1ueydYJr0QJO4AuP3yVxIytpzV0Dx74BWXsSovWKMuWctR8u7Mm2ID9ZyN+m/P8z/6m9AQzbWu4Rp3BVzdW3DB6ItK+954OiAD4R0xVa63Mp+FoPBm2RhBQksppNRah5rF93wCgZG++Wf1b3d2vf2NJ9Q1RO//+Ac7NVqX4AjcxI4X/lF4myWkFErZlu04TjkmOZFMJJNuIuG6rmXZyrKiIkflsAGttdGmEkUwPQ4r7B4Y3ttJEQuoFiKkcoReIagJ6DZsFm4U4c3YoptKTEKdpkk8u+CeJp2vFcGb4Phl43P0CEmcA4D8iqdrraWUjQRDRY4qxGLlop84nwweP3/0hJtaNCiLMePe4bl3eCZJ/hardJZdOsNmZx4rdXQA3Gb6GmO6nTCdoVHXL8+qiBWxaQjYIcys919ofrnH3Lan/u8bp2/ryb7toG+V3anSBI0mJ0dmMEsiZhZChKqFpJTGGGm01lIp7QdhFI4s5p07flv/Uh69+ZdjN/8qe8ElNV/VYyNDP/7ebDaLzliEsevi5waJpCAKlalt2aHwTSSTYSMEN5FwXNe2bGVZllKRd5ZjkQQMjkdBExDd+RGRiKX/RjFZU0oGl1Obprh9F5LBmNkW3XYd3MDLM0pn8v+N8Da4U4tCT31ozoysvkwZE1mhGxfBlV9o8q6ImXuecNowmdvEYjJEb/4KVXYA3HbjMzmqOeNzI4boBukbimAkpP2F5xQv/BomCpRQUZsCbp6+cwx4nj0Ci6svLFTSMcNLMSqMFc/alMwm/NcYY4zUho3RygQ6UL4vb7y5kUN96Av/NhOAh378fT020jmfl9oodvftO+/yKD65nJObSCSSyUQylUylEomwIpVtWVZZsEa8jPKRmFFOQJlMcqs0/5nMAxaVmh5x6IpphVEXhcH1Y7JmD7NqpkBHs8/LSwhi4kPkvQcu4ACJqdyNSeHDq6723H6htTFGVi7w+sAr/xZCMLOU0iiljNZaiyBYe096xaPJlk8wfwUVj5elUyxvk0RClp0MDexSB8BLQv4SOOO0z/jczPpT/q8hTltmfeQy78+/T4IgaGHo27SM5norlM94oik2MQ77KZYjs9gwmE2FxErrQCp9yy9MA/c8Qz/5Xmnv7pqe4KGfdOTvUhxPXPK8qCqVZZU78SZSqWQylUyl3ETCcVzLtu1KSci4mzC6q4tgHE6soMk0UJraHVZM61I3PXr5WGfw7Iq5breGGs8JAMTR99HEB5AAJKAAGzVN0B6W7T/+DcoYxuTtdYOoCxUwQiuYVErpxCFn4y2JpqdugcJKM7GV89vIXyvJhpRGShIaVGko2WyxzA6AF8f43OMIQdSa8blZ+mIm+lZ0sPyz0+X1j5uf7wbNC33nbnZG4x8X/UlUniUZIBhiAMQcVn2VWmNiTP/6pw3+cEM/+d6qP/0/VQuDsZGhn3yvc1YvtRG4iYEzzhdCKKWsyPKcSiVT6VSMvpZl0dQ6lHFCVHV+FagmaiNTLE9jMGJdHBqKha76c54Z3OAGZ+FxIwwO6bvvb2j440hWQCuBBMqG6KmPR1a+07P6FDddECMiIlWqhFJOr79eCd0oI7Xi0eWl4U2l8Y26uBJhrLvUUvnKGBVqawnwPLcK7gC4bQx2RbnsRoOUaoS+9WeBGelb+dv67LO8l/4vFwKqRd8Gdfl807cR9GKGBg/x+TR0DHs/v75x8Xr4v6+dDuCxm3/Vkb9LcBw6/XxBQgqplGU7jptIJFOp0PLsJpNO2IyoUg+yXABrGmxQc8nUsGQ0gKj2S+H5ZHDjyruJoOgaVAQD4rF30MAnkKygNywBLacaogMgwGPyDYe7rmzZYTvpsxdCStn/A+EMNXHZHtw0tv2ioyIMcfdCH7SxLCtKhYpy0uZP/nYA3Db5S7F2v42gtL4luQlg11HGGrQ+oz57BSyJ2ToMLmX6ztpbCbFqHt7tv2m8rtzEA/cGYyMq2x1fmHvgHu7wd+mN4RPPEFIqy7IdJ2zEm0gk45ZnqRRVLM918FkPwzQjsdBI+apjh8FVS1vo1lC9INzO9r/B3k8gHdO+EYAl4AIaMECAo7mnH7EvWVH8mVsqWjnbshJIbUT3CZzd2DSGibK/05n7mrtoA2EMGzIU9kQiIl1JQtNCCCGMEUKUA7E6CnhJ05eZM4pk3NU6m+u3OTDXD3uuswUNcc7KsP1Iy/RtqtAVN4ze9tI3HMYY79bfoBn9OvTj7y1/5eviS0Zu/hU6CnjpjfHNJ1aKUjlOOeMo5bpl+kYlIad39G2k7BRqZeg2KIWPRQa3OSCLQEBw59/hoY9TFygAhfT1Y32QBEFnkXcxWMToaFdhx3ne6+BzPDmYkfF7z81ve4u3+WWNnxj2Ht39Q6/2OdNVGs+WVu/N1pLrFFfSizU6AG4DgxVxylZYENcv18VXjTX1nLRv4/SdX7PzbOgNffD+3l36QHO9Akdu/mUVgCe2390xQS+1MbZpW9gO0LadSieipO2G5a5sJScLMmNqkfPZhe+cpXC1W3c2l/Axz+Ba65du/1Bw+0etLjIekTQyqj/grIc6CeY4jKWQG0duLwqPIihaNFHVHhgGFIzbB2+y995U2PTG8Su+MOvECwAF0/21AnlT0DrW5x1ZPXFo1fhgz4Qhc9ata9c/3jNdOkshRaXQSlj0O/wjzPoOU5zQfKvEDoAXWv5mnTa7fpsOe24ApccWfWcVvjWaKRlT+P2vouXuuo1dF1zqrtvYNUOuUfkC6OquWnLSV77bObeXyBi9+VfFvU+M3vzLsU0nyHjsVaKc76vCahtSChJEs5pLG14yn1J4diS3g8Gov9oMDG70XbE9FITSfdfmb3yPTAnKCbAh1xJdy6j/bPS8EIkXIVDIPwr/IahHYI/C9MAMwRyeFMdRw+DKn4lHvxj0nZE/88/qw88Y0/XNvHXIADAW8qv04PrikZUTw9mcbwKtNRuA6f6zDvUeSabHnSoFXC7orcKM8XKlM6VUWAhcxppLdkzQS5fBSUW2FLOhry5ymhVcTdKXYwRrhb5NJvvOSl9JJAiaJ1sQcqvCd1L+Mmtj/B33ues2rn7T2/qe82J33cbWftOuCy7tnNhLZES/xbaJiSf2H9x96HBJG8dNhDWfbasc81wuUFpLnzYhfKezp64UbqM5ej4Y3GCx6MaDomt/W4K/95bcj/4CTJSQ1gZtbTFy1QpKng+cC2wEGOzAcqEz0N1QPVAjsHoRjMKUpqM3ep66/f8WNz/fdK2vyb8wBTH582LiPj9/ohjfoofXeWOpglcqeZ7HPqJAPADa5XvOO3DhTRuJYwfEprCpRljhW1WEb9hPOvx3eix92wcNFDvWttblL4zpT0pB1Lr8bZiLPBf61hXZzSKwNfqGTwVhzM+XtNfrdCWkUASEYRkM30BPe0ODfQy11pbR2cED2Y2bOyfnk3gMjo7vGRzxSCSSScd2wmKT0VSLqdmo1ZPdbEtmXIEa3UKNbVKjn1jjJWplz6e+kRr9rBk+jup/CsHc+4948P1ytVCrDfUBGcBygdOAM4EzgLPBJ6M0jOKjKDyO4uMo7ELxcRQeR2lgSnVov7pYdH7jn4xd+cXpGrRseCxq+0GvsILzad/zSl6pVCqVfM/zfT8s9M2Y0s9067192+7tjzay92m5A5d6YdtKy7KkVCI2aErds3kUwR0F3Dp9jTFdNs2Jvi09RyPW5sWm70xm55Skzz76o888+vVNqXWrE/3rkys3ptasTaxYlehfk1ieUG4kimcVvtESCe5zZEpZyHTo+yQffV2Zvq7MaLF0uKAhJYlqy/P0zKI68o6blMK2AAE2EQB75glZA4ahmXXY42ThdfD8B0VHnyK3vcEq/DusozBADiAgXYS1H1gJrAT2g1ZDdUP1wOpB0AtrBEH4fBSmWO0JjknhxK6v5Qb+Qq84o6YCNhZyJwvf941f7odkjEGlo3O8cF7YC/qx04f7D6V7BxKVGyMqx/RZ5eaSolIGvAq6HR/wEmWwRZy0VEMknM/Aq5k/pT30JUBR7b0KYltuhL6h2H10Ys/R4tCon79z+EEDA5AtlID4wtPe/4I15+V8RjPFqBMCvUoK6pyST6HR5ToZh496nDOY3o+oDoabsD+H93YER8AhsgSsps+x8hs0I2D4zCWG5vliMGZ8Y0MMFoBB885gA3bXBsvfrva9FxagAA/wAXUUdABYCawA9kP2wFqGYBhqZJLEahi6WJu+EjAg46dvv2b4ed+KylEhVpIW8RbhleTd0HEbXzlcgYLAkN7+jMPn/XCdVRIhp4WkqNdkPIhvAbjbAXAb5G82IdFCeu7McnkWpjZjfK5T7qo+fSXBIgiQJChqyCGkGRoIGIY5YJTMjB9BoJLGvsKAkrYr7dgWDMD9Tk/YY7Fx+nYrysjOKflUHIJouUNjAYYCRv1co8YwHP/TFXAFuQKyHZOwJEiCA0oDmlFiFA1rbjODG2+aNP0tAQKCsCE0IhdyjeM50zBr/5wH/oMKe2ABHlACrBKsg8BBYCVwALQaqgeqIn9Vb9kTrCsiuGZAlkBi3/cnDvw2WHNRtZ1j6giBqpSqKqMRTtRBEAghgiAo9OiHzxs6+VfLKrQWcafvQnI3ft/TGc3RN/w3IcmWYo6u3yasyq3St5FPEQRHIC2pV1GXpKQgV8CiRi8/SbAJSYG0pG5FK2zqUZSWZIvqz5eEsaA4UByUJKtuRXqs7Eq3P2ggzzha0tuh71N+ZBWWWVTz9KheMlsaOgO2QI+i1Q71WZSS7aHv9IslKdCrqFdRQtTuE1rjEuDZb0Znmzd4prdIIIfch+gDPrRocnYK+6XC7tZr34US4MUefBQ4AIQY3g9JsPrK8lf1wOqGSIMUGAzBLIx0tEholZhSvoN05o4PmmldI+N/Rs05bDvWmDJZbgvtuK7rurbjWJZlWdbAiYWB4/OolNCqMjsvfE7w0lLAdCxUQGBmsMm4czM+t9X1W4e+dd5CgC3gELV9orEFbCAFMkDJoGS4aMqkP+qNDHojksRUDa37nO5uK6O5IeEb0jfVoW9nAGkJgI76XMc2W98iLYGURFqSWsDpVxLSktISRYO84SrTdFt0cJ3EpKq3J5D8L/Elxzjv43fnG99ybN/M6tfzoc9S8QHYFQDbU0UwVkP1QvVAZiHTUMuQSXHv5XA3j/nL7tktjfZJWKcV/ql35Hb4lZpZCu6hn9t7f+6vf2Y81A6xjoRgSRZJKSOsUiUnLfT/+r5fRnUQGGN2XTzRu88lQ4sieecXwIJgWkIoAWmFgkawhAkcGZ9TipSgdhmfW6h4NceUX0lwiOz5N38IICGQEGUSa+BQ4ci4n1dCVgF4tbs8qSzfNHQ8uzr07YypDA6YRoJqkTejRbrygiJ0SUrIxbQEhubuosGE5nllcJ1uDQRKcPKfxPsu08+8GOfk0WSVSgako9e/Xz308ikiWB0GPQF0Ad1AP2QP2ytBFqdOgeyCvQwkAaQNq8H7B0dGV9EtPfZd5ZLRRSAPaMBGavtnhtddHi8JSZWezUopI0QYfhUDcHkYY8JKk+GrPpHWWqfxxLMKqQl7USTv9BmyrTwndFlNm24koduCLZY0fSMGC3Dalm00Ps/2kU2tO0vKryKkJWXkQtB3OonTAmd3r/2DdZdXmbc1m3WplbYo7399+joC2Q59O2Pq6FZwRD2HxZQlDAX0KVptU0ouCT+cK9BnUUpSy7boxqagGQ3RNiwf/pvl649gzGpy5gl3zCx/qclejAmgABSAIuAz4DCOM3y65i2aXWP1m9QJnDyenRWo+KGEoBOO25h1h07LfIRcDRdIVBooBcA43N2/oLE9cbNz1AcpLJ0Rmpdt27Zt26qk9srK8vAVK/bq6Il6+Cyz6PRtvwL2DDIKPRYmNIq6IZ7ZAlmLJCGvET++TX+21tbdd/lPe/q8yl9mzlpiMvVovo3Prbl+a60jCEmxoEa2mmON2/Plp73z/Se97kMPfeP/7bkpugFfn1hFDWhfAnpVJ+K5M2qMfov2e2x4llKRgpCV1LX0wk8JSArYRON6MkSrcR1cp8BWgwFZAHZi+zvEX/2X+VIQ8Z5mEcFUzsUHCdKb/xUHPoZ0hlMbOXE85DbweiCL+L5Nu6QZ6M2aC4/7sDU6BJ6SCgwfmIAYn6CJwyazjqs8tUIIonjxzypXLleKoXClp4IQInxiXLJqVU87JgEcd48XNNKKsgoOYTxgM7P/gZmTCpnKfFrSHMWwtdCAIvmvHxOHDs4fgFEp+5y01cIZn1ugL9fw9TqC3KUUb7c+ueJzZ7793dv+IMSwJLk+tVo3UJwrq6jD386Y0fwmaTjgOvbntESPoqWctKYIPYomdDlsAnVbEtV37zbI4KrxVfryM+jiN/Hr6juDCbABAjzAgAUIBpw9K8h+vYq1DVTdGiPzcsv5PRIV7obo9codDE2Q9K0uMoYq+Izct1WaLW6jnoSIlPFg6dBerZSiKAhr8TDczlk5/JJ5v+wFdiR6bXIF126zzJy1JulrGEU/iEe7cTM94dR996bf/14oa17lrzEmY7Ut8rmFrN8Wko4kISOXFn2rMPz9C665pP+01Yn+OhFYoeVQAJlO2H5nzDy61ZScdZ4KthU29Vl0TKSMh34iatI21ogAaGTZ34q33Y0dyVofRIADuIANPIJdH6V//RT9q4CmKCKaAQbz7NY7AEyAOSyKLwD/rGxzdgGn0jw4XJKA17u5lFgR5ftGiI0imcXUwlVV6byhsVqFOb8Vs7QUctHp2x4FPFlwhJmZNXMpoLA1vSBkLbIFT8SkMDNLQpdNVmwy9bTR2hARKqFu04+LGDxKuZxev6Hq02l8PPvG1yEI2HHmZMSe7WvaAq4l22V8RmOXSgtviYYtkFjy882l/Wdc2n/GsO/PGoGVkegU3OiM+iMrMRRUy6xuRd3HWskDR0DGzNF1ex81VNlj6nOuk2Y4htE3i9f/zPzCgRsAYBDBqRTr2IlHbqAbfoTv3UI3M/hmc7sF5dfQ2bPlMRIQ7KWRF0PehQRgl/XuFBHsAz6G1z/PMIwxbAw3Q81wtTB8WgFhr99QAYdVO2r2rzzGABwXiGwMM0947KrJMguuJFtgIuCCLp9Y2Wn3oXkvCIJAShkWKZnp+Gbe/AbOZksvvdq77HKzfEWI28w7/1rddy8AjpVEaWMX5Un568qla3yeGnhFgCsWOtJqLqPHsgww7CM/Qx0PZs7Ijv7tjFlGRtJR34jKta8I/dYStQDNPjsTuhWNBhxwPZrWvBVv1hlcNW6n379H/P2nzcctgAAfuB87bqQbfoIf3UK/y6Nsn/5v853TcVKxame4XhFQjupIlx6Rh14I2lnmrgTcqRWhfcBHwN1H118ttZ6eDdw4g8s6uIKGyB+86CK4bbeFzBzWBtNaTwToca14ecBICgcG6Vol3SYKRW2ilanm9nVv38QH/qn3ovOc733X9C/3Lr60+LKr6fBA4tovResYY9qb3RXR15VwlOBaNJ1d/rZkfG458IqAlCR5rIlFAfRZlDQY8tlMmxQSoiN/O6OBs4iQFCgwAKQk+hUd06cNAV11GNxaYlItBk8f/06fOJ8uOINPuZ5+/AP631vp9yWU4iu8lf/yFXhJqfHPjX0ryt9Pu14MPD5JX1k2OMfpCx97e95YUn2JWNGrVs4KIQCE1EVlO4tYf2NeABxW3dRaG63Hi6o76Vat40pCrQQSL9D5khd29CwfqZh+jQ46M3tnP338o5/IvPOvxZHD7nXfcq/7Vnw7xrbZGI41omrLkQ27HmVc1XhNx1mlbX2t3OCLNV2/xyh946Bd5dBRfzIIBQAbTlrojM5oZKQk8j73WqLnSVFpt2UGzzKPNLD268UfEaiIwvSXTuczP8QfCiozUhN7ReDx++T2q4B9SMboG1a/shAPxRo2Z+7P/KEzlb7NWjcjg+ik/J0qjrF45TjaHIQVEjjQwdBYrvE3ThSKvu8bNnU8uJESHXvrXxSfc1XN7bg3/tT5zrfF0SMt3yjV/FBmdhVZkf2Tm+xNxO3MO6rP5GOdvtFJudyirko4DRtmZqejfzuj0Xs4WmlTz5Oozn3IYJrp6m8gIGvmRqgsgASUqMWCEoo16ZtC6j/4K11I+XWmqZoxpAQeuZ9vuYrH9sFMa0HoAVwJxUog7669z/kYkzU9wrnpAxgb8bgtIcSTqhIWMzNYaz3ulQqlTMKxG3nXaC6vtY5Kac8EQmNMaOUe/PgnV+zYrnY/UbWac/utzh//oV6xsnTZ5aXnvyi49DJe1t8G+csmbau2189ouKXgbPI3FqD4JKBvNLokbKJBnwNmZmOJTvWNzmhoWIKefOaSSAdzM4lJdQzCEuQAFjABcxfdPYqRxnfmg+Yj5+D0QmMCO3pOBDN4v/+Lq6TeR12kfIasKOBIBweACyShJ9wnRv6gSz+YKf7KGTfKSlBiLbq3md6TIVOtHMCZA4MWkcE0UJyrWIzoqIPA8zzf9zzP8z2vvyu9fsWyWd+ujbn30T1CSttxbNuxbVsqVY5Pm7p9Du3bxhhjuj/yz70f+/AsW167rvD2dxT+9C3sOHP5Xq7gnoTFTcpfbrf8ndX4nJJPwhxZz+BQUQvWa1M2OqMzntojrFgZITmO5+hvqgXvaEiQC1jAGMx9dNeP6QfX0w/vp3s1dIP78CJ+2XX87SBsX1hzT+JPqPwPEYIjDxS+f5X096huqRKskkaEwc9OxftrJcE2ckWMFnlEcV6IwJsSER1QkNxS2viqwulvN27vk+AHbYMCjlsG4k2ghscm1i3vm/XmgkDLutLDE4XpiVyYmuMUojcIAvXoI9n/+sqM4LRs78yzSlc+x7/8WXrbNrYstBoRXe674KgWU4+ajb1qRhlXveyKJ2eFCltgbUIeLWh0Rmc85Ycr4DE8U0tl1nUGh3pXAaMIfku330A//jH98D66l2Ga2oF12PBp/iwAPVtI9pRcKYIe2ZX7n5eY0T3UrXSRiQ0xiEB2H9zj4W6CyWAsh9w+5B5F6QDpgFQlm3uyVTCriUfU3R90Hv/+0Et+AbenA2DE6SuEIJAQIuk6G1b0NYI9IWj9imU92dLgRGF6jtdkrZNIBxfyy//Pn6nDA9M3VTjxpOFXvrp06WXmpFMsy5JSCinLxdKaZPCk91eSjHXhaCT1qKnYqzmV3agstwjOkzdDRxCWJzvytzM6AwAykoYMNxX6ZIHyKN1Od11P3/8pXf8A3dfaRyeQ+Iz5j3W8PE/1JrTpGUemMDxx3dX68KNQdjDGpAj9y2j9WVj5EmSfDR2guBv5hxE8AmsCbi8wgtJEufhOvFVwpWGwGr43fct7xy/9dyx2O6MlBOCwPQUJ0ZNOruzOqGayNjMJJ+XaIwW/oGc8oCGA+z50TfLO22uucPjFLxv6w9dYtm0HQdm7XomIbuFHiuRvDe7VhS6akb9VixogerXxmYCE7AQodUZnPCUGARlJY7r2LFLFYAII5uv09X8VH9lB2+f40c/jF76Ar4x6JTWYcYTAy//orXrfnXKZpZYbewvbGzbL3gtAFwJnA8vhTUA6sNIIumB1I+iB6kaQhzFV3I3DOLn988Wtr/TXXNTGkg/HKoApVgh7WSbRk2zF5yqIepN2SZuJoLotUohSIsp899u9n/8sgNKaNSNnP/3wJZcld+487gufC1cLhAiCICw8JrQOGcwVSd347xTz/k6Rv7NDtwH5267I52iFpKQOfo+V0a74/DZetp1xzA1bwDLwuYbYrVrEACCexc9dbdb9im66iX5yL91tmjQ7R+OX9LPf4+7zcGa+JmtrnvAEFAcS9nczz4Jc5dOysDXDKHAIeAzIAFmoNbD6EIxA9UD1whpB0As1Aj0xqX2rRLAEjM78+q8GX/5bstxjl8Hyb9/7/nZtSxB6HJVx5xSBqAQlFAHwzJQJgpnFIw/3XPOPY1c+e9/b37Hrz9926LJnjq5eM3ja6T0P3Jc8sB/A4MWXTpx0sizHmIuqQidNJVyHub89CSUE1ZS/LaceNYLYRopelY1LhE5+zhIkK88wlto+z7qTxy6kl9rRbvPETShNzT+c8nxqQFYSqeOx8Uq+/NX8xufxCzdgUxHFw3S48cCrcBSQv5VueRW/JglbYzLAasbdCCcrJ+vYu6W+myJdZhVBNpABMkAKtBzswOTBRZjwUYIpwEyAebKoN1c/5MRBbfd4K89dCp19FxPAYZugHls4qg2uSAJsQbYgn9nw5EcYrUde9oqRZ12RX7XaJ9JBoLVmNkOnnb76xhtksTh40SX5U06VlUE0me3VeMWTSP46EilndgtBK5K31stNGJ8xJfK5I2MWfk6PWGVi1Io/ju2vGX9E328qnpf4affkpm+odjSznmrrnYnBYYu/EkAQG7Dqcn7GK/n1L+SXHoctGsEROuzDb/BzD9PAERp8Cb8giH1qvShoAETsnCIPfwXwoAAJKIYyQAZIA2mgC7QM7MEUygwukzgH9qbQF9X/2ofuLBz/h2xnjtGbxTYAmJldgW5byLZKMUmhcZUCRlgEVDuOVkrrQAdBEARhShKYg0ymtHLVil/+fOgZFxdOO12FQ6oyhqc2ymhUGRjT4yrZgPzFbPK3ERK3Zny2ia2nDH0X/uqapKwx0b/VYvEp86gaYUpClWJ+8t8MFgoYGaGhQTp6hAYO0YH9NHBo8nH0CI2PU24CWkNKyPnNXFdEBTNpeqVpMmZ6YlKMxLQa/Zfw+a/k177UvPJ4nHAX3ZFHQ9WT7qE7N2Lb03GqX+sjaopgtnvIGxajN8Oq5PtaHsipMDgF6i+L4Ii+XIQpQM8ggivPyS/AKxQ3PHdxC1q1/iPOfZbKKCRbyoDRWk/kCyacx1AumE1hewoSkd+3rIJjt95CiBCuzKyJmPnwlc858qtfWIW8Uip8TZRFMDX1w0STiy1gNaDmm0o9mun9zXZciHbVWeDYq0IBeqrNKp1+0kjbqqZeHbnfmtCsmUx4rCtgGhujsVGMjlaf/9NmNExMAKChIQCwbV7Wzz0980RiAUjEuszVdQZXDQMuAkVAgI7Hcaeat36DvnqEBhr86L8Wf/E0/bSTsbXQSN8FAAy96h1y6D9ROgwb8ABbwzkIHARWAiuBNVDrYp7gEahuyCxof5m4REbamh2CllwiE0Re4dTOa3OnvtUsO/lYvP8rA/i/dv/gZ4dv3ZhavTG5ek1ixbrkyn6np8fKShL1T/GEhCTkfWPYBNporT3f932/VPLKw/eloLNO2iamRTPtOTjw4GNPSCmVsmzbtmw7+lcpS4XlOKSMCnhOXuFhf0fLCmEceuB3vevv04cHyupXyLCUB031ATd66TKnXTmTnG177FUDmK9hfLYI8366eR5GRyk3gUIBnjfjauk0EglOpZFOz99dfxAEYQexNkrbDm7nm3w0bRxL9NWajh6l4aF6J3/dy4cO7KcD+7mnl1evno9LIyEwbjjqXtNQWPLUPw24BAqApvzBwxh6k/iTG83PLdjBLKyvTGHOCr38r+TBd8MBPMADrFGIA8Aq4CCwH2I5VB+sQfhZyBRUD1Inc9d5SJ40kFv+0CFLG8XCUUS28DI8mC092jP8+/SR31OxmL7rY6NXfDlqhXeMAZiZbx26/3eD9/xu8J6K6YC67cwyu/ufTvnLs7pPnOkUZ+YJz4wbE5SH73meF7K3VPJ9Pwh8rbXWev3qlct7q5OmjwwNR4ozCAIhhF/rKo2Tm4ikkGHRSiIKhJCVFoS8Zm1x4ybLspRSUS2tpi3PzKE/21GyUck7s/G5kdgrbmnjzOyIeXR00fAQHT2KQqGhtScmMDFBR44A4GwXurKc7ZqP6Sb0O4TGj8bfFfXxbq2dWWe0l4XRVbnoZXhnQe/AAB090raraWyUV6/mnjYXb3IE5QwbxowMbqBEZZ3xLvO+i3DBdfTtn9NNT2BX/KVb6Hf/QO/7OH9IM7hBEbziz8TRz1PxiZgIPgAsA7qBbmA51Ca2ViJlc/oUyB7YKyATADLF0sShOzSMgBAkSkIVrE2jXRceXv/mLv+JFY9+IfP4t8aH/o77Tjj2TNDMbNgMFAerpvphb2zYG7NIzRThHfmCQsTqIPB9P/D9IAh0EIQuooia+w4drgKwHwQj4xMUyxEKOykFlRReQcJMJWhZ70ppAUKIQEqpFFdmVSGEVMqyrCr13LQJ2ph0A7m/LVbbaOw9sxqfBVjMz6lGw0M0MNDiLT9AY6MYGyV5gHt6edky2G0roCGECIIgPE9836/TyDOibHQGdsZSQpuu+lnjSJ779o0xc7zDEgOH6OjRWazNLRB9715M5Ey7pbAFLk1yth6Dm5idAACX8RXv539wIJ7HVx7GxG10y0/p+hvpJw9hZ7jCJ8SHLzIXv5ifm6+bFjw5kVlZvfLv1Z4/hQUowApFsGEsZz6O0Q9y4G4CbZqcTxggJFxnw9pVu/YeiF/gISxyiS37n/6pvpUXWwO3F3uOP+Y8wYqZ80HxUPHo9Ne6rcwKu6+RDkW6EhkVsjgyBQgSLBjAkeERz/dtazJDaWRsItBGSilEOW8o2qYpB3gYY0xoYY7oGz4xQggjpZAmWpeZiJRSUqqQvtSq/JXEri1rnphNxV7NRf7W3GRc/lrzUffK88S+vaETqx22uyN09Eh7jW8khKlMi1p3ilM+SXgc/ymjHjUtdEoPJ+WwrUuLJ1guJ/btbfnus5G7W1EomM2b28hgh1A0s5lepwFyOqerRj+Wf8b8h4QYBwBkkH4+X/F8vmIYH7qTbvsJfnwD/fh+uvc14pW/13edgC2lmYX1FBG87LVUepDUKKc3wjmOcTzzJqBvSgxXralw45rVBwaOGmYChcoqLttGNr7SEYEKWw0eWyZoY8xA/uiQPzb9tWV2d1YmI/5F3216febwf6h8//ASUkoZY6BJkDHGDBwdWrdqRbTxwdFRJSsBU2HpjMqTeOPGuFk/dAEKIcpRqVJG9A1DtESUgNRSp+Xw+yRtQbMRty2pRy0bnw2zFVXobNfUUCyIxx9Hu6lWNr4tW2aWr5j71qQQOgg60Hrq6GMAobshAjOmJvSHRg5TscMBsKwW6xCIwwM0MDDfXzC80MzWrW1TwII4MBAiTp4WnMFV42PmMydi4xg4DDUJgHGAABfuM/niZ+Hicf7gvXTXdfj2/6OvvZffQ2zXMURPLhK23vCJKQIX9d4VKfhkwl3Zv+zw0Eh4JlQSTSs8YjYyMR0Zx4ICNmZ/4bBnauSBrXb6ycCQmV7NMV6fOYxijuo+hsdFSFlRp2XD8sGjg3EAj47lVMxfG5I1DJsqUzSujGOXHAEkBKblh0TmrNbuncuNmpmTtjV3+VuPrM0an6ftqmp3+BWNjYl9ezFPmlJrGhgQo2O8bi27iTntJ5EQoqN9n1IjaOaWq1z8rtl7U63lrsepWFyYb0TFgti3V69Z27ZJHGHLTkYdBjfo9QUAvMG89TXm5eMU9hpmigVaa5RzlRTUhXzOM3DOCHyNyV6hs4hgVOK2Z6X1tLF+9crRXEEIgVhP3yiS4BgN71Ba6925gzVfW2UvC4JAxc7smnNiqHjDpCAhhKxI4Yi+OgiEEOO54kS+kE4mAOSLpYIfhDHP02OmhBChXXqSyrXkLDNT5bO4Ir7Dn6e1ys9sTEJRPJxh7vIXc9gIhen2Zpr8LZdia9MoFOaRvrFJhx55xKxazcuWzWU7UspAa3QCqTqj1mTUgvGZikW563Es7F0dDQ9TJsvZbHtEMLFfmQDrkWw2Q3Q4TuHTP2Q+WgwTP2eeRzUQFqR0MNmqtaGUpNm4O5MIzqaTfT3d+ZI3KbEqNlHEYomOMQAbY57I7a/52hprWZj7MT04onybWZG8oc4RJKKM/dAuFDYJ9n0fRMw8MDgcAnh0IieEiPKOlFIhcRHvqhS5gmYA8HRLNeaQhhjeM6Qce1ZeNiV/JUEAPs8of2cisSQWwKESL7Mm7TRhvJkS1MZEC7Vn94LNPuLgAc5N6DVrW/aBEZGS0vd9dEZnVHFIqWbvvGlsTO7fh8WwqchDB4NUqi3OYIvIaDN9lm7QEB0fCSQ/Y77Ui/REGNpcZvYUEVz13jDQkZrlLrciglcu69l3dCQyPpdhQa1YPZeQAn48v6/2t5W9xmhjpDGGajGYiCCEjOKTY9UMUCkeGUgZ0peNOToytmntKkE0Mp5TlmVZVpj/qywrsjZPqds8jaZVZvBoYVWkWGv2Z0eSFXZw4vbIX0kY8BiMdS4V4kJ2NnHsChjgHTuLZ2bkH6+xczrmdJ9DjEnNWWD+Qk5mnPK8x82GDWy1GCCtlKqK3OmMzogq8zRxOzgyIvfvW7Q99jwaHjZ9fW0AsCCtgwhCzUZEc0xE/IP+54v57FHwtPcy1a3zMaX7bz0FPjcRnEokc0XDk5owZjQ9JhmsjDEESgo3b6pdIMtVt9ZaqUmsVgEvjIeCELKikuMXQBiUSIEAENqjPc8bm8h3Z1K5QjG0PFuWFZI4VLpxuk+n6XQFHN+l6fcHzTHYmFRCNS5/uQH5KwDD+KP7cn++3nnVSitgeA30KMxI7C+ZtzxQ+NHh4N5npAOeFM9hAlK7jCwil6Ph4UWwFBaL8tFHg02bWnYJ27ZdLBY7WUadUT6ThWg29mqR6Rvuw+BgWwAMQDCHOSNlS+ysTYqmriCAAPoSftbb+W3j7ZCq8ySCBVFPKjFaDOKJM6goQFrKmeUzAZiNef/6Nw5MHD2YP7KvePigf/SgGTpqRj0KekSmjmc7/KpRmlCcvpFlOIqJ0JYOQ6UGR8dtS/mGHUdFWUMiFtI20wfVf6nlgrRRLLciuJZsXP42soLP2ODSlqT8g9snbtrkfnCru8qhvJ7xjQSkJW4e0W+4P79zODhvubUlKTwzuavGGFUJ+W4DCI8eXbTzTmu1a1ewcRO7bmsbcBxnIpcTnU4UT/kRVt8zxriu22AmsRgZlvv3L/qek+9RsdjyJTB1BiknhNC0PJxGSnOUoE/l0//G/D0AXV1XY0mI4GhRJuHkfA41Lyje8WHxC6C2BGCwBdUnsmllb7D7jdIEUpYlbJkRyZlAGO+wO9MXZmZDJJmVUlorrbUyZrxQlMNjlmVJVU7YbYv1YC7vLYdf2aK98jd68sdr7Gv3el96ovTLweAjJ7gvW2EFjJKpfqMiJAS+st97+4OFMZ8h6ZJelZQ0GjAAEwZ7GyPadvH7YnxscSdO9UQrDPZ9P58vFIpFrXU6lZTzXPK+M5Y4fSdyeWYuFksAXNdNuK7rOnVITMXiUqBveWeGh83KlXPfji2oUEkGqa9Bp0tPBmvw+8yH1mBFAUwNGK5nrbkxPdoLcxPB0XIlRcKSJYMoNqgqVRXHViGOqtsHQeWIMltYs95TzPo9hRAcxjRLpZQGcxAEg+O5sGIzUfkIyt33UFDi4y9Y4C8f72mTtFV75W84PINzuuSZ3fLu4eCxnH75XbnXr3P+cYu71qWcnuzq4QoEjHc8VPzEY0UQQRIMLu6VQSVjOCr+IpRoSwSWGBtdCtOnemKXv2FjIwzWWk/kcsVCMYh5f8cncomEa1sWOuOpNzzfLxZL8cuhWCwWi0UAfb29yWRiupOCikVr9xNL5yuIfK4tsQzGGMMUmqElUX2YTaeahFyJFaUZtG9NEdy4lkWbwqGjRSlHFfN+HFvtEmOLAGAqdzcQUsqwdEa5pFRL5ZSrDgRz2VYQbjxcikrERBRBzn1rnU+9PLjiz/T5f7AIDDbGVbV7Kc5R/gLQQFLglSutu4cCKALjy7tLPz/q//O2xB+ssnxGySAjsado3rK98ONDPiSBAIPVCTo9I0uxsnrGmEBr0aYiWGJ8fIlIGLV3j7/5uDrhoEII3/cPDRyu+WqhUPT9IJlw0RlPmcHMhWKpboowhxNO2LS0DGmt1YH9WErhe+1KPmZmrY0xJrw9p1kROG2lYOpk1lQacSMieO6e4Gi5a0lFvjlGWlPPpoCJQjqGYaUhgMv24Up2UMvfMApRk1Iao6KDJaWUUk2G7WX6zYbTrP/5e+hAP+M1C6yAjTGphFVf/s4qeOuQWDNe2G99wC7lNYMARU8UzKvvzv34iP1PxyfWufTrYf2G+/OPjmtEXR0Nn9OlVtgip5kr3t+w7LatEu258nO5pTIH+b61+wl/w8YqBkeFzzBbNYYgCMYncpZl2Zaijlf4yY5ezw98369vB7IrRcgn+5ZqLQ7sX7BqG02MQmHubmBHinHPi1dEmF16NlCfstb6zYngOendOoWxbDnuGT4Go66qARwJX2bWUkYKuFymamqac4sMFuUyHWUTN0CxIhtl4qw5Qd3/Y+s774NUwXmvWoD7mii02xKYqfdRo1K47kLPYFtKXNonrz/olxErCMBX93g3j+qXrbA+u8eb8Aym9lS+rNeKd/tlZm2M1rot8VdLbRqiYlEOHApWrylPmpV6atEK7mwzFDN7nuf7vlJSKSWFQGc8uYYud13Tjbhgqk6YcE7DuvVIpXHk8AKn3s1y8s+5e0R4AYQKuDytNWPybRaZs0ZjzbSojeHQSVuNl0ohrY5pEazC1n6hoS/soxBVclbKiqzQrX3JeBejcEo1lWTf6gYM6V5IJiLruvcaJ2XOfMEClNWuhF810XqhhYUMCMIfrLSvPzS1fIRFj02Yj44VIQlTYAvLogt6pFcJ1Josu92mIlC09JJo5cgIXBf9y2cKqkomk/l8ftYfNOzIFdbrEEKEWfodeh2jwxjDhkPnS+OhD8lkcoaTTKK/H/39GB3FkcPt6TvSlllo7geKWRuttbHqNiSoKWrrCw9qjamzfusG3hhet6bWmlKQo8gzc+2+IMaMyS7m/KDC+S6UqcxRA0ERMjje2KD1LylEWDuxqpx6WGqjHAalPUiAmAw73/q7UqrXHH/h/DE4Qtpk+BWaCb/ihknMZRF8RZ9anRQHCgwx9RSb7ns2OCErtyaFx1McwGFdz/Z8f38JKYDQYoiVq2RvvW6pXdnMrACeQuJO24an6ujKZmZbowtdXSgUcOQwhoaWAoTnPqFN8XbPswhulKkMEGyCZugmRXC5EC/PuHLSlsV8QEK0jAn3Dk+M6PyzEov4y5ebH1iW5TiObUcP2w4rRErZlr7Zk67gcp8FSVEWF7PRGhMDJAEJSJAp2l9/Gx18CPNZ2zMMfnYktRJ+1eRCn7HCoRcst9CItYn54h6ZVRSdfFEIdGiimPsgb8mUckynsX4DTjoZvb2zGhVdtxNp1Rlo23mSSDR47h0Dg5nLXek4zuD6UxNj9uwOrvV3zTapNd/FgAFsAYtqffoMb5SAJHDdvXMtJQnx2ovNkW/EpL85gcUuHV3uAxhGXVmxIWP0pTn6gGPVwkL0TnaxqPRsEEOPQXLEYFEccr72Fxg/Mo9mnzD8ymm++EaT8rcia/HqVbalaPafXODZyyYdwmEDhqi5xZNnpkynsWUrtmxtfPrr6+3pAKYz2nyS2PbiYpjb8TChub7SGm46kJrNomwA3tzIHEiMMJdSERwBWWdPuCx8FVWbBWt+EgEJJXhq9nOjk7/hzNcmRI7ZQlU3gQVXwJXeiiGGw4eoREiJNoWZVbVYqOroaby8OroDEpBMAiGGxdBj9rfeyYHf9kNTvmkyRoCdWnWVW+5xVOcCE8BJabHSFbNviOjafd7DedOlSFSSgMtRcqY9JmiWi+oWjdCbTjc5Vdr9y/rQGZ0xw+hf1hfFPx8zGA5r283tkcsXoubo8fly/kRw4xNm2MQQgACcihSuubIArFh810zmwmhx0lEcqf7GMBGulvpJwdnuV459dSXHhQYwTW2vWIXeuRf3im+hSk+XK1Yeul/l9pMM0csoP4F67Fd08MH5uD0Jt5mwJNGc5G+9My/2Wlrikbx5xd35fXmDWdlH+M4B/5LfT3xpn+dIcqKGT5MX2FyHsZ3FmSDDaa559MbYnc62qYlbZzzJRjqdTrd6Xi0ihs1MIWPNjEBrPWVyaIC7CyWCmae4ckMpLKatLKkqEWSKCbrGvjEsKSxBaIa+zGw95Kd/VIgvWUwFXIXJ6aNdn1RzyyFWEo//hKSBBETEYKbwz6O7mrrBafA3CNNqk3ajVQy51RUISEncMBg867aJXxzxuUHlqehQif/0vvyr7s7tKnCXIkIlauwYHVJizdq2TG19vT093d0d3nRGfGSz2bZZR0IMbzsBc8R5IxNLpYncXG+pQ/tz2UPLTXN3PkUwAXoqqwmwRRm3YfSVNTURpIq+dUZSCNOYFboc/jJmur6WQzSPGhNZDhYZwIs1qDic2HMDJEhwOQgr9AQLJgnjFbjdRycMv1ICdq30X274NJxV/lqEhMSndnsvvCO3J1+d6Tv7LyPpfw/6l9868cW9JYtgwTDzRKHQBo+Rs7AKuL8fJ52M/v52ba+7u6t/WV8nv6gzAAgh+pf1tT8+IJHAlq3YtBm2PX87z22KKxyZyMWVXLOG6OjveRLBhmvEMyuCLSAJFtXIBeHGGJ/Ssvd/Su7tHo3Njglm7vpGTg5OyphAGKM1x4wHC3z2qsW6bKIvnHjkO8ofYhmqZGYKxTIAMHGQ6GJjqNJzqS2KPLxhTDut9D5qfGFSYizgtzxY/PKeEsS0G7xGfx864pm/vD9/fY/+m9V6hUDgB3DnnLQgBAtBC6CnwyDneZjC0um067pHjg4Wl2BtozmpL3sBbiyCIAieFGlaruv2L+trY4fs6hEmLB06hCOH56OGpU4k2jLlT0rhWSHUZErSjG9sJNu3slYogqcLkJppmGVmN7I/DMpK2qp6P5s3K4veNqt0huMfr0xG1Dw+yZuK7n1TTnstuVzNY5EUsFrc64fyR9IP/ydE2IKDQChbpsNjLpWXWS20FkJwO+zh8e4LCWtO4Vf1FyYlHsqZN9yf/93RoHbUQRPHiCHx4wH/1oOFtywvvSnVnhRedl1qOK22lSEl1m9AV9c8nrtKrVq5olgsDg4Ne4ta26iKmompssa2rSqmhs1IlibSpt/QeJ4XL9ZU8rzIFRI2+V6cmUupvt6eZDscqLOPlSvR24v9+zDa5hYm2nbaMvWPjE90dXdX5eQwT/brayi1t9ZKc6wlOflNAdOwxZVnnmCnf0Rwmhp7mZ39oe/e4bl3eCYjvBOt0pm2v9UyKYqmffWon/1B9blttNZaEJGMdZd/8gM4omDqvn9V3iBLgEDEIAr7cRAxE/mZtV56haV1WA+kLQcodJjYkpQU85F9JAgu4fojwZ8+kD+QNzXoGzlGap+n0yxBhhEAzENF8887i6tT+T/ua0OEiE4kxPwBuL8fK1dhQRoFuq67ZvWqYrE4Ojaeb+s3irBq23ZY21IIioJsF0aqLoqmnHXJrKo6bA4Yp3UbDRXJZLIrm1nopHDbxqbNGB3Fnt1tlMK6HW7mfOVoT5+R4gyeJxHcYJ/gMBRLNDZ/c+PltBiJLvvgBZ57J9lHGIAYN+5tJfe2kukS3glW8XTLO15Bc/fX8jTtdwurG4UlKp5aCpiZ5cCtqT3fYclEBAITQEwgRpnHE2vOCVjI9gVhRQELCbfRL96U/BWAp/mfd5U++HCxfL8XVNYNDTFEoPLpOP38sgTO71FZRa6ghERSUlIiAeNyID2WJTY5P60Lbbll1omkhcF5mafWb1iA6JXpkHBd1xiTz+cLxVKxWJzVxBrJ0FCwhkWkn8RkXQBJGsn6megYKeZQVevKn7PiWSnlum7CdZLJ5GL+Ol1dOOlkHDqII20oURC06TIZy0006LtdRBFMQMCNWgMNN6GtpSCVwKHXq3Uf9uN3G2LUuLeW3FtLukcYB+qIqXlCcluDfI8BAJetwNpP3fXPIEMKrDn0+zIBYCIwEUsxuOHZIozAOrpfHtkrRwcJgJPiDcfzmuNa+FwAbAyYE3bT4VeNkFgSfjmkH86ZN290MhYlBaUkkpISEglBCUkJgZQkV+KP788/OKqnOIY1n9WlbnhaShAh5hrRWnu+XyiY3EQwOmrl2tTFSCcS7XcDL6DwrTmEEPFclGKxaIzxYmW/QmtwB7GL+AOFbK5J6Jl+r6VVAS2M5+/qxp7dc2zqoFOptsz7YxO5uvNeKyK4nuhsXgRHe9KgFVrMLIJrLsyknP2lscFni2U31DiectjImed1xqLRdxEAHH5VY4zz4NetQ9tZESmewuBQ/koe7LkoEJllv/5Gauctat/DlM9BEwzYAMLmZz5Xv/Z9nMg2++nM7CiSQjQbftWIJvYYV/SpFy5XdewqDEjgFSut94/oqpcv6VWOoNGA41TUmv2ACwHnNecMjxRLXhBY7fAg6nRajY0d08J3VlkMYGG8hJ3x1Pq90mlsOwF7ds/FKxyk2nO9DI2OhXX1411zWpets7UpbHmhRY36gAVVJy/VD8VKOBZrPXChTjwiU7uacFPy4iUgLaYCponD7q2fYZ9gGEykmCRAzJWzx+SE2ju06ZY/U/nh0H3Pomy3JYC1Rz/+njqwy/+rz6J7ZeOfG6Z81bQ/N1hSo/4gBgN5XTt/PHruCH7xcuvDj5eKOnZaCbq4R/o8eybA2Ph4XzsSYXUi0R4Ad3Vh/YZFFL6d0RmLI4U3bcbQEPbva8ErHKRSpk1mmMHRsWxXd52edfPrCa5IyZlEMFdqYDWVCBLWpDSVLg6zAZuSthoaz+15vtr6ZVvlGv2kVb+wJg6geLoxW3lR/LELaoiLXLDObz8tRofYB3xiD+wRa0Aw2QbM+qAIHhOpx3dY3jAEygU6yk948vk996mPvhEjhxrPwg7tDQlb1WHqHAOhG1m5ZHBSWl7UoyZ9HQarEuL0jCzNkEZQdo0DRDQ00h7Z6meyPMcpIDTHbdrcoW9nPEVHby+2nYBEooWrry1FKI8MDoUN68Jmc6jMEi1PZTPV5Wi8iEfV1iTBFS2mYQqCmgb2mhGyXamE53kTieLuywuNb98ao57badUXgxUfyXd9s2A/6FNxQQXxQnvCmFkceMC+89vsg70KfX1w0WcfejQVPKb0EQEAqsLayqPynEMkQ4G275QffiPGBhtksDHGVuX2R60Vt2oHiZkBi/CKldbkUsPndMkVjgimRx9Mq+I5ODLCbRpzMoLZNrZsbWN5jc7ojGNy2Da2ndBUiTejrCCVasuHHx0ZiQrsl9E7gwhufOJqeWabvppFcEWjwc91pLCcbSfTSVcSPM8b2JIfOLXpkHs1xMnflnr+fbz3mpHMN3P2Tp+8hSDxwgE4mvTtn/4rSgF7BA/sEwoe54pwt7B7OfvbWKRImbAO5aTerX5weaGC2LlTffitPD5Sn8HRpyeteQm/ihY1uHLB8JV9anlCRAnnl/ZKOWOrJIpX8hweHWvXj+K1nKfb1dXajX9ndMaTc6zf0Lgjxuvqatc99IEjRydr+ZPA1HoJiyuCXQFHoC2ptWEpI5p5T4QQ2VTSaB34/iMXjkz0t9hxVQ6axK+K3Z8a671mNPONnHOfJ8bmsWDRgpugt/+KH/iN8Qg+cQk8nkd6g7rg79SZfyX6zxD9a8WyNXBcEEesRQ0RHGOwgNh5t/Xxt3EhNxOD4/Zn11bzEX7V7E2ib7AuIZ7Xb8EwGJZFF3Qrz8xYxJWICCSEICFIiP0Dh9vSxUw7jm4BoitXdczOndEZ1aO3F1u2zlr3jYXwM5m2fGAuXxjP5cNpIeoyN+OMtFAiOHT9JsRcSxBNl8KSIGdwXYPR150Jo3y01mbOnX7lEZ34dTH544L1qD9/bYMXyO9c9v4Gvv/9z6BExkD5gXKE9fQX2c9/L7nL9d77KPCELkIHCAIztJc8v1wPC0xMUTxU6NUPhSNVfnBxz83qk38TvPPTkGqGMAQ2xigBJUQjR7NpEnNzKzOgGa9YaV27rwTD2zLy+JQozZi+N6WnMhENDg+vXt4e228p25UsNOw1CZ2+T4IG5p3RGfMxEglsOwGPPoKZrymvq7td4VcDQ0PhrBBvsk7TRPBcwqEbfWPsBUVItCp8uUpVT+tWV2ez2VTKsayi5239VVf2SOvlb41L3iZRPFl5J9p6hSxn5zDmo07WQgA4ir3y7vx56eH7tCTtm9TqtH3BBdZpz4HJQRrRvxHGNyYgHZAOyAQ8tJ8CXWYwVwp0hGZelUCahMmF/XLZJy5C3nUTf+0T+rV/i2mhgJN1p9uU/tsqtqe8XjR8frc8KaMeHAye0aOyikaDGhugGH2jy2zg6OCp29rz6wSplFFKNFIZWEps2doxO3dGZ8x+mezfh6GhmvK3lM22q/Lw7v0HwypOYa3AaK6YMYC5rTnBNYcAbJpS0C/6rvHcELtmAwbAm2rujb4JTQPw9D2UUmTsROYRtXpnugXbbpDm/Cbkt4niVsm9UgghJZMxkYt9PmpVLqACDoLR//2KyVMqzd0bgvQJUiQmzMD95AcEUGaTWLYROig/TGB0wCOHiA0LquhcNbL2lKFNF+Q2nLr1/n9Nj+6EBhvAEDS4BHHrF4oXPYc3nRpncGR/ZmOStr2I9ucqDmtGt6KXLFcPDvqX9CpTcwscY7AQ0cU2ns8Pj411t6kzbqmnN3Hk8Oy39vPcGaYzOuPJw+DQHzytYJbX1cVtkr8T+fzR4ZFUJiOEDO/OUQnFahmxjeQE19+CBhcMVdXbpamEZiAA7GlvNjw7+OvvzFruTdxYbOreoZANRtf7Y5t1fiMjI6VSSinpSakUM0sphZRtbAW00ACO1Gd+xz35B+/tW25WbdFOH3hiyNAOYQSEZaQlhE3ZtUL7EYChA6N9Hj1KBkapgY0XHdz6zInejUSU9IaShUfDH5YITAwiciBsLfb8Lth4StXdSsX+TJaSTdifuWG4NhN+VSWCr+q3vrDPOzMji5rrfNykApZSSimE2L1vf/eJ7fEkeem0NT6uioV69N2yteP07YzOaGKsWYtEEnt2TwJGqUJ329om7j00UJ4NpJRCRiboWUA1ZxHciBV6OnqrlKuuxVozc6X82RU5AR53XWfw/7P33XGSHdW551S493acvDknSauwqwRIKCOEJBAS0c9EgQ2PYAzYxjYYjLHBxoEHJtgYEwTGBoMxWWSUEEIoreJKm/PM7OTpdENVnfdHdff05J6Znp6Z3T6/+c329ty+fUPd+uo74TtZhKppwlOX9nRuzWOMCSE4EyIQQmtjTFlUtehRqGhgX1sYrpcL2hjhic3b3FQyAwA6h+ghYC+xZ4BL4NIwh3GJzSvKLmjUimlljOlNrD101kuGWzYiIhiDiB0n7+QUEa+QVgYCA2gQh05Y8fey1mB5BeAKVhPWWy1+T8h7R/8tMLA1wf5ko9vmYDRJ/87x/mfGOWOss6d3x1k1u0d+S0uycxIATiYbKVcNa9hszGZLlDC40NpWw7Z3ew8esQtyIQTjnCFDxNqT4OnA2GNIVvOeyklY0ytTmokaFBqaoOQXJ8feMX/Bb+bh8QgSMwDIwdZCxCOuR+HgyJRrmDGGMWYRZOkx4JEulcaY1dt6bvqI95M/F1AAAEAGaAx2My6BSWCSuMR2yVpXg47AKDB6kCcOrH3ByZZtlZkFgsKVPXcAB0QAJCpWvxV7ORAiGUOIoxtSkzEm7rjz4n+eg6aHrZN70xpnMvJLFQMCETkrPmyc81yucLSra82KFTW5U8rzlOeJ8Zr4ra2wbn1jIm1Yw+aIwcrzotrJbHb19uWDIJlMciGKJJjzMQrntSHB06Vi7c4cS/JYm9uUFEIiIoABUASBmeoYxncINlUIT076VwT8bYA/KkB8gs9FjgYAGU5AIVAVcar4u/RijJXhbEnGgC0Aa63prIsP5f9s3Z0fkRABWgzWNHwCmANMEpPAHGw/h7WtzQfhvow41n4OMc5KMXBrq07+IqZOAkfCYtOkonseARCiVIfWeozTgIgYgCOr4nAz9j9Xhd+T5k2X1dqmgW0su59LC17OT3R1r1m+vFa3Kd/ekT52tIG+DWvYfGBwnkwNi1kOHD1mcVdwUcTgkosMJgGJmpNgjphV/ut++6HuoH9dbPnqWMf6xMoN8RUbEivXx1dsTa1jgFP0ZdKjezOYWeBuGcy7NftyrighbX2JEkNP9y/Pd63KdC/PJDLy0js2MjN2B7as065d7PUsT7OswsrMeIkx4PKywhhDZLTW/hmXHgjefcYDHyNUgADICTXgkbIXOiR5MFh26EQ20gnkaC8DZxwQGWMyGtzQ/S3gAEjlijeEYhgYAMK2LUZr67Atr2usABbDsToXc/E/zy79akIz04E2jlTaM1bMEhAM2eETndu3bknUaFmthfCbW7zBgQb6NqxhNcfgWBRls9ma7Cybzx86diIWj3PbRFMILgQyhjA//eQngT6B0BcOdQd9g2F2MMw8MviMIQOIQOb8ljN/fsWnPS40TbobW4o50vaNZoG9QAgYEft8Fro1SAQCWCVOrsx1tg71rcjlndBWBhfi0Z6ze858fNnYj7tMSClKl3HUCy4sDFf6X5cqAy6nIhtjhrdcutvPbn3kswI1IBnkDCMYPBSx1DE481Bf5Ouu4nqEMc5GvCuIuOH41x0zALzcPBjIhoERACnyWvKtW6XWnHNWch3YDgwxV87UVzwXTIVZ5WRNbawU8Ck/coyxg0eOnnPGtlrdqUJTk5PNMKUa6NuwhtXWpJTxRKIm7UT3HTmKFWtxOxWwUiVSNchVk1QsjnCi0JNVBZfLSuzPqsIyrzUhRFSFF9qKddCUlGaqozLAvprDXRFtlXC2pB0Stsqug32dfRljjHWEWgq795zeju5k28lRdEUI4ThcSCmlLM6rNqONjxhOElZfOgy4Aobt6/6tV+4x0fYnP09oAMmXzZ2xS4/EbvB1GyJa9m+vQpHtcc45Tww/saz/J8ArGhcCIBIgEgIA5FZfFPG4sB2mKrz5xhhbAWx7HU6BhLVnvVP6n6t9v4IB2zBweazsOXS4hgAMALm29lQu20DfhjWs5uY6DhDNEYPDKHrmwOEiTZNSSMk5F1wUU6BnXjg06zc5wtF8t6/DpIiNmfE2xlc5COF0nNaUvNBmoi5w0x8VApzQlGD04SbaJEEW3+tY1nKir9cmT40EIhntuuTEFT/aWBkMFkI4LnMcp8iDuSj5GXk59XW8tslSAuAyc0eslCxlvVuvfpqZjs77+1ad17384tBpRRxxOFcu7oqrEqQ1+z+Hxlj/M9n0ZyxTYSTBTm58KRjDju91Dj8pD+1mvV0Qhka4csOZ/GWvx2WrCSD63j62pUVsbzM0Q8ycIxLTTDjxhBsjslIMWEppr08YBPsPH9m0fl2t7pdJJGjFCmxMlg1r2HxgsOsCwFww+Kl9B5TW0nWFlDYALKz/uaIlcO1J8CR7OZzvnGCuItqYWFnNCoAAlAGHjQSAJ3U2T3ZkK7l5ZRxHT6bNqZTkQlfk4ZIxhozfrJ+6+OSOe1eW32ecSymk40hRXMqU4+iVVollSwyAYSSruwgeWgitNRnTvemazg1XlRZTZXQegV5Z8s4zxpoOfMfreZIEgiAUMCIOZjFYUEae4Zw40vq9f/eOPAWhAoNkADQwQnrwF5lffS/+px+TO55LOZW5/r9T33sF39lBNEPWy4pOj2nxtobVTZV1wKx8EaXkQjDGGeePP7N307q1NblTnPN0KjV//paGNaxhrusaY/KFwiw+G0bR0wcO8hI/kY4jpWRCzCAFes6lR2XTAIdyneMKh0gwsT6xspoOBuWC4PEFSNUeHk4wn7qObGpKDWfzZQWrokC01ie2ZTu6Mqv2FxUUBOcghEVfKSXjvD64OwZS5pkBlzJ4yz4TaX8LWQp4CymkENJxXNd1Xc9zPS8Wi9kXrut6Jtey6/MQIoUAEVIEAIAcgBM4hAxML3N3HVn97X+MHX0MSY3q1oCEXsx0Hc297/XhfT+Qzz+DTuQz130tuuOoTZyuChcRgAFlIvVfT1M+qvZT03FpmvC/NKUjmvPy6kRKybnwg2D/4SM1uVPJZLKBvg1r2HxbLBaz7uiZ/jy1d7/Sxi7BhePYyKVV4YByJwaq2mM3o/YMo+kKAvoajuS7ObIx+4xxd21suZ5un+UyEEUTJ6LOLo2m1JihyXVdp4QmFkeElJyLZy7pK6SLyruMMRviLAc6xyRezfd8WI9uSCPoK6SU0nEc6Tj2t5SOEFJKp4S9rheLeZ7nxWKu53me5ziuELLpwS+xwT6KgCKksPgDQCjADGG0l+sjnPkBiEm6FiKgG4MwzP/129Wu/xUXbTY9w9mbvhl+45niGmpqzGQACOoH+wvP+pK+9zgm5IQ5AzXUlB6/T6x0I3Ahy+sYIRhjjz+9Z+59zVLpNG+obTSsYXUxW8I7U/q7+8DBcnjO8jYbocPRMljT4O4cJqIRbxnCcFToCvo4jpo0NOlmmVrutiqqNv0lounrMGfqcWxJp6TjeJ4Fk5jneY7rOo4jpTQJtvuK/uK071RWG9UPd8s2vy7oERZfwuCyqCZjjEURGWPj5MjYWM9zOR7evSf28LcIEAjQABlCY8gYCh3TC7qfgQaQZBWhi19XvqOVXRykAyoqfPZ9QC9EWA85P/eq75qTz3f/4HzCSfpfMkAA/URv+KF71f88BUzIH1w02cZVc+JZfgorSoHtOoaXXAgF399/+MjmOUSCk8mkaKBvwxpWR2tKpwcHB7Wptt3sk/v2K609z+HW+ew4xVDUaP/z1OpRU80wM3mTM+jy+w7lTgQmIgCBjCFDQE2mw21uddKapt9V5d9mUQQ8xUcSMS8eiwFjllRorXnJvay1zqxXxy7IrXkoQQJYHeG23gBcxmA7PkTJ5VFGXK11GY/LBVj2pUVfIvJ+8RkohCCACMEYCAqQakJvqxkyJn8EeZ7QtrWv6Fo4OjSA1tliAISEbAAt38LV19Hx80AX8u/4senOxf7msrGwygABqN8PPvZA+MkHKZsHIPmqHWxzE5nqUXOqIPMM0q8qeTBjxUqkkifflgA+/vSeWQOw53k2N6RhleYPHvIHDpX/27zxqsY1mZFlO3cpf7A40XjNyZU7G9dkzOOcSqWGhoaoCn3KbC6/e/9Bm57qOI6Ujn38BRfVlMrUPBXLEMS586p11x/Jd3b5/b3B4LDK+TokletwWxKCl5SwCKdBXpjFYU+7mOCMJeJeqIkxjoicGyzJI6JSQHT00kK6x+Uhowqcqj8Si7oNNcYYcS4qmJxSyuo2l9+x0Fv2wgOAeeY35rE7lQBBCKEPDuPbr+MbLqNsFsRe0Mr0HcUwHNu1ECo6BxMBYPG1BkABzLAdvzTKoe4zEXz/w3fRybz3mWtBMDBAtsEDQfiVJ4O/udfs70GQCA4wEm87v7asd+oNaDz6lqPpFoEdx5FOIIQQIu/7+w4d2bxhxhgshUgkEo3ZsGzKHzx27z93PnJbJfpaaz/rlo7tN6+44NbGVZpq4TJw6OAvP9T71HfK6FvG4Pbtt6y84PWNpczINREikUxmM5lpt9y1+xmltet6Qghh43eOU85Rtak21dPKGadijXP7hYbWxJf924XvDgxko6AvHDpR6DleOLk7c3Bbcj3ZAtTqNJxnsEEVXHnEqxfzBvOh5XKmws3AGLNqiYdv8GXcZbCQWS/Y7VMdvqZSlMroohljyiLX5RTfcukVAJDW/sdulQd/KwVJCr0NG7yXvpdvfK7u3GO6njEnD5meg6b7APUfh0gRIWgAg2DA5j+DATBAoaIgAMNRxInIvgmoSUn67c00tBYgIAjlLdvjX34hph0CUPceDz74K/WLAwho1ygEobhqi/fLVxa92RN1uByPmmUGPMlfJ3pNU+2TiJTWKor8QiGfz2eGhzPDw5nMcC6b9QsFILrlBdc6Us5oYdTa2tpIvCrb0Xs/cfAXH1KFwake7JU7t7/iSw0+N+Ha5eDPP3T03k9MvVnH9lvOesWXhNfcuGIldpsrTJkU3dnT+9N7fu04jheLxZPJVDqdSqWT6XQsFnc9z3Gcon+18tGGsZ10p3o9eRcjAAADzEVeQmEDQHrE2YiAHIEjCASOwABCgoImNnIAOP5LJ/ginG6DiU5qirPLh1H3cEFKaT2pSqkoDMMoVFFkPa+cc5uHZGPDNrxX51vP3/P+v6oPAy5zOEBkiGX5TTEi/VXUHynHwIPHf134zr/pCFCyxIXnJW56A19/IXjNyDgYDWSKyYEqhDCHVF4YVbQhDPKsqUPsvFqcey5GT7J2YK3EmgnjiLEQ0l10ZCsYB4Hrpzv1r0+ys9rCv7vf/4Ofmf29CE6lUqnzD9ews9uAqme9NfY/QykSTESGqLiKUSpSkX0ZRREiLu9or/6+NDU1NRKvyvbUN99w+M6/N5E/9WZhpuv4/f8Wa9mQWtXA4Ar0LQw+9Lmre576zrRb5nqePv6bf2vbdr2bWtG4bgDgOE4YBGbyYPCvHnykEIbScVzPi8XjsVjci8djsZjjuFLKyjkTx2HVpLBa+T5OimfIwPi05z3H++7KBj3KhIQSRYIL6/ZmSAyMIUMQEYQGQgOKAMceAE4Dq9Uh69SrijFvMoYZPyw2Sx65PggVvdUrJSdtDVK9XSD149qlHr2MMdutCCsSB8bknhERaT3w7a+QD21rVfv5aW9rC2UPmy4P28/F9FpmbNtgDVqBjoxRNNSDQCXHM6KhwWWb5BWvXHb5Tdi2Mrrvs+rYf4JMkwYwiEkiw9nyLhjcpR+8DCBE8NTdB3OXHiWKEMTolpKKn7lC3LR5ClycGjVh5hvQFNeQMc6FFOV8cjeUQSSE4vzxp/dsWrc2WZ06dCKRkDOhy6e2Pfnfb+h86LYZbU8Eqy66tXHpLPo++Nmrs527qtw+yg8+9NmrL3zLHY1FjLV0Ot0/MDBhMPjJvftP9vXblCtbMGITennJ/zyp/sY4X+0sfL9EIFPMPxad+PaAEFwkmLNMxDY4ibO81Lle8iwvud2TTWzSQqIF8kITAEcmObNyHFaOspgFjMi5NsbYjJqJHfinHgBDZVL0mHaBo/9q/dJhbxc7cO/qs1V6rWF8QHc/yRQAMmASmcTm5agjphXoyLYvNFpRpt/Cb6Z1w+Ezbuxd/6yLzj0L29qJjHn8u8AlICADAgINCEiSs83H9IOq2NChmOglx91LLd50Hnq8uEKdJ/2N6rjyiLve5mGVCrpEGPIoUlr/+qFHrrv8udPfeCHitWuOttTt8D2fOP7AbTP91DPffXfLpqtirRsaF/CJ/37D8PFdM/pImB984utvuOSPHmlcPesOTSWTw8PDY69SFO3a/Uyp9Mg+7m4pACzHp1/NTlJjqlQsAgRIne243yWeJDA6PKGCw/7AL4ZsO/b2G9Lnf2sT8rFdZWZ5JLNriDTJXz3Bs1HxsJAxXppCjWElAGaVKUenOABXAm0lBo8aQCX5ZpZMr3nxtemjP9A5JENouolL27jQMId1OKxltVEKjUJd/A1GF4w4svXGExuuNFwKxlqa0gBgjj1EJx9F1yWbkGV1pK1Qd8IHpsDwSZw0AKBZe7N4zXaaGdbOpoNDNfhdTMWyclg2D8t1Hd8JpQyF4Eqd7O07cqJz7aqVU9+CdDrdmPXK7G3fjz9EZsYfDHODT3z9DRe/7Y7T/AL277+z+7HvzOKDw8d27f/Jhza/4IONQQgAnucFQRAEQeWb9zz4iNLaihU7Re7rWk0JViEZMVMJyRlhJAEIQQ5EHExRYkFaXAaKKPfrwcKhILnVM4amh1hLgQwATYD0s0uHmuJzrsOHA0VEaOf9Egbb9COwHW4qHNSnBQCPp7zjlmNkjNFM9F7zgfz/FjoGfknIAI0ZPs6YBC6BOcQltp/L2teCiawvWhE70rbzyLILQzdtd55KJlzHAQCz6ytgfJApNEBIoIvRAGJUkpOe4u4q+ertbFlssgl6jvobs1J7QUS0mpRWwCT0vDAKwzDUSmmtH3zsieXtbVNkYyUSiUbot2yH7vrnKD84u8/27b1z+Piu9Oqdp/MF3PejD9FsUzkP3vmJBgCXLZ1O9/T2lpnJkROdRzq7SsLvUjqOdF3HdaXjTFF9NBcSOSlOSONAyEHQGKIiQGeNvyef3OpN8X3FYiQEQFDDRqRHoo8EY/F41guFCQCYCyC/LD6BiMbKHpcA2BaW1Fl8Y7EA8ITQWzattSboed6funcXUifvA2SAmvCoJcGWDWP72axtHWndGfB9/IycSCBiubC6SH9PPmn2fQ+9OI0MHCo2MeRkCnEgMVlPXgDD0knx1p1UoRM5U15bFabOJFerGEdnjAvhSCeykWDpSMeJoogrlff9R3c/c9F550y4T8dxGs7nSjt2/22zoL9lO37/l9MvPX0BuNB/qG/vnbP+eJQf7H78O8vPvaUxDu2jbdU5ACCMol89+EgxNXUc/eVCcM6hatiYkxcaQMZRUsQrtBVK3ktgkYr25wFap/lSBMag+59P9nyl393qumd6sbO82FbPXefI9iIbIABjaoC7I8SdM8HRGMNKaxqbEU3lmuAFVeFYdABcHgvGGNvHVzOx7+L3bLznQ82ZRwE5YQTsIHBpmMNQAhPdsGZPVzgYNKEsNlPC0QCs7/t7UBmQSTRU7CGMgEiEiNJQTzsBH9HQGgfAuLmFbWuZIdbOl/95FAW2SiZCWMW1MAwdm2GvlNb66f0H1qxYvmKijOh0KtWY6SrxI9d7aC576J0D/JwC1rf3TmPmtoc9dzUAeIS0ua7run4Q3P3gI5HWolKq1/NczxOOI/lMor+18EJzYVyMGJSlpkf+rkGpQ1mabp/IwL8/l//0STck1RX5v8z0A5DHWLuQa53YmV78LK/p0kR8m0tmOoidSW6Xy1lBk+V2Zb0wrABgWAj9jcULwOWKYbItpIg0k09f9CfbHvj71tzjhnGGPrADgLILVh0YzPYHB7BU1GSTk8r+hHQyYfZ8mw79AGMJ0MWqIMQKDAamD63FqbBPmF2dwat/4H7+eogLmNFEMz/+Z7uSq0zFsiTYcV03cCMnDKOIKcWMue/hXS+85soxjuhEMtlwPldavu8QzQ0/ho7sOr0v4OG5XsCjuxrjsNJSqdTeQ0eOdnaNaN45juN5juM6JfnJcunRLGjiTL3QBCBi6LAIR6kLFv/DmaLjOQKoUEEatwLgQAFFn+xOI5lmpgxoA5pAaVKDKuqOhn6d7ckbc5737F+ewWM4fqad9Rk5kueiqDLndzLQbbigJ3DI2IuiRWz3zned/fBHW/y9EYv1sbOPOC8aiLZYB35ZRauyl4UjRRwD/eBHUXIqXvFS82AEQgSpoKvVHFkFoKYcfTz62qPmZM792ouxIzaGKlPVI3gWUE3TXp0KEuy6bui6TikSTMaMd0RzzpMN0atxsz9R4zLMAYB7D83xAjau/xjjnAdKFQtVpZTScT3PMmDHdaWwXfNqH/2dzAsNAMxFBxVONC8ZrrE7R5qKCoKTTFbmniHZF8mNjvGNCUgr0Jq0Qe2CiiMB9g2Gfbsz+f1++pwYVXHMHIslpwRAk0+XrhREoQ1rwriE34Wlv4sXgEuqi6zcfiByU0/s+OPm7keGW7fkvRU21luEXqzQkS4VU6eTcfPQp+nk05hIV/j7wSZdIRI4Onr0TAoTCME0BwOu/sW+4AXfcL9xM9vSTHrmYDnDzar5VDkSLKSUquihisIwdEOllFZaG/P0/gPL29vWrizKHTQ1Mp/HWbx1wxwJ3Gluwmue4wVsAPB4u+yiC3bvP1AIIymdYodW13NK0d8xibvT4+7MvdBjNuBxLhyBnI9Q39IvkoCDivIaUyM+wlH7ZAB5w/b48sIEBUQ5TTlDOU15YwpkAmMURIo6A5/nosIzuaZzYma6Q2II/Y8WokGd2ua6y6TgwBCglMtDFYfncM4AbBjYClEsLOVd7ABc7h9cVipRQgitjTEq1tK77ioi4mX5aMbLzblGOnMhElGCcvq3nweWhAhREAogbQVaEBFIaBpKqfvPxanpbwUGm0eO+9d+3f3GLexZKyYNGc++8WBVCD1mqio3KBRSOq7rRVEYhq6NBEdKG22Mue/hXS1XX5GMxx3HcRynMbWNfQDizaYBwHO5gLG5XsAGAE9oN1x5+ffvvMc6n13Xcz1POo6cqPZ3FrA603pclpDCddCxPWpGifwREvOBhhVLiYn94QxFd8hXO9QhKWcobyinTc4UYThnWEA9+zMm8F2jw305gGm0/BiD7G7/0ZccKPRq0SHc1TK+2U2f7aXP9pJb3Pga6cQYINh2TAxRcNRWM3ERPj6Lk/7aPslGay2lUyEZbbSmsrLJmA6GUvJSWy4KVeJHn6QwjyJGNgdekBUzJSRARBmFd+80mZZp6W+FOXR4ILjxG/I/Xsxv2ABTp85XHwCekVbl6L+WW1xIKY3WqkSCozBSkVJaG2NCpe78zQPPv/zSjo6OxqQ2AQNumysDbj/jqtP7Aq6f4wVs23pVYxyOtzUrlq9btWqo4NvcK1t9xMtOPpxYDmquAlKTeKFZXAjXAVmh61ymmYwgYJSdlJSgJq+Zw4UJyhuT1ZQt4i7lTfF3Xg8/0ulQSGDU4dw0awIEreHEX3d6Ge02M5XX0ZOq/+H8ya+D4chSzFst4xucTW9rX3lNyhAAgCNYPhqpr1lU0veLC4DLvQuJyBI7KpUmQamLRVnPkpeEpIttuYQollkTycfv9g5/BxJxMoSERIQGSRJyQAQSoTneEd15AUAegM2kX4ikvnz4km85/34Df+32YovDuZFamFv9UpkEF2uCLQBHURRFSiljtDFmYHj4yX37169d25jUJgTg9Jqdc8kDWrnz5tP5Aq7ceQvRG+ayh1Xn39wYhxPaJTvPveORxz0vZrUnBRdsEtmm2vLd8W9iXAjPGTNZFjObBIAmGprYlUgMnGHNDFELZ+2CG6KQitCb1SZnUMHQr/uiE0MuZ4ZrcyJnYFTzpbFcHCHz/UG4L9vczrUB7YI2qA0oAq1BRRQdCLoeyujhaOU1KbsfV/BsEFKDAc+IAQOAqFizMMYizisBuEx/raC2EKLYwTDINz/5GUIBAYBEIAKDQISEJAC5QVL8hR9KvuBK0zVYeMvP6GS2oulC+aYbANs7qcQ2iwLjDIIofN33ZFdOvOdi4lDKr64BEs/CUzdKGEs6rqsiz4vCIgDbnlOOlM+96MLGdDaZrb/09Y9+bfYAvOr8W07nqyfjzSt33HLike/McgHUvqFp7c7GIJzQWtOpLWtXD/qRdF0pnfHR32knnFmg8ngSTADoMR53UJf6vlbOSQQQGBg2E+yfAQaETxYihhhnxR8PMc1ZqyADPCIkyH5mtwhCnhCGazyZI03AceJmhgxMxqjbepoSqKVNpUZlQBNom1ntYqiMiXS4P+v3KbdNEIAjBFFQJnINAJ4GfcsQC6WCmSLlFcKUANgmAPMSCy47n40x8qFv8aNHQCIJQCIyiNb/b2wvwiye9VJ28csRgKAj/Pzj0e1Pj269QCC59+WboNmlw8OmO0ddOTqRo9489Baoz6dcBL4f/enttH+Q//0VmHIrFmtUJdLOSgBr4s3sAymE0MZI5biup2IqUlG5Jviic89uatT+TgHAl9265yf/PLtq4A2X3Rpv33CaX8CzbvngsYdmCcBn3dyQwZrKtq1Ztetol3U+j4n+TpZdNR9KWBjjMuFA3hAfMw0RAFCkIWsm2D9D9ljOPJo3aYExRI9BjGGMsRjDOGKMsRYZ7M/m7+t3kw5wJAcxo01G82Yx2WSo7skIILHFNXlDvtEhGQVakyLQBgzg4HDEMYS+KDjqx9qSupSHNbULWpk8AuPMazDgkeQ0VgLgcvcBWxlc0U6KlyuAbRI8ZQfw57eFIUhCZgis5AkBGiQCUBEklrPnfKC4eEPgFy6Pbt89eoBG4nmbxO+eWTlki6Mhr0w2gn6fegt0Mmf2DcCBYdjZATRbsktzQuJKALYrEsdxtNZKqTAMVRQppThn55+zvTGRTc3hdrzq4/d+4iWz+ODOV3+8cQGb1+3c+vx37fnJJ2b6wY6zrtpw2a2NCziFxRy5sqUpq0EIYdF3dgg611xoj/GEA5GmChEBLM9hAcfMOHbJEYaV+f4gBQaTykIveogxpr3ia9FuBv/9GGRIJB0CAEbMRzOsePNEwMSA8oaOhfKiJPnFELLIasoZC8YmJKWgz8+5qExBB4cLsDMJAIyhrMjDmgiDaXf3x7e0vyHGVjUAeBwGl2qSjDG2ZSZWVikxVl4VGq3VHV/XfX0g0RhwDPCiLxmsCxp0gV39QWzZWIY4fvEKgDHCFCj/4AKwCqVlOLSHExcYF7AshtBCZbe1njHTndFjU80G5aC4kNJRWnleFEVaqUipM9dvdRvJz9PZ6gtv2fnqjz/y1XfPCH2vft8dMt7cuHoAsPM1H8/2HDo+Ex7cvG7nZe/6duPSTWurmpL7h32czvk8H4ocxQ0MQIwbycEY4KO1t7DIdCEzbh5E0D8Yol9lsV1gjGEMMcbKJBg9xCRX+/z8nf1O2ivulhNESJlJK1OwV8kNDq2UJl+RxlXKpkafhg4Om0Le4aiVVsfyI0+rYFFkJmPA+3u/3DX88zOX/WH9b+7iFeIYwWDGsCSfXdlAaYyItjFGD/Xnfvp1GYAxaIiMQceQMMiIyCD5Wb7tSnbRGyuhi53TjnEP8qHFU4KI71gtrltPYyDQzBVi55qKRdNcK7L9thgXUkrteLGYVirSauuGdY0prCpf3/XvkvHm+z9bVT6RjDdf8xd3NK/f2bhuZbvs3d++/7NvOHj3bVWh7/qd17y/sXypyhzOWjyZNdU2/YWaK3IQgIvKY6QA2Wj+WyYhQ0ZUTmIcYViH/9WPAxp9gwLRQfQQPYZxC8CMpXlhfwayIGMuAYElqNrQkJ7wgJFAtnK4IEGF0dnUOUN5TTkDAeQfOyZ1wDjXoPSxkYRqR/BcGI0PAxPRYOGxfT3/7ogWAFZ/aY7FroQFpaiwVbMaL+CJpfeJKPPLb/u9/UaiISJC6642RA4hKoVOkl//IeCyEuvY2jTf3KIf7ywRWiPfsgMlm7CyYi4S0DPZz2z+Ws7GsuKUxtVaqWUtTYlYrDGFVWkbr7g10b7hoa+8e+DQrik223TlrRe8/uNOfcGjkB08um8XABzbt6uQHQKAfGbw2L6R44wlm9duLS4I1mzZEUs2x5PNa7bUdYnw7Ld8adlZVz70lXeHucFJ4STRfMYN7zr35Y3Q7wyszRU530yrvDFHRY6pPuqgTjCtDAoG4/sVamIVDJgAGEJw+1C4J2BJhhFgRFggzABjugjGMQYuRocLIuYgQyrnz/gGMhOGkwH7FAUG45y1CdYuyBAERHlDWW2yBhQUHh0MDg+6EgANZ9p0F6i0H4dzq4dVCb0AEOmhxzs/QmAQOFExvlnPUiWxyEde+XJMfUVsC+Ghe+/QARpDxoz5DVLlvJe+l63dQaNVw1Eg29GhHj+GIAA0W9UmfufMObFVmmsAeNakuZwcbvs5RkptXbOyMXnNyJZtv+qGjz5y7IHvHH3gu8ce+E4lkLRs2Ln87KvOvPGdiY4N830Ye3bdeWzfrr7Ow8f27errOtTXdaiaTz36q++MfzOWbF67ZaeF5zVbdqzZsrNtxTwe/8Yrb1190S3HHvzO0d9+99gDo45n+dlXrbn45k1X3uokGsR3ZiYZegwCIjbhNDg3oauptyQANIASTYtQEaCsnHAqELdPFWmxVX72Tf5rfRqJmWIvXkRgGtAAKkKfMGuQDBomPKc0lxEAUKgn9GZDQOaxPCEUCXQxoZphC2ftghligvX+50HmI0tKADAeUr+i0iFJwSt77ZVR48muf8yHR+1kbIwhpErQaQAwTOsQsBfUhoeTL3x1z8eeIKOMAUNAVPyt/TzbdrF8/tsn3AN71gr4qh0DSr7ubNbi1koaiWq05bTJ8+VIMCCUtbE6mtOeIxuT1yxszcW3rLn4FoAv1ZPg7tl1555H7rLQW/M9V8JzLNm8bedV286/csdlt8wHGDuJ5k1X3rrpylsbA6mG1irZicBA1RXAVeJu9fCMq6WKCM0E4EiIcDwyvkEXQQNDzH1/IP+oz5MMta3gJIalUs4SGAuGojxBleY4Ixlkafx3mEdy5pE8NnMsJnCVgsoxhnHGmkQ4UMjf0eekPJAIBMZlMEy2ogkABGOCIVFRV8JC7JGBb3ZnfjlyKYwxaGw1TYMBzwTniIBIa+1dfHni994z/G8f1VoTsSL9VdoRTtvv/jW6MTNRujI/fzmCBDAYT8jfP4/mwEHnjsRV7odNGJWmkog255zzZYmG83kJ2J5dd/7mR1++78e31RPsH/3Vdx791Xe++al3r9my85IbXn/J9bfGkg1WuqgtxlEAmBIzm2/cHV8NjJvcyAAbn3OKAAjmuDLdSqx3QIDqVwOf6tEMjQZEYFZFofwDhAiCAUfUNJZOEwBlRs+XDCBnwu8MYN5gits8avBGcqoxxnibHP52J/UaEXeKyT3AsYAmTzyFdl7kDKNSIhERDeaf3NPzr5VXRGvD0ZhS1lEDgGcAwJYBa6PdS5+3til19O/+3ChlYoIMRGGu6TV/GDvzWZXoW3mH2VltuCxpTvbJl5zDNzdNQDfrWL1N1T6NkNOTOgwQ0RE80aC/i9uO7dv1zU+929LTyaypqdmRsr1jGQB0tHcAgJSyqWkqsOzt7QGAMAqHhoaiMBwaGszl8/l8bvJj2PWDL33oRW/44DUvf1fjpixma5LYFxGfuRd61Faz9VeLs2I6xnVlHlbFrEO9Ktjty/UOAPR9rDv/TMCbONNl0K0EYGAIHEFNOINpUKOTsBAg/MGguitTzKb2Ss7nGIJN5kowfTgo3DEkky6IUstEJAyBcoqlHEAgAilYGBYBOFTDT3b/raGgYtqUZMAYw0utghsAXC36lr3QWmut9drrXpQE89SH/4xIK4yazjq/4/+8iyYZbgSAbR7b1mJODsi37ZwCA6vKwKpegqM6r/Kk7iDAqSPITY5oTFiLHH3/3zuvLmQHx/9p1crV7R0dzU3N7e2zke8uf2rVytXlN6MoGhoaPHHieE9vz9DQ4HhO/M1PvfvY3kdf994vNW7NorW0wN7QjA9Pzk5pcmbTrAG51cV1MnwmQNdKMo/aqQkp9+ts0/Xpvu8O9n6xn8WY0cRKDudRAGxAIBmBRhPAONUtQ2JYV9JfUzCFr/WbrGFKIQeUiC6ix8oJ1SbJoy4fhoyIuSMTJ0cdRXfvfm8r37o2cWVb7CyX8yxpYwwiPt3z8Vx4aPSMyrQmzgxjDCeuFW4A8EToOwaGGaKUcu3NrzRh8NTfvtcIvuYtfynjCU2Tjk1EYGe18UwkLl1FsxWxmgVbrrlfuvKypJYKAGsNhcLkTD9WVkM7xeyzf/GS8egbjyeed83zpay960JK2d7eYbG5t7fn7nsmoN33/fi2redfecn1t56a8FUogJ7Ea8Q5LIViAYaYFpjVVBMpypnhtyYeZ+5VqewjBS55mZuObCMw++vcwJ2Zo+89oQEYAdMWd6mS+AIB85i3XKqusFxSPKbiKeqJKuc0/6fD/lMFluSoAQ0wm1CNBjmgQHQRY0z3hdJzgY2IY6JAQXK479D+ru8/oW9ri29fmbiK0dlN/Iyu7O1dmZ+OnzON1oYbYwwy1mDAs8RjR3LJuQZY/4rXRpnhgYfvb7v4Uj0d4PHnrGKXrq5gsvOCi7NE9KrjzFS6CHGObDF1/AAACEMIQ8hmQaviVDgF7k6GxLEYcAHJ5FIHZpvbPP79fD730EMPNDU3W29zU1NzrcA4n8/l83nrlz5x4vhkm+195K4lD8DZbHGwFfLFYaZ1tZ8tjjEOsTg4DsRiiw2YkxwzqlQtU/cwcPplLb2f74tCQF7hiysiCWb3BgO3HjF5w51i9HcM92UAJqPbX9mSWOcM/F0XSyJUIHAxBowYHIsoZzDBEMDkzPC/9ygEpstAjszu1gBGhD6xYQPAmGRjTo8p4fmtjkiSpu7sI52ZBxyWSLpnFqIjE2KHbV1T5xt66gCwjX26opjUrhE2vfHtwYtfSdNBHBGIl20DyWbq+V+oDCyASjmascOIiOJycaBvoQDZLGQzkM3OYBKcbFd2bi2bnR+TKWhqgqUm9TVFWdGJzuMnOo/vHsdfm6eM+05mPb09tTqwRe1EscPMjre57woAhoYqQC9ZHGnJ5IIv++KCidDomXuhR205qzCwURTb7qVf3nLys72ihY+ee0EbCCICQ1yg1hWJV6UXDIECclY6y/54efBQThEwPfabrLCDPqGi45G7zUWAwS/05h4r8BRHXUZxqtgzMgSGxVqjMYfNFeeFGCEhMFESec6Gz0wGIKbUeq8BwDMA3XKVsK2CdUfy2oEQ3PYOU0UqMzY5BGMTi6sM1tYQs6v/Kj65DwCBEmJBb+vQEAwNFonIfFPqoSE4fgwcB5qaoLUNlojqyLF9j85o+yiKZgqls7OjNa2AmnfctSOtEizniVJns9DTAwDQ1ARNzdDUtIBIHGeQMRMFKWtUDTyVj41g+Z8uH7gr6z8T8FRRkcMQRJqiosMZjKWqRdzFchY0aAJFGz+yym0XepNrklwHBvkoElz8lkHtP15IbHMzuwq9/9KDLjNmdCp1uTkdEkPgDMeiePGxYSwfA6xqWiXSC9Iuackz4LIeljXPkVQ5YqbAucq/mWnH3jQjc2b4OTcJDjtMym6oyvcBIMZwwSbEnh7o75tf3J0MjHt6oKcHHAc6lkFr66kaOZ53n8VESWGLzrJZ6O+D/v4FWlwOAQC0tkJrGyST9T+ElGTDBY2cQ+3Sr6rcDylyl4stX1z39GsO557yWZyRQAVgSuwTxxLfYvkvaKCC2fS3q9pf3KQNORtdvs3N/zbH4hPMVkZR5r5s+rr00fccCzKGJ1gpnDyWUoMm6SCVE3xwFAyTIZ5JVLvGpZ69wx9ojV2yjD23SW5tAPDMMLhsrpzBGc1itUN13iGNhd7xSIyIZUQ3xsQcVu8boDV0dUJ//1z9zDVB4uPHoKsTOpZBR0cDhk81y2ahq3OufuaaWH8/9PdDMgkrVtYZhj3OBCo9ZZru/IWBdUSJ82Jn/2DT8c/39dyeye0LdNYAEXJEichLEVoY4akmMEiw9W9WrntnhzYEBrjA5AvSQ/dkuTsaOm2zYQcH78nm33go81hBJJhRZREPrMznorxJ35DGQe0/kmfuBOdBGkRPK1BVkxKBzqrd2czuY9n/SHtnLUtevjx9ecJZ3wDgmSGxHO19nb8wbc2ReNqvo1IvLZeNyGKDdcJD8R0kk5D1Lf/t6YGuzoWH3gkWBH2weg00NTVg61QwreHI4Xn3Ns9iQbBvLzQ1wbr19VztJTgb0jRTL/SorebgrzYReeucrX+9csOfL88/HQw/Wsg8Vsg/E/hHw6BbqWFNUXFqAgDSlDzTO/MjK1a+tNkYIgMIYACab2nu/HRv1K/QwUraCgDAMHs0ogMhjzFSYxU8ipRaAU/yjr9Y2f/pk9FvckwgjKto0hS1dJ8fp5U+9DOodlY0FA0WHhssPLa/9/NNsXOWpS7vSF6ScOarpc0pBcCcMTHJY1DnhKma77CMvsXfhJW64WWndIzj6T4nVrLhgwegtRXWrYeGVWeLVA8rm4WDBxbXIq/ShobgqSdh46a6UeGkYIORotEK+XWoBq7EYAPAPJa+INZ8QQwADIAa0kFnlN8XFg4E/vEo6temYJqfE1/1Oy1eh9B6JPBGmrxVsv1NbYf/onMknwsBAYhAEwAhSiQ9Oo8aoKxnaTJ63Z+vSK53hte5KiJmRkN48XyjxIkNF8TefZ/6IGnCGZ69pqA//1B//qG9J/+1KXZ2R/KS1viFKW8zw1qmfJ5SAMwQOGOL9vDm2nqBCACMFWvBYsIeMmYZsNUiqZ//WWvYt3dmpUQLYjZSuMgweM2WHYvzaq2tb/ekau/gkcNLgKDv2wvr1kNrax2+zROMA1lVp2lli2uIu2N2SJqMLubPIIJo4rKJp8/0Kr8OATSAUoRjiSatemvHwJ3Z/p9kRDNHBANgDGkqIu54EY9yHpYe0st+p2XFm9s1gHdBTAs0quIkcYRJ5475/GmFGxnNYaLSFPTnHx72n8mlj21uuzXmrGgA8FhksiYYQ6wN6aw+BXrGlcNz0MCyGOwiOgzJGGAMLPpCEZuTdSvIOXhgCaDvYsXgee1HNLeVwSID4EJhCaBv2Y4crlvpcJxj1lANcXeuBJqAFNH4Fm2TbW6AeXjmv6974o2He36SMYgkEQUwjhVYWynigYiABGpIt1+f2vyx1cDAAMR3xvl6JzgYojsuFxrB5OH4j5/Ub89zSMzyOsu1rbGL2hLPaY6f6/A0loQqa6WTdYowYAvAvAoHbM3DvbPA4Wr94TTxOqPYt4toRLQU0RhTP/9zf/+iSISZ0QEvUM7qZDgXSzYvwpTjbedfubgO6OCBJTYTHTwA28+uBwALNuxrHN82YIbAO4s8rBoAOQEgGE3OMrHjfzZ1/3D45O3Dgw/n/aNRNKxJEXJkDrIyHiMgEgVkArP6d1q2f2qNSHPbsl0mWOoFTcMf6xZWn2v01zOuEvc9W7z6duMFqKv1DiKwmNjY7J7f4j077Z4hRZwxxoEbM9IrqVZaladKNyQAIhJc1KoXb52OvOrNKqK/RTV2+xpLOyFj3Lrpb3R1Lr1R0nNy8QAwAOy87JZ6dkCqFoB3XrWIjmZoaAFK2uZotjZ9/lP/Uo44kY8YjUrFqqEcxyymslns0GhgHq55WdOalzVFecofCnLPBJmn/KFHC9lngqArijKGIiJNjGNym7v5Dzs2vLkNEYyBcvek5a9pPfHlvjBr2PgJkEVs/9r4PRdlbvoF5uLT4a50YX0cd6blzqTczIUUILRCoEgIAQCMMSpVvdbqup0KzRjK7FDMcwnsQuVUj5ypPU0EAOAI5VIE24siJurif9Z66U2LAIstWeyaV7xzsQHwomtKuFRiHOMPuy659x5HVZY+rhE9nQ3uzm1L0mADuDyO6e1ey3YPXtJEAGHOBMejwtGocCKK+pW3Qi6/LuW1cANQqRdpDCQ2Oqve2rHv/Z2ihcO4VCsEk/jGDfkrf0tuCGrSTHVhVjb7v+ewlUIIRiIwodDGaC2krPAzjkp9bQBwBTQRAdGYFOiFxcvKzZAhY6A1zF1pxRAJxgBAICpDZEkwEQfyBK/T/NKwOduaLTu37bxq6l6EdbYXvuGDjfuyhCzOcVAZrKJ57Sxwt1ZQPQOE1kAAphS+FQnmbHPT21ws7UEDKFMpmVV6n2D9OzoGdxVOfH1ApDiTOAqGRcie2hT/6k3ZP/hPyMSIiOEE8ySaBOo2Q1qNeb+ksWgMs52UxiSfz9HYqTEWLQILzurMXKsxRAgywXBnBoCkQEeikIgzj9dW5JrhmHeMMS6v161cTI7cGdjiE+V4xTs+vqjo76JNDWvYhBYT3JQ6zNdkQqt/J7cpvoA0GA1agzIQGVAGbNB3ouZvwBw897Nr17+jQ3QIEzp62FNZRwVcaVCGIsf3vnKT8+Pn8mbl8naaSJqDYFSdZ/mq0mir/bT0nvf/1RKnvsVOwMbo1kSM80W3pHAEPv3D3T/7sx8eu+/Iyd0nsz05rUg4grui+pFdfNKMEQzTrgSASJuC0ghoiIwxScljsl7+jPnWeZ4Pa2mBWfUzmD9Lt64oZIcOPvWbhZ/Kk83v+McfScdbdGumvt6lNyutXgN1EcNxODuZCzhjrIIEj2nTi1O/QBi9+cSvcQ47nG5LnH7Pkx9kZRE0c3HFC9LrX9tx8rzv9rTdBTGjfa6GeZSBKDTaZ/irs87ccf2Gc27qzw4FdABxFFJw0xLTz+FccM6FEFwIIQS3/xGCM86F4JzbS122ud/EU6cOmEHNioBrJ+pc3Fvv0z3BkN/9WGfnI8dtFH/7y8697M+uiiKafG0x8XLDKa0wBMOi5x3AGBOXdWR4K1bCvr1LbHysWLkID+oV7/j4nl13HlvoFghv+ci3F6MERywGyeQSy7dvaqpnR5A4Z1GpGrg82+AMA7P1T4SunD+xRlFpIuAIx537Dp39qejsTCGU3uC6jt6rV3S+RO1OD+/N5w/IE38ulr8pIc6/Flc/BJAftUrAIthKKS3olmFYcMGFYIwxxqCm/mc4NZKwipIUCKy2SVi18Mggwygy/fv7uCtEifIGmSCxIoUzP8cJAdgQIZEn63grk0no6Cj2h1kStm79om1Z+Ef/fMf/e+fVC4jBr3vvlxZX8nOlbdwETz25eDWwxlP2+pabxyQLIsOIDJFtAe5xZAC2QYKZshVrzROyZjy71vTrGUKff+ieve9lFFuXunxV66Wrzrq4Sazl4ACAAYgyJhrSg3sLx5SbGH5VPv2FyovDMOY4jpBFKzNgxri1mnPfU4cBW2Syl6fOzRKm3QwZZLtymRNDTLDypsITHWctn+mexwBwXApjDCAYIq/+HZBWrwGtF6YjzSzQty76RLOcQ5PNC4jBr3vvly65/tZFDWlbtsK+vUsAgx0HNm6qc6qBx5kJorK7DAF+3fukQLYqvrzFSSW4dBjaZr2+LoU55y1lunryPR9JYUS6O/PwjlVvXZu+IuWuZAAEYKiYYo0IMsWcFBMdJO8TGG2V+cui+D0VDBildBzHkY4jpRRcMG69+0WzyW5lb38jC3osBvPqQWhWofTZITEHGDzUHwz73CleajLGa46l17WUdWyqaFgMAoghhcbEK5iuy1mgjDHGc536d7KEtevAi+GJ44t5+qa166CpCYgW8+j1Ek3v/sQv/+39L61nUnQs2fy6P//SjstupsV9ccDz4KzteOjgovZFJ5O0YSNwXueR5nFGxhhjkDHGWGTU+5/4xJ7MwWVuW4fbssLrWBNfvja+cnNy7XPbzne4WNhbPUvSWyWoE9/a8VIBQACaQI/RhS41jGWcu66jC37cvyHnHFbiSAUAS+k4rusKIUXJ52xzoMusFxt1wOO5b1EGi7FFlMVXXlgB9O3p1aHhJQ+oVia9Op1oj5uq1/QS6N4B1Sb0uclR98sTrBBEmuqYAj3GOjoomcQTxxfj5NjURKtWL1rP83g4fNcnfvnD2z70w9s+VIev27bzqtf++ReXTNoz57R5C/T0YHfXoqPCnNPyFdDRsTCsW3Awxi6hOEBPlBmKMhz5QDTcGw48MbxXE4EJ1yXX/eSKf49xqeZh5ps/V/ZMyToRRNN9hDPmSBmEERFLFn5nKPlJwsBiqg0ACyGllEKIecXdsp0iZUgAwLFObtgZUGEEDdC563hUiFSgjDZAQMq0bG4XAqtnHpKhT/SKh7Kd0aj71ey52mitdazOLQhHQUeMNm+hzVsWUXlSMkmbt9CGjUsFfcv2wls/+L7PPzyvEdlYsvnlf/Dxd33il0uv6Kijg87aDitWLJaKMs5hxQo6a/tCoW8RgzkaY8gYhnTS7x+OsgK5QO4yJ85jKREX3FsXX5mWCU3VzVq15jCLysGCiK7j2LCug6tT4c3l90vRXs45L/ufy25nnB98Wfou6JIKBxudAk2LY3AYTVuuPyPenhg81J85MewP+mEubN3SjjM5GN/Q5c18ncdWxkchiicFQ4i0dsRCT0nJJCW3QDaLA/0wNLQwNIVzaG2l9o4lh7uVtmbLznd94pd7d931w9s+VFuPdCzZfM3L33nNy9+5SHsOVk832ztgaAh7exZMEyYWo/YOaGqabClQluyvgyUkH4gMEXGEE4XugvZjfFQ5mSazJrbCZVDQtCRu8nwLe7muy3nB3qAkXRmZvQX2CKKF21Hh3jqc7KmShAXzrkM5u6FEAGdef8YZ158RKcr35AYP9ffsPrnygjXKzGA32lCMwUfPTjWP6zbYEvOGSj6ohbdEghIJWLkKc1kYGsbhuiCx41AiCU1pSjeVB8RSH9Jbdlzxzo//Yu+uu37zky//5sdfnjOo73jOC17/nOtfb6GXlvr1YQxaWqilBcIQh4dweLhOEZBkktJpSjeNrPBoijLCOl1kgUhG29YsR/KdepzKBAGtS6ycWvhnAcUs64/uruNIKUu1M9gOrzkBexFGJTljvfypSxiAx+iVTLZgWXAqHCkiAGSYXJlMr0yuv2SdMmCmXI2O74MUGbqiY4L6wmXpRBAEi46mpJsg3USwFgoFzGWh4KNfqCVficXIi0EyQYnkkua7U9vWnVdu3Xnly9/+/x791Xf3PnrXo7/67owaKG3deeWO5968dedVi7b9cA3WXu0d1N4BWheHWS4LhULNln2cQyxGiSTEPEokF6GYGgA4nBlrAMcKnePxkQFbF19Fk6FptSlOMN+QVDdodx1pmytY7GCspYO9toCP1RN3TzUGDAC87gx4Rh2VyBBp0LM9u4QjJqT4nLE17S2L997EYhSLldc3mMuC1lDwQWv0S3g8BX0pxZUpkQQASCaI8XoKHSyKS5hsfs71r3/O9a9/7Z9BX9ehY/sePb7/0WP7duWzgwDQ33W4r+vQ1p1Xlsjuzrbl69ds2Vl+57SwkTXfcgAojq5CAbSBMMQoBAAIw0nl2xzHLuNIOuA4wFlxhbcoEXeMpTxHD+WAIFDmSK6L4ZhIHLncWRNbXmf384JocVRpUkghZXlqRcRm9twUX4cLQe1PnTIkVncZrDp8i90szjHpTHqnBOfzpFNa+7O2OJpugkWWmrFUrG3FhrYVG3ZcdnPjUkyDx4kkJJL1fKIrrZ4xYACQCEQmp6Iuv4ePBmBDJiXiK7z2SgA+fRzOE56FlEIIUUl2EdEVWxnj9SfBp0gZEgDxKlqCzAsOz3Nr4RiD5ulUruwD34C0hjVsscxL9ZzEGTKgLr//UO5YqH1NhiPjyDkyRbrNaW51mjTVA01npsUx2wOa44kIzjnnlV2kEJFzzpDVJ/HqVGPARU/CPLig6/AUTfEVCNAksEqVK8aYWTzZWA1r2OlsiPXMBHQ5K2gT594fb3vjocLxY/muLr+3LxwcjrJhlGt20inpVZ/1OUt4s9OUWUTzz2QnUtaXrIRbW3rUYMCzRF8GyBBPmeeXI8QYxvnMnoQGBjesYYsDf+s6F3HEyOi0k3jr5ls454GBggr7o6HuoO9g9lizTBHNr5+OOLLuwxRvhmTT/GFwrRg8Q2YpL2e8nFrGGKsUfG4A8MwZ8EIDsEQgAI6oqKi5amayIhQIDEEiOghitqfCGJu/1pUNa1jDFqHFBO8LlNI6E3FukCHzuLNGdmxIdFzadqYm8Oc7BYsBHnoEu/ebW/4YTD1AdC5fUfQ1M8ZKiGvho1LzuQHAM4BeAECEeWXA1YzfiIAAIiKGwAA4ggPIGTAAhmBo4hRohNnD7WSr72JImMgY05ieGtawhZ2d5tsYIlW4vghIE2gNEY5MMvMOdVGB3/EFc83vQbK59iS4prhtGa4F3EpH9Hx0G6xi6bLEx3exnhqqvnDz/1AYgoggMJA3lNE0pGlAUc5QZMgQIIDEkR8xP7fbLuhsRy08hZzzDWtYw8aYK7gxBoiotOBegMTvzqex5wB75PbaQsp8ZM4yZuECiwBc+sFy94U6Tpizv1r3HlL9+UXj58R5u6k1GkYRgW8gq2lIUX9EQ4ryBtT8HwqWOk3zCn9LwxrWsFMHgKUoSXHMnnbPfipiCGHE9v8aXI898G3Q86/ZMbfjZ6V8XSzB8EjPwdHdFxY1AJ/M0mv/O7e/f05OTk0wGNCRYfNIt/rlofCHe4M9fWoWPJhN1wl4YVZkU+JxXtOgon5FGU31QWK74hMjvaYZIkIDkhvWsHl43Or5dTb7Utcl5DR2ruLAnrkHO5+AZBMefAiPPQ18kd+airtTgcH1R1+YdQyYiJ63hf/Fj8xNX8696dnuK84Ra9LTY7khsJKkfQU6mqWnB8yTfbR/0PTloqGCzvk6G6jVSfaz17R5VXpmi20eCXBRcPGKMEy1d1ETaALfEAIlGMY4zvexVc4R5TFHlQ79U0AuuGENW/DZoI7fFRPc0GwZ8FwirIigSdz9rwAGOMPCMD76E1p/1lJcHS2Id3DGAFy+wUkHXnme/PcHw3+6x//cw+w56/mz14iz2tnyBKZcZAiKIKcgr2A4IkOQ4LAsBhuTGOfoKxoo0JAPeQWhAUQmuZECpWKHhvTte/2XnOnN6IqMEWBbKOitBODK1+WBTuMeTlMGPoDAGI6QliIu57qGtCviMUc1g+HZAOCGNWzOk0L9IAXAEM2iCnGu6U0C+H1f4/vuMm4cDIAU+NQv4cY/BGRzOf15TZZm46QvFzAwJ2Y4oqjy96t28q88DAHBsE8/3ad/dsiAAC7RcRAFao5c4LoEbk7hphRsTCJHbHEgnYBWF5tdaHap2YFeiUGEkjPBSXLDGX5hV/7F21zO0HarmPaQZl3iNpfno/JLx1yWMqxChSYOVdbiVbxJJdppnx9jzJDSSVeuaErymcuyUGknteXKDWtYw2pAsuYR6005EbqaaXN2y4mxe5WInXvkTz9MUiIgEYDj4okn8cQeWncmqHoA6qz3vEhmudkw4LJtbIHrt/Lv7tFgEBiBATCoNRQiAAMoAAgGIxqKYCjE4QiGIxgMocOFZhdaXGhxscWFJgcyIUqFkqMUTCrzaLe650hw5XrXltNUM5gWUIVjDPrSaC9uJQ0lMwpux74wxhijtNJKDw1Fw/19W9avkzNp9KuUamDn6Wbq4cdmDxLJBN+2uXENTwGTnEXGAFH9aLdEzPS733o7FnpJJkABIABnmB3CZ+6hdWc21kbzAsAlLCna710IP9wDyhAYJAZYlJ8AYAQEZCAT4lAIQxEMRTAckn29IoYtHhRJsAt9Pgs4SW4kR8lZyOiLuwqXr5VTZO2O6UW4GDTDK5cmpvQkjECsGaG5xXQJImOMNsaQ0RUWhRGp6Jc9+R/95sR3X/asZk9W89VRFDWmoVMAR9Ujj00GrtHDj9bnYPjWzSyVHJkjLjhv5PX5541/s2Hj5/c692NwOc9pXZ5/5h1jJEJ+yP3Wm1jnw+SmURMxQEIiAMHwmbvh2jfBoo1kVSS+LGEGbIzRWm9p0ddtgtsPYlH2ydhwBIBBMoAMCgqGQhiOaDiEoQgtCW5zocWBJgeaHGxyKelALkTJmcVgwfDuo9HjXeG5KxxbJb3Ii2fG0l8iKIlgmFIw1mgzAsDGKK0rcVeVLYpUFOXD6MRAYVsQfPNXD7zp2ksb6HvKmN57wHR2m70HTFe36Sz+VPnZuiU60L6DlaIx+pHHy68D+M9Rh7RyefFnxXK2dRNbuZxv3dQA4PKLuk3xM9W/mwtlIYlsqNP7zv/lB++hWBoUAbNpLwAEIF127DE90E0ty1Ev0ntEZBcLsOBLhFlmQVv0VUoZo9+w0/z8kBsSAOHIbSjhsTFgXdBDEQyXSPBwBK0OtnjU7EKLi80ODAoMFArOpDBSYBTAV57w/2GZoOnKoktlSItjXTUmEmzMiLNAG0NktDbGaKOV1kZrpVSklC4ibxRFkYqiMIpUFF3iKS2iqPvwE0+1nLN9qqxCrTU0bDGvz7K56Pafq3vuq2S3I8OGLeEyMOo+qbtP6l0jCI3JpDj/XH7+efLGazGZOM2RuJ4AXJl3OX+nRALEsQe8H72TdT9NsTRo6+xERCAkZEiCQ6Ybjz5Grc+f8VnUxZO5qJ43MZdbTmSUUhtS6oYN+N2DLhggA4gEBoCV8NhAXsFQBMOR9T/jUASDIbS40Opii40He9Trox+hEqg0i4QJFf5wf/TW89WmNlad1DOOuZEL9aQVHVCMYQmDi1JnBEbrEdfHCDBrC79hGNrfZSS2lPieBx7aumWz6ziTrYQaepOLmvI+8njhfR+GbA4WQa5+PSyX17+6X//q/vBL/xX/5N+x048Q0zgqXD8SPK+NECWC1t5vP+Pe///Iz0EsBQqAAdpoW/GHkAFxBOEs5ntUN92I2gNw5agiIus/fe326KeHZcEwMACIxTCwxWMGkYahkIZLeVjDIQyFkIuo2cVlcRqOYDjAfh8GfaaICooKgdAFFuSpP6M3tpgqSfDCrnOLuFt+xxgCKBZ3EyEiAgJima0SACey8FxWwyg79su+aWNMvlB4+LHHL7nowgm/XSnVSLta1AC863HM5U9HtZNcXv3qN/L0A2BWyRfr9aWmCL6zKTusivhKEL3PxO59nzj4c2IJcGKgCS3LQAAk6wAkBqAUNK+kNefCIp6YiIhwaWZBw2gBB0vCOrzoLecMfuaJlrCcikWlkLABMJCNcNDmYUWQ0+RryGuMcchEsHsIHuijJ4apKwt+AU2BU4Cg8b2Xq3OWgzEG2WLnDWUGXG6EUO5KBESsBMBWcEXbhhuMKQvPjJXRt7ig0VqXuLLd50OTAHCh4DPW0LFa7Ian8z06/dLyR57cOp5+U8ztK4Tz4YImgQDg7vqP2AMfZlG38dKgETUQAyCybs4REgwAUc6cdwM0teKipwZLLwmrnOBXVNHEYpYyGXPjuuENidx3jjQ9MpgYMhIMAEMgmxiPBY1DIQwF1MMNKTwwgIMBdObpUI5OBlAwEBEoRBCIDiDh28/J/87ZoDXjnLPSqJqSB9MieeosG2alfkR2cVpsF0FU6oLFldZcc844E4rb7tDlbpSl3O/yKQVh9OTTe84+c9uYL9178OAZm0/3nJfFPx2ftvrbp7nwOKsvcxiVBFqjG0gOsKGTsV980Nnz3xB3yEsV01xseBEBEQhtwJGAEFVEzSvMFW+Ghl9ufhlwqXWiBQ9LUrekCn90VnYgYAdzzonAG1AyYkxyw0HfN5x2cjwbsL2DfC8TxERAGBBogAQHjhAY8AkiycCYP9zQ+/KNkdYxY3QprkGL/2EeU34wEhi2jwQyi8nMGCJinGutuRBcKcWFkFJIKaUUUgohrVAzYyxAxCgCgH2HD08EwIe2NQB40Q8Lxthpe+50Op40Vr42daFZRGAbIlXSgLktH5AEiKfvjN3+Xj70NCVTSECaUFi4LbPeEglGICRQBf3Cj9Cy9bB0ImMLy4NnEwO2d5eXzIKwBQxjdFpE56aCc5LDUKyChS8fa41FeU5Sg0QCIVEiOlw4BnwCMKARDANtQHLzjnVHrm4rGBOjUgrxFBdocXaer/QeW0+UlcHCimolRiSMISJVKkOS0pGOIx1HCCmE4IxbKuwDENHxzq4x33Lk+IkgDBuakYt9Oj6NiWA9fbCLlgQbperxTUS1hBOJoLT7w3927vw48pASTVazHhUCoyLWIgKOSsLC/KC65M3q0ltx8ZdlLJphOUsGbGOcnHPOhZTSlDKGqFKCkSgy8LkDqQO+FIIIjUCtkaFGRCbQSMa0AY2gEQxAmodvaj14XsIHcE4xRSc7BbMKNzUrdzLmXBgjpYyUEkIILjgf1TrQbqai6NiJzjWrVpb3efREZwPelsCt37zxtI0B446zT0/QnfD1/AJKZSnw3CZPdJB6O8V//KncfTukEiDjpAkZgEZiBBpRklV6LkIvEiJQMKR3vCJ64UfQLI1V11KVoqwEFdvbjowxTrEYBhGVYoxp6z3+r0N89zATwqDRaBANQ6ONQWOYMcg5kwgaQTNYxXKvSe1b7SlAack0jE71mvpSjrmYCIs6BlHprEbGLNEvevOFYGwEfU1J84SIjnV1jwbgEw14WwIglEycFtVHEzPg027lMWa+qmP0oRbRX0SUoB67z3z+j1n/Pt3UJAyQJlQADEswDMQBbdAXEK0qPmn13HdE1324tBZAMIsag01tHQb1Z8B2bFkSTFLaOK3FS865Ukpr/etOdUcnCK4NMoNoEA0ybZO3UNssLsm4YbCN978keTApiDNR7lbLOUdkVWKwMbQU5qOxy4JRSW2MFSPrOMJ9y0KVxpjOkycrP9vd29vR2tpAuMVu520/fXORztt+2gHwOMRljNWnUp/mCCqITEL2R18PvvB+Fwo8lebKMEYMNRlNOmKawCAhQ8ZBMiQwEUAEVFB67bXRmpvxyd+C9CDVCi3LwHOKYKxncDD1eU7GX54FzDGaJQMuYzBwXr7lNr83iiKu1HAh+urTBaOZQTSG6RL9xRL9tTyYI17qdl8ROyptKFkIWU5HEoJzrojt7jG/ORE9cCLqSLK/vyZ9Svrz7CqDMQZClMehBWAbIdZKDQ5nytsPZTJhGEGjc9FSMLZ5Axw8fNqd9sb15vQbnOO7wjDG6qBVV05WLUvQT116juP/z0zPVz6f+cJfe3HBEnEWGIYoJDI3wVraWNsqiCcBAcKAsgO66zgNDlCIpACUhEMPiJ+/ApQGEOQkoXk5bTwXLrwWLroG4jHQ0EhVqTEAl2GDcT4CIVgEURVF396T68pGQogy37U8WFfQX4dFz08cOS/WzxgTFnullI7jOA5Kd2/OffAQv69TPd2r8oHOh0YbWhfj77h0Qn27RX+Dp3OLl7k+cZBW7NNo10pUhmHkhPl8PghDK4k1nMmezvUtS48EHzpyup00nX70FybyOVtOstgnJ4lq92PRf/1NvEnEW3iiSXktxulok6vP4WsuZGsvxWXn01CvObZbH99N0W6AAkXDoDUAAhKYEDgDYKAJCxkaHsC9j8OPv04btsPvvguuugn0omrMQESLJToypxhwccxxDqXMLK05ZxwQf7ovY4w2humK6K99Yf9NC31Lumu9V+CcCy64EI7jSMdhXupglHjopPNQLw76uhCSK5k2pAz5IX3swezFa+Wz18gx5E+fKissxpg9FZvapiwCh2EYhVEU9Q0Mrlq+DACOdXaW9bMattih6HlX8O//9HQ7a/W8KxoADKVcmXknwQRzKQImDaJj1aYdy4TuZmnCJGFcYzrCJIAwoHIQZZELEBwdB70YxBPguGDyxe47DEu50AgCADkIFzTCoafhr98M+94Bv/c+MIuFJVGxkHkCLFt6DHgEg3HEjg76+3pzBi39LUZ/TZH5MkRcLaJXL+ttdTTngjMupHRjieVtzW48dSjvZCKSgpbFKNBMG9KatCZtSBsKFf3Jz4e/+8qWltioYrvZ3dq55GohIM3PgGIMAVgxv1w50nEc13V8J5Aym8/bbcIwsqlqDc/OEgDgjetheQf29J5Gp9zRbjauP91uNOcTd+8WQqh5BuBQ6zlFozRRe0d0xtX8wdtMLIkBIGeskIN8PxYGyO/HcBicVvSS6CXBS6KXRDdGQb4oxGEn08ofO0V6MWIa/uuf8fxL4cKr5qM4eBbISTAy7y+4E1HM9fwr0ohMKXWox3d97QrMa6QR1SxERGZQL/eiN6waTErgnCOXWbeZJ9u85lQ8xVpdDJDyCvIR5SPMKYx0kf6WfptDQ/oDv8h86oWpysNYzNGmmcK8dS1bkZOSS96RjiOlzBd8u03f4CDnHBdtx82GjTZzzeXiG985fc5X3/SC03Bk8klynhljfJ4jwdl8AUa3YpsFgOnzX2Qe+E+mADSgRooiDAYpHMJgiIJB9DowlgYvgV4C3SR6ScoOgDGACEjFnHe0MxhQGYkFB5/B//4bXHAF2Oql+YHVGTkLDBm+ONyHYu67qNSdsHZGO9+4aseh/m4wfcxERpNBMkiE1OqZ163LCyH26FSnbsrIpqSMrdNAAcYExAWsiGEuolyEeUU5hXnFLPfVhrQBraEQ6e8dDJ67S77yPKfSq3AqPcnWn18UORGiLJI1mM0WF7xKMcY54w1sWxqA9KLr5O0/g1z+tDjbRFxffdnpdosRUYhJp1Mp5eJtG2rnbwV667N1xzaW3QueJA2oicJhDAYpGEJ/AFIheCl0kxZ9wUuBcED7ZdY7Cnetlq4V6/Bi9Mh9uOdROON8UAt/ukQESvFoAFpXnAoAPP70EpL+4CLzJ3es13y1QV9hwJlmHFHwmMs/2ycPq/gwyhVxXJ+AdUgxgTFBcQ4JCWsTuDKBuQjyCnIKshEEIxgMlgoHynz4N7nzV7JNLSMMuD61v/P3LWP2bAuTbIBciGJ2eJnoDw5nhBAn+wca2LYkjBJx9aLr5De+ezqcbPSi6ygRP91u8RToa0mwEELNmypWsRB0LlTEECRj6pzr5J1PQNIBDaQBwzwFQxgOUTCEURbdNHopKHuhnRgF/gjuwij/8wgqcwaZLNz5bTjj/MWw2lBR1LT/gfQjP8tf/nJz3pUL64WucZ04FYUj9JVrg2vXZEEzgmTE2wO5oiBX5MWyA1HbrkxqMORaU69PJ33oDaDHp14fenw4WaD+gJocXJnA5XFcHsMVcWyLMVcUfzzJPIcJDpmQ/uLn+UjTHL0uS4IHl/BX+mEIAGEUCSm5EJzzkUacjZ/F/RPd+HzqaD/1lxod7eErbj7dbu60AGxJMDI2fwcwR0egbSqoz7/JiCRFBjSAZhSFEA5SMAThEASDIATEkjYSjF4SvATYqtBiR8KJI8GAAI5H9/0CclngOG/AWvVSqedY0wM/ZJGfvOM/Yz/+PGQHF9CBKuYBfYt95v9gR/7xXtEdSESEojPCaqcgIaKGAKnHh7iAGMc4p5iAuMC4gLigZTHMhpSLIKcgpyCvmCYCAk1UiIAUpxyINBCZsvratKVv885ha/olJXEOZkGYcS6EyOcCABgYGhZC2FNvxICXDDLFY8Hb3+j91T+c2qcZvP2Np+GYdD1vWiKFiK7j+L4/L9M91YJjKDAbztFrz2cn7qOYhxpAGwqGLQOmYBBJo5dGL4luEtwkeikSEnRYwcPBBoMRkUp9ggEBHAeOHoLHfoOXXDtPsFrV1ggQheqnX4UoAOkAgHzmt7zrQHTNa/TmHQtCheeFAVtrkuqPzuvhRKAJjP1t2wNT8UdDJoSTBerxqceHXh96fDrpU3cBkIElwSviuDqBaxPoSTZMrDsUg5FUIByP/fEVAKaY+6cNzWse1oKQ5nITYc64KJn9gxBCSDFZ1mXDFqfp7WdEr7j5VHY+v+Jmvf2M09D5XOWTyBjzqoDqWVghDGFMTu9s8oMJJNM7bwI/BAWkABRBmAF/AIIB8AcgyjA3gW4cHY8JyRhHoyHIoPKBtHU4g1EQ+VDIgFKlpCwABNCa7r59lkdWowuGAOGd/6sP7UY5kj/Ehnrdb3/CueNrkBta2gwYxrXi2tFWeP2Wk1/ctxwMEBIaAA2ACBpsg1yjoT/EhA9xQUUqLCDOKSFgeQw3pYEITuTpQAGeyOOA4sQNcwjB/P4Z0bZWMoaXMd8YWvC2bzVn16XGj0WFEyFl78Bg3+AgF4KIEDQ0bElZ+IoXY0+vuPPeU+/U1FXPDV/x4tPthjLGHMeZ0fae59WcBxfCELkz9/2gAbXjBnP3Z3lwDASQNBjkKBiAKGdUHqMcxJt1skN3BNpNmZVnmp03kfQo1QHJNnDiQIB+DrIDMNDD7v067H2UQg8NEAC4Ljx0F/X1Ymv7vM5bOOlcCmrf4+rXP0DXmwAIH/qpXr1Vb7sI6lubVPskrDJm2H9eumHgYMa542QLIJIGRABNgAAaCBERQkU9AcQlxjnEBMUlJAS2eJAQsH+Ybttr7uo2vSEYAFdAhIzQXNASvm5bXmunTLsNkSEDcEoxwnJWub2elgHbN4QQxhgydLJ/oKO1pQFsS8iC1/8fdugIO3T0VDops2Gt/7Y3nm63knPuue5M52vGWCwW84OghnnR5b4X4w9mZgeniFpXFd75fRw+gbqAzIDrgZMEpxmcBHCPUEL7ZujYQgyQjcR5x35p3wH+5D/jJjK+pgHUAwyUhJPH4aG74bqX1hZZq/ywyWXC278ExgCfAPWirReFm3YwonK/3aUHwJVowSq6Bb/1rO7jeXdPLm5x1zJgQAJtXRNoHdFxDnGHJQPgQPsGzBP99Fg/DUeADFIcAgKrOpEQ5k+29JIWWvMR+UYyZOalynu+w1lTf8UIBnMuhOBCIKIfRpwLxkqn3AgDLymjeKzwl+/x/ukz/KlnThHue/H5wVvfcLqNQ1ugP+upMuZ5SqkgCOqWAVQlpKAhallBbSvsYWEp0cuGdMEKbxChhon7/krEzied/3oNDJwAGUdOGCNsId3F6BjQA3fgdS+tTybOqPM1Jvzpf5qTx9CbID9fJ1tyl78CDQGacie6pQnAJfi1dE0JIbROGPOec4+97+GNPZFDSGhx1yAgkAFEIg19AYsLcEw4OKDyIeQVR85jDLkDgYGQAAwAADJ49/Ljy2VoDButu4Z6upYjM7vn1W89f5pYpfVy6aoyzvlgNhdEkRBCa81YwwW9NDE4ES988D3ev3xJ3LXkfdHqyuf6b3vD6UZ8Xdede6tBGzyOoiiKojnCcNYP4kmnLIs01zPUBHosu51+r4gggB35rfz2mzFznNwEaFsZBeiAWGM0F2bPo5DJQTJRRIG6UGFE0AeeUg/+HB1vwg0GL3mpljGhNSISTupLmJfpvcaLjlKTYFGWjxCCC7Eybt5/3pHzm4cd6yrW9h4TaEqhOt8bvkYeE/29fd2Dx/sK2ULEQTmoHQQXwWXgILgMXISXN3VeGB+eeMwYwxHsz1w6JtVn8YMz2QwRGRbrkbBUmMQ5Z4wNZ3MNPFui5r/tDf7b3rh0S2YpEfff9sbTCn2llLFYLBaL1arRLyI6jpNIJDzPm7aQaSrEnEnHQ5yHLYEjCRCPf9P9399luU7wEmgLkxgAK3Jntpwxp5N6O+ud1ErA12xxXvhGkC6E/lj03frs4eWblYps19c6lyTVjAGPaRIshHQcY2uSLFXdlA4/eN7h4zl53Hf7I2kQ01K1OdEy6ad59IUjLRCSEZIjGIM2OCIESCaK6wQD58QGbm7qYswpxphtlU7JZa+1jgz8/GCwf0C/+YK4w+ZDebSe1Ld0VcuOfc4Z54yxfBDaJCzGeaRUoyPh0rXoikv0Wdu8f/3SknNH6+1n+G99g+loO+U9z+V4ms3AmK+JWAghBBHZZuoWDGY6VyxQhzQkCZjr9379YfHYfxAJcDzQBAyACAgRgRiAATTE2h2TjFfOmlgfNHY959Ib+Yazwttv00f3oHTt24VU+4kzr3CUUpzb+2w9q0syBgylDCzgvFgQ7BSrgsvu4tWJaGUsGKOe8cuT7u5hwYUmjePGZRGD20Xhd5uO2K7BrIIC2i+NCG97Ivzewf67D4cQ0kNd0edf2CQQFNWn7rfGiF2p8Tzi12dMCBEqbQA458bUO1zRsPkw09GW/8s/kXf92v3Kf+NS0KqkRDx43e9EV156qsKtdeOVf7M6Flcgom3KCgCmZEqpqZnZUC4/u8ZoWDXJnXT3DIGDOPRL996/YCefIpkGg6AJGAJBqUUSAAEwAhPA6u3QuhJM/UctEABbtdF7/V/0fPdLscfvYtIxjB/cfq0Cxkvct/7KCjWOAdu1Q9lNSsYYx4yBW7tZ+c2hCH/S6SiYNCYgBKQ4/E76QEpQqWmwtG5uxnhk6M4u9l/PiMd7KYy0K1FzvO2hAgCUMbjKsTh/F37WOx/R2WbMLj4G83khBCBaAO4fzjQw7FSgwldeqi7e6dz+C/mjny9aGKZEPLrh2vDG51F80bnNy0hZduSWa3PHJBtPWLO7CNeyds0NADbVq6xxRERaa/tfO4sqpUbob1H2qMYKFhNvKRGCgvOrf3Sf/BdARbE0aCwGfamoT4lIhFjqwqDpwpcBn3hSrsfVJ0Dp7F97gRKt2/fceXL12dn0cne2PRwXKQOGUlNMUSlSRWT/qhTTWkPFn359AoYDw7mGUVF/rFx1XZc6utIJuSj2JLAozLl4elh+4wDu7idfm46ELoQmH2o/1ODibQ/lYxL/5QVpPiUGLyJ+PMnBlD3t1gtNEQohCMBwblfoDQf0qWEUj/svvym48XnigV3u/3yP9fQtKpoevPzF6uKdixB6i1ePyGgNAOMb/wnbsLyEZ1PA8GI2y8jHH7YxRjpOKp3OhUo6DjGOjDOOEc0nz7T5VsefcH72Z6LrV5RMoivRVDRjYISEVCGViX6ONl5MF9w87WHNS4i6kgoLZyi94uELXoZuXJQcjKNWMEu9DrgIG5yLisVFUdk4Gol1E1Gkza87A6XVmMuJUMp5B7g63XNWLMNYUQ/ZZv9H6D484D7Yg3kNMWnshaWSGFoh1OSyf/1NniN86rp09Tx4wbny1Mth64UmIkGkGEPGgjBqlCGdUjAci0VXXBJdcQk/fNT50S/EA7swv2CEmOJxdfHO8Ibn6fVry0C35C7pmBYIwSjvmrBgXPY5L9qzqPRC69Hdf/uHM7kwiggloeOgwwAA7O9ghiBcFfIIBARx75edOz7M9AAlm9EQaUJeCvraubiIxIBEpBS4MX3TX4Mbm/fcnOkWakprxhg5CVuswyus/o4QMU/7LS42Kwa0zWVQQtgUAytedWwgPDysKvvKW/Qu//f8VObydD+vQN9YLJZOpY8WpCNobdIiPDuZp0phcgLyQwMufvq+PAB88ro0R9BUVxCt1VdUCptwxjXn3Bib6cY5z+ZPjw53p5/p9WsLb7kV3gLiqT3iwUf4U3v44aN1+2q9fVt05aUjuHuKmsXmSoSunJEXyiltKYoxxjrPp+2hdLSru68QptNNCeQeE5oTN8U0otqfgETMDMj//YDY9XWIuxRLoiJigBqBETIgIiAEAqASCQaNxlc3fow2PQvVvHTNqX5LbYwxJITgfARThJScCzaGCi9dAC4Hg1kJgEtiEtzCL5WG17FcEEVqTPp9kfkCrHCjm9r6OOPFy+R4Ot4ab0q2xZgQZDmvITBAhljvmPYgBH5kwMVP/ybnCvzbK1OMlRBxVthY5Ydmse9qPmJhWHCuS+qbdr3GGMv7QdxzG4h1yoLE9m1q+zYAwHyeHTomdj/DDh3lh4/W0EdtOtr0+rVmw1p11hlmw5pF62euDySXAY8LIYu5JvOeh2WTrSq/vXobzvuMiamLgGuAJ4gogPY8xL76Ht79KKVTCEAawKKvhWFR0YWQARCAVqB8/fwPmEtvxdnJFmAtN9NaE0Exl8hxXNeVjlMsl+UcTxkGXD4Nxnm5kMYYYdFXG0uDdTYkrdVIuWslh0a6edlwTDJ7rTqxeZBaW7TUeWRIHR6uS5U6OxT7O7C+kdZcxWxjXxlC8bHvB9et9q47Q0Y0L+g47yy6dAGJiDNOnLgxZad03vdjDQA+DYzicVMC4yJCHD6KuYLY/QwAQC7PDx8b9WyXSpvU6AYJev0aSMQBQJ11BiVipzzNnTsYSyEc1xXz46AOoyiKorm0ClZaIxOVvG0KFJklvHBEBsHPvkb/9UHXZEy6iWkiDagJGJKmIgxzQg4EVJQ7JIWxuLr+H/TOVwMAcABC0IAzn1NrhcJKaeRcCiGktOjrOI5daLGSC3ppx4AnwOBSDpExxtbPcGO0UhFGSU9qFQDpUrp6capBMs9qN1vTJkL3saDlmUJbxGOr4rjahvkRGVKbh1QCYCp6oFn/SE8sUAZ9H8nHphRs6pj5wzPPYljT7R7L/5TR1xJfIjLcMM6tb3o4l2trSjemy9PQ9Lo1AKDO2jo3YG/kEExjVqzKajjPRS5jPMD7vj93RehMvtDU7I2+pdNXslbTu6/4QiCQGfr3v4u+9xkvIXk8riIjwaCJSGvQgISAHDiSQmRAIUKIFAD5pNdfaTIp+NUPIN4ErcuhfTUkE2Ah2CxA/7pIaSFEMZPIdS36SikXJAA8vwAMFQlZxdpmCyOl2AYBPWt9e6pJZvI9YALUCoiABAEgF02J2Jf7Vtyfb+oHZ2UM1yQIERgiA0IAhohIbR4aC72lDodEzMpg9QU4rNAwImZuPl9uaWURzeDmzRfyVvsBZJhx8Hu+eZVdkVGpysIQcSJDppw1oLVpTJENa9h8mzEml8sJIWqihOX7fhAEcz+qvO8XIbfUFc7+Z1oqXIapaTCHgSkUOj/2Af/H/xFvTTKFLDRCChFL8PZl2NSKrgNA5Of0UA+d6AJfmQhBASgkLWH/L/BHPwCDRJxkDJpW0KZz2aU34iXPB9fFumvpKq0rua+Uzhjn8ynigh7Pgy0MA4BBtKMZAZcn6I+ek/6r+1crDDSGjBEKTkKCdD/XIxknYEgcOoudk0qlZUgMgQEyoI4YmlLHYYYgER7sY/sVZoHQIQPGTbN3XOIs+NM7oxAyAaT4nyOcKJhX28+N9AbmnGjEBY2MDTRKgRvWsLrN4Eplstl4LGblMmaJmoVCFIY1OZ5cIRjjzKgUyadqYHjqGUlgeMf35f1fSG9v8Zq01yKdlductTv42mfx9ZcDS5gTz+gTz5hjuzG/2+ghiDLFQiOb/ywYsIQVlwaloOswHt5rfvFt2LqT/f578aIrbGvC+QM9HMuAlSwVslrPMxei/rlX9QPg8VSYMUbGWEQBgGvX5o8MqC/uaSUe05wBK9JE1IYIgAMiFELsBLL0l1kejGRLthjSsjgSQJxDTsGPO+nxHASI3AVgoCL2knPZRSt4Ncl3i6QmmABd/FGM/UvBvHbUIoYxIGJEnHOjdTkJS6mo4UNsWMPq+IhSLp+Px2Kz64aUz+fDKKrVsQxms6WOcEUGbIxBxgCAzbCzHk58rhDfuLH9ggRLRpAglgRoY5h2UAKoLHgpEBKFBNcDL4FenPyM1eIAJEAsFiNZ/sQRHA7cAQ2w51Hz3tfAX/wLu+pFM2oPPEeEjLQpdSuQZTnFhVPxrBcAVyLxSAVbaaX2qq1DucD89+FWIAPFbhSlim4s9uXIR3AiDwwQkSrz7BjgljSsSuBPj5nP7tFH8+Ax4AQRog8Yb6I/v1jC1C3/YL4ys2axZwLkeCzNfx8AbHvjMePClipqi76cM8YyBb8RxmtYw+ps+XweSjJV1VsQBGGNuK+1gh9UgGWFI5oxKq/diWDW2lgK1LoLoo4dovdBFC5xxXL9kOjDQh8V+jG2Ar0UeAks/iSJ94LRFdALI9M5VKByLA6FPH35n+BZV0MsUVbnmFcVDgSItGal4B0vqetD3T3PCwbAEzJjAHjd1l4A/d+HlwESaaxIk0MCQCAEzIV0AgFhhP5yBE9Qdxd976D5+QmjAZoERASMgBHkInj9WXxHG9M1gqf5r0RCBJPmb2J4osKBNNaFYL0I5SaFyNhQNteUTDTmxIY1bDFjsDHG9/3aHsNgNjeKAZf+tURnTHv5WUlHEThcbb9R/Ow+0h5qoDCDwRAFQxgMgvbRS5Z/wEuCdEHly7hbDhyO/QEAL04HnjK/+B920+vngq8zOimlNGPMaissVNx3EQBwhehXWWji1Zt6BJj/PLyiYsFWjmTY+4iZAE4AMUREEAzImEdPmsd7YTCElAAFEJli/yttYH0C/vQcPjH9rUMno5EjhzFoOhlUE0CCfcTBH5feKD7YDNFUupIq2jNY/8lQNpduAHDDGlZ3y+XzEypETsJWfVNrZ1UmX/DicTsjcMaqbC40I5EOJNDbrzd3f5xFPmnEME/BIIZDFAxhOAxOB3pJdJPgJtFLohsnPz8Wd0eR4BIqE4Bw6Edfg+tfBUJOLFFZ0yJgIlLGIK+2ZKsOxhbqi7GUUmQLsGyTo1du7P2/W44zQ6VuwSNtg0kTaEJNmQCO56EzTwd7g7sP5H97LDRKN0uI8WLzYPtjDLxjO9+QHCu9MjvHRTUb4QSf8x38HoNjBEAVgxEngWoHf57gH6oYLonRK5aJjDHGmF+LdMqGNaxhs8PgKulvbZ3PAJAr+KYkimdTeRkvLsrLmsZTA8z0xUgIoIFWbNbrngW+DxpJKQgHKRiGcIiCQeAMvXTJC51ENwmMFSe8ymnP5vyMedNxac8T9NhvYPpk7RpM1Eprpc2YGXRhB88CMOAycPBSm00ppVXm4EQ3rhlodtSn9qzJa46jWGKxwYbDzCWyNxWEz2STyIUQ3BhCIME5Y8gImIFQw85WfNM2PuvVZvFbq/AmT86licDjcCAhXhvRdZG5JaLnaVgBI/0TqBJ9OXSl+O9DZULCRH0WKpGXl0hw/3C2EQZuWMMWxLRSvu97njf1Zr5f+1yNoUzGtgnnFb+L4akZkjycmjky1GffJPf/xIpvUJDBcJCCIfQHwQQQS424oGMpkA5of0LuO9YLjQhRRHd8Fy68vJYQMxkAK112JS6S5lcL44Iutyy0gpym1J4hBAAFz12ebXEP/+veVYd9r8wt41ytd/2dqaFLkv3LuP8vx1crozmCUlafgjgR49xFxhgUAN51Dk87C6v7DQjo07u4ucdh/+Pw/yFoj+iq0LwioqsNdIxuskkp/iaOh6vyWpQd+CUAzuZyjXmwYQ1bKPN933GcqYuDo9plPpdtOJfnjNlaGgu/5dBmGWZqgjNowJzxPJNcxcJ+chGjHAVDGAxROIhRFp0m9FJQDgY7cQr8EscgtLm2BOUyUou8RS+0GzP3/5L19WJbO9S6LHjMuYdKlTnMIhk5CwfAVtxYCFPqGTxSvqbUWU35fzh//+Gc2xsIA9jiRB1O2CqKjtYHBmMnfMaZIiLOS2kHnDgQZ1wZdvUqduM6ZmbefWEmEhzVbEkAmDf/KvBhhocQeh38H4f/j2HLI7ompFsic7WBDgJIsH902A9megHLPQq1MYOZbFMq2ZgKG9aw+hsRFQqFRGLSPAyttTa1F8zpHcpwIcrOxMrOemWSh5xZzak5YY4m07pMb7yCPfEf4KUgLIDfB8EA+APgD2BTG3pJ5sRAuMQEIlKQQw2EEtABNwYGwQAEEfoB+QGgC+gWZ1AhoOc4/fqneNOrqhfnmp0FkaosOloMMLwwLmgotUviRFLKSs8MIloe7IHemsxvSVR2S7YBBPjtgKeUsqy3TH+tKUYu5289R9r2R/OXt1zlDhHIwLK8+bckvwFKaQYMu138mgtfM3x5ZK5TdF6C/+Uk+D3BEZZFOSptKJttJEI3rGELZUEQxOPxyeb0MAznI0iUyedjieRIGo3g5bbHzKZGC8ScT647FsZmHnNFAHX+K8WhOwBDAgM6NKrAdGCiPJCmeItuWaNRmpbVZutzCYASLZhop3Q7eKlihkwUwlAfDpyEO26DJx6g0CtSXsbN3d9jL/pdKJW/zAcSI0AQRosHeheSAY+QYM4FAI0bmhEiKtSoicbKqvX4eDCLBtQo6OXEgYAor81rzxbntDIzP8obOPOSYgQK6Trf/InH/mHMnxh0u+w/Jm+k4Ex9ARkWS4EZZ5lswwvdsIYtpPm+H4vFJvzTXHotTGaDmaw2IxlYI3WJJXghF91f/9a9777MH70TQ5oFjI3CqYjM1isLb78bgyFkAIwhd0EkSHiIkpIJSC6z8oRTz584cJg9eAy2kvG16WOmH0F4tPsROnwAN2we5YWuAiVnBKRBFFXmpp2mSVhQIYll/yvHAzNjkZU5NmZk5YgIREfy4IeKceK25q2C/oZgVqedN57jQjUwORP4nQ53kWAquo0ABfMhgXcJvL/6q2SojRCQJthvefRwW07OeH9DkLJhDVtoEjwZAM9HALhncLAoYlzqdjMKTgRizm990xuDa66l6YqTqmWcBJRqh3S7nZKx3ECnOEUTGoApHO0Cofcg++rvQv9hkAnkxGOGtYDuZNQ5SLt+BRs2zwZisbrNAEKlEBlCgwFPhMGVlcER54xzmxpdyY+JqLMQKaU4kQVeXsJgIMprvLqD2j2sifLGLHB6ciMCL2c+n+aXIlSLlC77oaKzQ7rCQFN5PyXuO1I/bb1Pw9lsqJQUojEPNqxhC2LaGKX1+K6FSuv5SAYdyuYZYxwZxjjGOMiKVnoIhkPre98nn3qycMtLoWZiy1R9+wQc8z8B2LWbf+uNOLCP3CRoQtu1KYZ8vTGa6PEH4JbXT01j5nh3IqW55GUVitMagMdjsCi9aUFFCKGUstnRUHJTG2NyUaS0KkPvyAugBJitrNfQivpc3BkFmBFI0zkF8/dx9rYq9y/xV83iV5rWhXRtYG4JTBGJcUwSVgmFe/sHVna0N+bBhjVswUiw74txqVhG6/kIAPcPDbO453R3tX7xc/xFL8ZLL6WkRxxRoZGQ+Mb/pj718YlhrC5FtyPGEBiw/b/gt78ThrrBS6IisoKUDEADIrDVnPL7INQgeRWVn7P5axQpbUjWvePv4gXgMRhciSiccSWUNMYCsFVYM8ZorRFBq4hsV1wyxA2R4URE5sLmAo+ySikhnTni5XzAMwL45q0Cf+Hgt6rfD8cjMfxijH1R07rAPN+nl0fmMoI4Mo6MY1nRlLO+waEGADesYQtoYRiOz4Wee8ff8ZYr+H4YJWMxvWkdi9TyW14kztqubnxh9OJbgksvkXsPtfzBW0uslWaHoFWC1DRbCYQo4Pd9gv/2kxApcBOkCZht4Y5IQCV1aGzStc2GHXNgQRRBRQ3S6ZsFPRkGW45bDG1yzrUo0l8igiL6KqWWJbhSihMQZ5U8GA0/v8kHIj8IkxUAXOcCpCn/SgiY05/m/HGOe2Z6oTgeifMvxOELmjYW1POz5ibFLkRmo8CcMdbdN3DO1sYc2LCGLZgZY5RSYnQkaD4ysI739NjCX4Ei85d/2fbUk/EH7k/sfop/7B+Diy9muTzvOVmcdJKpOXLZWUZhEYkDP/mYvPu9eORe4AmSLmhThFsGpeJgAAI0Ea09ByS3rXdqjzIAfkUKdIMBT4DBlv7aNgvMGM552f9sjDHGMKaI6JK1ic8/3B8pxYlVuqBbhVkXV4iYK/jJZLLK21K9InRVCD39RmRgRUgvjeFHZ325OB5MiM95+Lm4WcPC3/f5/7ElCNlcPlsoJCZJA2lYwxpWB4vGAbCh2jugeweHi1pGwFjMGfzkZ9I3XIuDgwDgPvDAqDlpaJApbVyOABgBmLqIEwkEAvHQvzmPfBSCIYqli+nNBEgl6EUCRGRAxoDgbMdNM4T9mSlaF4JwsRUBAwB/z/v/apFg8Kjs8FKzn1KWLys3AkoKanPN3YezFV0NAQA2p/Rlyw0iNqUSrU1Nc13TzXgoVLVLApT4SIK/E6Ewl6ul6Ny8+t2cflshukLpeBhGYRBEYZjw3OaGHEfDGraARjRGljKXrb1S7KN79kvHicXjXiwWkx6uW4EdK5M//P74aci5/zfx73xHHD1O8SStWGFcBhyxgmjiJFPdSPOXKbfEsQwYQSAOHJU//EPxyGeAETqelcHCMuWt/BABBDnYeiW+4I9tbwKchFXj9F891dF29Q8YAimlELKyDXCDAU9AhSvbBhMRlNzU9k/XbEicGPRveyJrg8OciICWu2h7kmTzhTmx2JlsP0P/NjIYTrBbEfpn81yDE9GFgbkhNNdHdL4yGFEEzGcsK4QQQjDBO3v61q9a2ZgDG9awBWPA4yqOak6Aj3X3FHswsKIAFlcs/6Y35O+9J/mf/zFuta7ko7vko7tSf/vh6Oxzgute4N/ykujZzwHGppi8cHaJWhwBgT3xQ/Hj97P8YUqmkACIkNlAIlr6W5T1R0BGpBTGkvTCD4AQU0hRzjE1jIhCpct9kE5rJaxpMXjMi2IW9GiJtVecmejNhd8/EBABCeAELS7nTACAH8y15cj85GEhAcTZH3F8bIa4m47Mc3x6YWSuVbTdlPbMUDMEZMg4FyUp9pP9A42eDA1r2IJjsJSyPH3V/JHsGRxkjPGSABZjjAkGkWGDg1N/kPecFIcOst4eIDOKbs5hihvZhUAIff7Dj/L7/g0coHgKNYAm0oACEIFYOehLQAgEYAxon178t7huR22FoMeqQEcqUtoV0pZwQiMGPDtsrrTfPy855Ou7jkcABMwAOoxzRPQjpZTiM6+IrU0e1iRxZQJw8TaXfWEGjzE9p2DeHJqrNWygkkIbVuybVRQhCSHso3i8++Tq5csW6gY5UgohpJSIaCNhRKSUMkRRFIVBUL0irt2blLKotMcYAGibjGeMUioKQzUP+aUNW4pWOVoWfOwppcoAPB8ZWJ29/fZ5Lz71nJHElg9/JP7D70+wNWNq2zb/2uf7N74oevZzTGsaAFgIVXrFq0yFZgLMiX3sq3/CDt5DqSQiggZiBBpQIzACXuzzXmztzoC0higLV/8ZPOf1ZfmOeZKD9sMQFlkbhiUGwCWXAVrxRQs2f3hhKtTDv+6MiMG3j69SifR1ywaaMMr7fnMqaagsyDxjvJwFQk+xJwIU8GScv3Nmg8a8Nm/eUOrcRWOOoaIpYVmNTnDOO0/2rl7WUee743me4ziu60544+xk5DoOJBJKqUKh4Pv+VOt0zuPxuOu6458WzhhnTAKA60IiobUOw7BQKOgGEp+uVv3Yi6Iol8tNLUpVk7EXRdEoSayacuCB4UwQhomkaxkwYww8nvzZnc0f/ciE2w//xQeG/+J95DoMAA1MqElZDbZN+leGyCC4/8f6K3/u5jt5ugkNFYkvB9BIiqxE5ajMZx2iicw176Or/hTMRCWb1RxP1YVShSAsi4UtqiSspQHA5fYDNvFPCKE455w7RH/yrKaP3j/02+OF3mzhi0c2fasrfWV79pVpun4zpJ1RBJTGPQgzCN9Oqc8ybeE4Qj7Bb0UYniEjD8uUF3HswY9qDMy57UfGBO/u66/nrYknEvFYrPrRLIRIpVKe53V2dQ2X5DOFEEJwKaUjnXRTuvodcs5jsVgsFvN9P5fPmwYMn06UNxaPz2jsSSmbm5ujKBrOZIzWfhCEYURkfL/YZm3N6lXNzc1V7m2KsRdVsF5T6yZIh050lp54IThnMSFPdLe9+Y2oNQBQIhFc+lx+/Lh86skiBd+4mVyHBYRQrWpj9QFg5AgMhv/708E3/sF1iCdTXBvBgDSiJlBIjJABaAROwAAMAUMM8yQS5vn/RDtfPQH61mplUGF5P6hE3wYDntmTVi5SKjE9IaS0I5sx84HL2j7+24GfHxtgFA1p+e2Tzd/qwU2PBhctZ89exs5vw/UJbHXR48ARyLa8J0AEVroRHG32AGgAZWrcGYkAEuw9HB8cf/EV7QzNLQTJBH/XRB9MTXtlrP+ZcS5F0XxTOFYXL7TruslEgo8T3qtyKly9alUYHR4cHAIACAI7o23ZvCkRj8+OBnmely8UcrncPATdGra4bI5jr7WlZd/+A0PDw5VoumXzplQyWZOxZwV07URfcx3Kzt6+0oJbCFfyXL7jTb/HctnCTTf7N94YXHVNeOYW97Hdyy57NstkAACjcNbQhdPitNHdn/6b3Hf+NdYUF4wrRYIDY8g0gUZihBqAIWkCjcgI0VCYpY6d+pp/gjUXW/StFR5OsZ/xDLgBwDPDYMv1OOdCSCk1GWMB2BgjiN572bINTw59qbOP0is5as7gQAYOZMw3DtHqJG5NwaYUrk/i6ji2utAkocPDFTFoktgXUE+ehiLQBpIOLI/higRKhICmqZerWo4DHfyaw/6lAlYTip4d0Y0RXavpXCJmADju89inJ3DuTHdlWCUDtk25Oe882TOvXmhEtCx2LjvhnG/ZtOnQ4cO9ff32v2ds2xqfWxFzPBZzHSeTyYRhCA07RYlvOp2e0OE8o51s3bJ5Psbe0NCQDfqOhIGJauiC7u7r98MoHnds9BcF9/Yf8n/nVdmvfBU2riObnhlCeN5ZQx/9x5a3v2UUOM1BgXLCvzKBxz/36Z7/+EyirUkDKkWcg1LIOTENpMBy3yIMawAKgBmz8036kg+A1zReVnqekFhpHURKOE5DiGOuGMw5JyJjHFsTjIhaazIGAF67o239Kv33B3XeIDJwGBDHlANNEhChoGEgBI+Tw7BJgmDgclQEmQB6CnA0S0ezdCxHgwG1OHDNGnbzZsFwAgyeUVskAuTwRIK/HgAI2hU9N6QbFF2raTMUBaIBgRhgTv+dwLtFdQnSo8LAJeVOzrmUknMhpDja2X3eGVsdKedlxAiRTqdFjbo+bFi/Pp8v5AuFLZs3xWshIcI5b25u7uzs6uvvd103FvPm6To0rJ5mjCn4PmNs5YoVjuPUZJ9r16yxY2/u6Fsee62trcPDw77vVyZC19AOneiy+c/c+ruIqR3n5p57seBChIBUDJdhhNm3/V/vFz+P/e//jMGjGqQ9V7zWQaA0V4ZFijgDzjHixBUwjowRaQRNyAAUUDRMyzebKz5kNr+o5Iec8VpgdgcfhJE2xmGlPkilUpoGAM8AfQHASkZzIiEElAA4iiJTYsNXLo+Wxbv+8UDbwcAlBMYgxiEuICEwKSBlfyTEBcY5uAxyERU0+RpCA4pAEwwGsLff/PxQlHLghvWiQFVh7yR/QYRBj30woptC83JNV2lYWQJdGP0JIkhm9RebxOVTCHSMDwNDyQtd4ZiX1iN9vPvkhjWra34jpBAtLS21HbtbNm8aGByanfdvMlu5coXjOAcPHx4aHhaCp9Pp2Xm2G7bgprUeGh7O5fLxWOyMbVtn53ae1AezedPA4FC8puJx6XTacZyyD6aGMlhhFJ3o6ZWOWwo3CSY4EvIQkBOwiu8xBISDn/y0e/ddmMvhTMCsegloAmi97sUn//uLUag4R8WRWxLMkHNChqgJNJAJwBi64LX6yvdjarmF3rl6v2EGGVg53x/Rd1pkWdBsaXmfEJFxLqUUUjqOIx3HcUreGEQAOCNe+Ni2oy9s6QdDoQGHY4xDjIPHISbA4+ix4msEyCvIKygoKigqKChEEGlwOSHQN58OVSk4gbNcjhECK5hP5/S3QvpdAytLGVU0Bq/t+4ouzOu/ntG3FC+Idc7bRCb7m/P9R47NB/etOfoCgOM4y+fBYd7W1rpx/XoAUEr39w+c7Omdj4KQhs2rZbLZru6T84G+8zr2PM+LlxZ8qnadgI91nyzqbwghhORCcMYZY4DIxj2VGJJevXzwE58yLS0z4rXV002jIbHljPj2nWE+UAqVAqVRKVQalEajAZSh7DA1bdAv/YJ+0aeghL4z+pYaZGAVAlut2XBBzwl9R/UuLDpbSuuaKLKtGgAgwfRbV554yXp9h7/iwV5SBAzB5egy8Dh4AmIc4hyVgVwEBVX+obwiZUgbchg80KUOD5sNTSycXQ5j0RmdBkiP47ujeXNZJQvAN3/s4C8l+1EZwqdefhZfl73QRfQVQorhbG5gaKglna7h9W+dB/SdV2trax3OZHr7+gDA9/2u7pMdba1zDB82rG7WNzCQy+WhFKOtOfrO78RaGaOpEQc+dLyTl7JgpBBc8PGSijgagwuv/B0s+CykueQ/T/opIiaw9ZobMr+9WylQHDkfCQNz7TODcPnv0Y1/CukOMPY64KyhdNZIbFOgF2cW9BJjwFBSnyiGQKSU0rGEuDwW7cZnudkvPld882rxljP4jlZscyEuiiQ4JkAyyCnKhDQcQiaCXAR5Bb4GbUgbAKCTOfNwt+KzGQeVf5+A707BmAkwqz9rYEXpw4lpH4+R5lElF7SU0mZj7T10pIYXv7m5eWmhr7WNG9bH40UHozGmu6c3l883sG2RmzHGEl/73zO3bVta6Dsfls0XegeHGOPFB9y6oEu4MvE0RQAEFPOAaoN2498kgJbLrxVty6JARwqUAqUwinQ0PKyXn2H+71fM//lHSHeAJiDCahss1BKJtdaFMLJXiS0+F7RYWqOwsiQJhBiznLGZWUxrxliu4Culz0jzM9JIANkIAkMEIBm6DBiCw6EthgVDgyFEBvp8GPBJa9KGtKFI06Pd6hXbnEmJJ1T5lxlshkAa1mXVJ9PilQAA4E77qSIAs5EEcVEsqhWdPb1BFNUkBSkRj9cq86X+tmXz5scef2KEV/UP2GVKA+cWrQ0MDYUlz+3qVSvLS6ilaFQjXdsn9u4vSl+VmIfN9rCoMsWqHmlO+c+TfsR69jR4q1enL7yk/2ffU25CKcQox1Ne8pZ3OS/5A0g2gbbMopZkt/qDRoBCGNoMLIaNOuDa8WAo5WSJijctANucrDCKckGQ4nE7/FISUoBlOQ4DkHAw5cD6NF60HPp9erKX7joBvz5mDuUMaSKiPf3alMBvMgisTbPhCg0tBAroFb55s8c+N92HRkliVVZI2zBwaOjg0WNnbNww1wvOWCKRWLrFtY6Uq1auPNHZWX6nu6d31YrlbAkS+tPBMtlcmftyzpd1dCzRsWcnJSFEGARz3FUYRcd7e3kJex0puSwGgCvhZI7h0pn5n8sAD9h67U19P/9BFGgs5BPPek7bm9/rnfMsIgBFc4TRuQeAs3nf+gkAF10K9JIE4PLlK19EMXZIFEE4k8un4nG7CNXFuqAK9KJiQoBgsCqOq9fhdevY8az47v7oi4/7x4fp6LD2NXA22whOFSKXEwIzAmT1P0r8KUJuwodkAkksxhhj5bVxMUGD8/1HagDAiXgclzhWLV/W0dXdXZYMJK37+vs72toaaLfYLIyigYqOAsuXdSx153MykcjncnPcyTMHDxttHEcIKUUp4lZswzARpZs7blX/KUPQ9JzL3RWro97u5X/wgeX/503MkaRgTN/BhULibL5Q6X9uMOCaYXBlTpasvKwlHpzJFaBjesAjgqgEziuT+LYdzku2iPfdnf/5wSATUmsMZ1kNPEM2PMJogQyks/pzCFE131jphS6HgaWUoRSFXP7A0eMb186pHim+9At4OOctzc02G8taoeD7QdBIyFpsNmCV0UYAeNnSPZdyZ1UvFisU5tL/G/YcPsKFLK2vpZDCCkFX1tVMGrWduf95RiVApEmmU+03viy+advyG2/WBKQmzDmtFofn4n8e/5cxGVh1mnD8/drbWE2KFVu647uck2XbYpawx5FOMS0r78/E84MAAJGBwMDKBPvCDcl3XhTLBGZse+fZFonjTIYUAkX0/JCuY9N5ocuXoqyHJaSUjiNE0RH91L79c7nIE6rSL0Vrbm4a885QSYm6YYvEgiAIKry1zc3Np0bu1RzXeQeOHteGOOfF2kvLgFmR/s6Rv1ZMp7Of04ymNf/3j9tvvFlpogrlzdlVN83s4zjpHhEgiKIgUnVOgZbD98SPfqDKExVLemSPyskCECX/s5Zaah2EQRBFrpQz9QMHBhDhj54V9zUoM/0omUurpcm80FS8OzThozKFF7rMgG2qZMEvHDhydNPaNbMcTEKcGtLKzU1NY87D94PAD1zXgYYtDhvOZCvvUSqZXOpjz05QjpRzqUSy6Ve8/GiXlA8mY3X19D+XWDAgZ6SmILU4X0isBgEd4PEJ59lcoUC2UBPrRIJRZ5P7f9+4a6s8P7bUH9rKpkCslCVok4EBWa7gz25IGYLIAJ8938UZj+axn5lAr2PqiyBKDHhEokQKzviTe2dPgk+lbOFUKllRGEYAlM3noGGLw5TWhUKh8u7UVqBqYeeoWUu37j96rBAEVn1IOo6UjpCC88Xifx41Y5aDvrND91l9koZ/TIdfB4WnJvx4JleoWwaWTQFOHPpj7u8jlqSSneIAPB6GuW1RzTnnPJPLz255iFPUD8yTF3pu+xxpVsGFkNK1CRtSCiH8MNx/9BiNAZ/qfk5tKxT82V2Wxk/Nf/LjoqTO0ndOVKrlzO6yPL53P+dcClkMLVVoHjCsllbOq/+5hug+my8N9kLhEXP0TdT3VRzXWSlbKKZAz7cL2gKt2/Nl7+TnAYBgBH2nxmBxykymFUS42DaYc57JV5X7MG3T31GbVf1+kdfOyQs96QMzYXtgUY6FO47jOIEtV4j4U3v3z84LLaWcqRvwsXu/d2zfrr2P3gUAW3dcuWbLzvOe++JFNh+WVu3GhDUqlW7YHC0YV6vjLP2xh1VwoCns6QMH/SB0PY8LIR3HEdJxHZt+ZcV3i/UgVVPVeqPmHNoqTL3P4l/JQLAXeBpMQCc/avL3s2V/Au56C8RK60IQCunUAX2JSBSeSh36o/I7xphytU65N+WpDMBQUZ5UXvUUgiDSWnI+H1W8tc+Fng6tp4Bqe9Zk/fBlrWwppZQRDwtBMLtIsNa6+kSYO771ydu//NeF7GD5nb277gKAWLL5xtf/5dUv+8PZ3db+rsN3fOufH7v3e31dh+w7bSs2nPfcF1/9sne2rlg/k+dkgkhc4PuOOKWegiVqYRjNJeA7xdh7+dv/37Nf8LoFGXsj6DvzpoRhFJXFN2xiqXQcG2OrRN9Zw+csCO5sfdozj8dVicRRL0THAAQgB0xS9pc6PMTXfwVECxBkCwVtyJmdBhZp1EMkWqu9xTqX2v8G1MUcfkKPjIFSkc4UX83f8/6/OsWe5JIch9Zah2HUlIh5o31ZVd6H2Y2aunmhJ7ynVFEGrZRSkVJaKaWMNl29vZvXrZ0MTYUQrut6nudUGCI6jlOu9Zravvr3v/ezr/2DCicIuqvQ3/3AT/q7Dp932c0zPffbv/zXn/vLlx3afX/l3FrIDh7aff8d3/okAGzdeWWVu8rnC8lEorkpnU4lyz+2t1sD/xbQ7NhzHFl5XwTnnudVk4JQyA5+6W9efee3PjnZ2Hvs3u8u+Niz7YFd1618vqwPZrKPPLnv/7N33mFyHVXaf6tu6jhZI2mUg2VZ0VHOYGxsgzFgcjAmGAxe0sIusESTl7zsR7ABw2IMJoOJNraxcc5RwZZkpZE0OU/Hm6q+P25PT09Pd09HaVpzfo+e0Uz37du3b1XXW+fUqXP29Q2PaJpmGD6f3x8MBv3BgM/vNwxDm/BCY1p9wCm/sFwPTj+Y5T/D9AdZwVPlvgA2wzlznZbNeCQDktsw+gcwFem6OWobb34joDKgf3g0blpeREwqbG3iphUjI4He/+fr/R64T+gLwAvVPhdChDv/0zf618nJk/+keMOlyFgbnRMWcOYH5izliB6PxZvCRZe6K8sGxRH0Qs/kmmaqojgToViGYViWaemaY9umZe7af2DDmuOyxr5AIOAruNeoGB/aL77+zkduu7HwMQ/f9jMJ+ZaP/aT41pzxtLf87AtDvQeKPOeS/PUZvQ0wiWTS+zrZGRVsGOfko66QnLc0q++Fw+Hy+t7Pv3bl1gf+Msv7XihXtU1vh31m30sTiye2P7837cTSdV33kt6rWj4VyWkOl2T+1pn/GZDJXZAW2IR9JW3mWwtueEOkF4GleNk6OUdJFjBTEu3vadp2mjH0e6EvsZousFousxteIJXG6caeMfTrQP8Psjq8l/aHMSYLur6PmgAzYUpe5TQInrd9okof9yaJ47Giku/P5E+eLV7oAqdiGR9cVVRN97ZE65qu26bluM6O5/euWLw4GPB70hsOh6siLVsf+MuM6uvxyG03bjr7lUUuy939h+8Uc9pHbruxdcHyl771M5V8BMMwDMMIh8Nd3T09vX3TD/D7fQG/3+/3FT2DJmDZdiwWTyQSjuNOFR7/0sWLw+EqVIB+5LYbZ1Tf9JGnX/zW4zYXZbPeeuMXi+x7i1dtPq/ctZXMvhcMBmOxWFqGH3x6qxdQqqmq36cHfIbfrwcN3a+rPl1RVaZwxhlYlnt3It+fZyBKADIjmnJiYJHIGGRYCYNMGR68WvmfU06tJyDFlM9vrPVe5bpuwjQVTS81Ais95xNK8/jqXzY9+yJuHfL13+Drv0EYS63GC6zW19rhs6USTpUeiO9q6Pz3aScRruum98cW+oB9yaMQ62oM/V4y1Wq5rOpnllK6rus6jmVZpplMxOOOZZ14/EpNVWV2R83+Paub5n4247B8B0x9UBZzznwXMOOr5NTL8NzPjm0nTTMRj8Wi0fHx8WhkPBaNJmJx0zJbGhsuOPP0UCgUDAardc8/e/nq4d7OIg9uWbDs8zftKcav+NnLj8t0/RXAH2r6+A8fL2k9uNCXOp7Y39kZz1U0iXMeDoUaG8IkrjN4XF13eHgkmSsH8tIli6uY36qkvrd41eb/+tHjMx423Nv52ctXF3lOf6jp8zc97w81Vee+Oc7Y2Nh9u7u+etszqqpxw+8LBI1gWAs1hsIhIxDSDF/QpzOuBDTOGXQOjUOb+EXnMDg0Dp8ClUPn0Fnqce+fyqAwKBwag8rAGVQOBlgCGfkzKvU/Tz049yYjjcGofCob+SP6vw1n1EIQkEza2vIfwncagMHR8d2HegKBgM/v13VD13VFVWdcCc6MW/b0NdT7rfChT2RFV7vGCrvxxcmWy2zfhsY9b9SjD2WdZyz8uoFF13mbUJSMcvWzwgLm1uHQvvdGl3+7Vrb11C1JppSReLxlamXcSjzG+UKmK/RC5zxVqa7pzA/u2b6Grpua7lVoEK6TiMcMvz8QDFZr2tW155niR0BvdDu855lFqzfP5DO8sUj19dT6mQf+XKEhMjmkBvzHrznu0KHDmakr056lsfHxeCLR1taqKrRynGdUjEZHp2aU9PDK+gYCgaPV9w7vfWao90DLguUz9b2fFX/ORHT04dturFbfU1S1ubn5mf49fSZnQuVM41xn3FC4zqTBTY1pKlQFjKfrDWYKXjorlGcZK2zKPzVTp5WUJLfoOK1VbmrCQh8UBktMST3EZrJEZ4rVyuEX5wx+jq4E7uqHTwEH/Grq8YAy6SfmgKGAZ4yEGSM8hITpAvzVrn/DvNGvHa8+LKQRZ80PjCy3FajAvkE2lmzShK6bus01zhWucFvCFilzJeGmXAVe9kMABkdQYU26bDfYfF3M04Wfy/F5H9LGH/CP/VVkbNlVzP1K//W+/uuF2sKd4VxCLoRwhZh5iDjSAiylG9p7FXOGJA94E42qh4ZPbkdiXv4TPhaJtRRRmn72eKFzviL9sMLAWeonJESGZ8l7WnDu52oSqiZ0zfUxx2SuBdsKhULnnHZKYziM6iUYOrz36TJesmjVpsLHbCvOr5h5/Hmv/kC1PpTC+fJlSyXk4NBwTs9qb19/+7w2WhueztDISCzXok/A71+75jhFUarY97ztRqX1vT3PtMyfwVOy55l7j2LfY4xd84otCRc3b+9RdJ37DMVnKIbOdY3rKlMVprBiljO9uywkhISVfkRmbDKWkICQ+Fs3azewoUme3oLNTVgcgE9JZSISmYPXTPHPbEL4VQbBwAGdgQEi45KERMLFs2P47h7cPwidT0klmRUOprI8xgaDkKlKS4KtCbIfvLPxJ1c1Xttttb9/W5uQnmyHDR7m5WgLA6AwpVXnS/xiU9g9ufnrm2NbA06nmJY2I6f6AhAwitkEfEQF2LuUQNdX9NHbAQge9HZHVVeGs5aBPVtwJBJbCZkvb6orIcpT5XLLA5ek5ekHOYPBIYARCwMmBkwMJDFowatn7B2mMPgUpkqugdu26pi6Fdcj48bQqBlPBL716tMXNFa5skJJJkjxLzm895laj8UzsmLZMkjk1GDhiv7+AdLgaeo7mlN9FUVJqW9VKd5HMmk0731mxhCEUvtSqX21GL7yqi1M3/qXPWNcM5hmMFVnigruWYhFDZVsmqQVENERG3f2sTt70aRjdQgnNcvNTVgRQqsOnXujN0R6dTnDluXpt5BwJJIuki4GLQRUJF08M4q+JCIOXAFbIuki6qDfxMEYLIEmLfekoRgjmzPoE/5wW2rfHrl6h7lxlbaXM2ZwVK4lrkS/yfpN5fFR5Vp+/OvZ1z/L3sCmVzbOd/NFlIm4lDNnkjlCAuyprDZ2Z/DwF9P3uqYWMBi3JTeZOi61pGVvG3GYosVdJFwkHMRc+BQsD2BRAM0avIHBxeRCSIUKygC/Ag64gC1TGj+jF1phUDk44Eo4Au7E8SqDoWDcxr39uLsfuyJs2ELChSvhVWpiWZ1YciEUuJq0XZE0ZNIv4/bNr96wsLFu6hqVMbbWghXLl5mWGYlEc2iwkP0Dg6TBM9q+iqKsXbN6lpRV8Acb66Wv/vfLNvX+6bknRxnXdE+AGees1Gje4lAZvL14CRdPjuCxYWYoaNOxLIgVQbksiIU+NOjw8ZSNKySSAgkHYzZGLQxbGDQxaDHPNmgzcHxY3t7Lxuwpo1PaMa4y+JRitXZmfxVDiOGuxNn3Js7Wq31vGOAT7Nd4/Sb+z1fx64sU4Ob4X4MHtyfCF1strxCNZ0EJHk0B9lazmdUb3vsuTGTslgJCiNRWtuK6lCNhC1gCCRcJF0kXMRdRB1EHcQdRBzEHURdxh8UdJeEqCVdPuiFbIO6CDzBHwpnwuggJxuBX0KZjRQgnNmJLKzY0QOdwPJ+JLN9yVRhMF9fuRbOG48JY7GcthgypUDxllVNs7rQ/WUiM2tg3hgETC/2Yb6BBg5+DM/Qlcedh/KWbPR+BkNA4FC+2okC3kVy6XDJVQBfQP3zKkhPmBWuR2n71pheU8ZIZr6Rl/rLhvhJsa3+oqUaJ+1evXLl1+w7HdXNMk4UYGh5pn9dGodGxeDyaZ7tBx8KFfr+/Fq0z40JGrpdsnvFK/KGmkjS1Zf6yGvW9/33pcZf+pSuuGkzVoKjppd/aoTB4MyUJDFroTeLBQcYm1o91PjnLtwVskbIBRNogZmCAI3A4zpIuQkdwhdPHapU6lwE68C3xzc3sgZXsWVFU/map2/v04eswfJ3jO95quthuvcwJnS6n7Scu/w4pyb360B+slktd/7piNLhp/3sU61DKgQAx4gRVV7guHHBTwpYs6SIpEHcQdxF1EHcRc1L6mnBTj8ddWCL1T8xcqY+l/3IkGIM2NYpPSPQmcSiBu/vh24e1YVy2CK9aBJ3DljPrbr7n/Bx/7caP9oIz+DgaNLT72IqgXBXEyhAW+dGiw6eAM9gCEQfdCeyO4Nlx7BpnXUmYLvwKmnXM92FFUPoV3DfADsSg8tzTxrxXxjgUlSnqqQuCl69rrFG/L2sQ3FTMQFmSAJcxDyi2nyvK8mXL9uzdl/NZy7LHxiPNTY2YwziOMzIylvNLEg6H5rfPq9H7ljP52/yCYvpnScvAi1ZtrtEHDOvKR06d98Vtdk3N33wDW9osRsbybebwqnKouWYEUQcAtCM+Ka3drdGAITR8Ufz4OuUCA0lZylupyV1q7y70fsf1r7WaXmq1vsoObQHTKhVg11imJHY2P/1Ju/E8q+Uyq+li13dcTukdtaTe+wPf6N+8uYM3U/lxp3wMuiZhC2ZJOAJOLfdD5VyN96Zs2kQP2z6GJ0fwr358ZSMatUkPcLp1M+PmXaRi57IIKHhkGP+zC0EVKoMEog5GI3hujAlA4wgqaNDQoEHniDkYszFmI+mCASqHxuFXICQGTPQk8MQwA6BzBEttKMYY55AcqnbVuhomtfeHmrZcdMWjt/+8yOO3XHRFMXs2Np79im0PlhCHtbGWKX+bmxrD4VBORzSASCQa8BkV1nyta0ZGx/JldFq6ePGs6nvFHfbWkgS4pn3v5cv9t/TxpyIKuFJr87ewthUv/Zwdg508CNwnz7xBfPxq/llZVkMoiZ3+xE5/z7dd3xq78Tyr5VVW00XlCPCEv0WJrviOGntCG/uXNvavAPc7oTOslldazS/xlLg7iSeH5b3DaIw9+mXxqayLHrfMPslmT70xBvgU+BTc0Yd1jfj31XDlZCg/gKTA13fhcAIBBceHcU4bjgvBASx30hJWGEYsfGUnxh0ElNTjqTPwlMxbAn1J9CQBCTbhf87SVy+6oeIMiQyMn9yqnNzCalpX9SVXfHrbg38txmvnDzW95IpPF3MxWy58yz9u/GKRRrA/1LTxzJfX9DN2LFywK/J8vmdHxyPt8+aoAJummUjkLnnS1NTo9/vqru9tPPPlxXuhW+Yv23LhW2r6Gd91nPb+p5V0NT3iqOACIYjj2dNVsAbtfp48wKxeKWXJApwZXS3gH1/xk+bnzmMiwURCG/+XNv6v4EG/03DOnewtPxw+d5e7bB5GfqG8NcTGMlznUgJJBGdnb9J4yoXiLXgMWdgXw7YxdCfwm0OpeGMBtOi4aD7esQLLA0hO+MMNjrtHsDuSUt98E8kjNkNknL9haWlvloiObXvwL9se/GsilhqAFq3cvOWiKwr4jVvmL3vV1d/45TevmvHkr7r6GzNuAknz5o9e/72PXFTUkR+53h9qLOajde17BoA/2FSq5zwcCvn9/ngepUmaZiwWDwYDc3BgGhuP5BOf+fPaZ0/fe/NHri+y7/lDjW/+yPU/+dzriuylxRw23NfpzSbL6HsnN7OFftZrkfoeTeLAh/l/v4jdLMqt4evoy8zwi8ymS+zwOVJrZYwxKUvOhCWnAilD/d9tPPSRrMviEHGEH5YvCiN6Grsr81kGAeDt7iNPyC2+2Xejky4uXoAL2rE3hp3j2BNFv4mEO7lhPDUhkoi7WODDu1bidYvgU2AKGBx3D+CDT0HjmA1fl4WG+/stTvHH33Pz9/7x8y/lnPuv3vyCwkPYtgf/+stvXpXPbvCHmt78kes3nvXykq7/0dt/PuPY+uaPXD+ja/Gem793zx+/m2lP+0NNG896+Uuu+HTxE4K+/oGDhw7ne9ZnGO3tbXPO/E2afQODOZ8ydH3TxvWzpO+983O/LXXBuCp9LxEdu+fm7z56+88r7Hu/Psy/u08lC/hoEQVexO78nvISDkeWKMBJbW0scF4ifLEVOJlpDV6CZC9DNWOsTAEWQqSr7kgpWzvfFhr9/XQN9n7JenxCgB99Qp42CwWYAbZMBXlxBm0iW1tOvKjs01rwlmU4pRlBFY8O4WPbYLmzYCFEytd3OB9c5RZ5+K+++e5H7/h5YcvgfV+/vcD8PREdu/dP38sablrmL9ty0RUvuOz9xRip09mz9d5fffPdOX3RLfOXvekjPyo8sHbt3fp/n399Ple2P9R42dXf2HJhUUuDlmVt3b6jwAEL5rfPtS1J+bYeAZjfPm9J0QvAVel7t/3iS4/e8fNEdOzY63s9Sfa6xzQwykN+NGaZwHz03qie2YEDRZq/AnqErx3Vzh03zjV9GxXVp6gpFMX7qaQ0uCQBTnmePd31Cv65rhDikcGhi/rPmYeeYq7PE+A3u888JDc1InccXX2RdMEYlvjhV9EdhyVnxyeS4r9PsF/QVlT73vaLL//j518qxjv3kWsfmXHmnna4tcxfVvw0vwDbHvzr9gf/mh7LWuYvW7X53BkHr669W7//sYsyR+ScvOkjPypyHNzx3M58XmgA4VBoroVDHzzcle+ptWuOC4eKKrfwpx989J6bv1dM3/vMz3bNKKVV73uP3vHzvc/cl9n3Npz18hl9OVXve699VO01FTKCjzACcCG/q7zyBeyvxTufD7DX71H/gysp2fX+0zRN8X5OqDFXlHIF2PVKHji2497QY/xuyP8q9sdvKK+RYEWoj2TAY/L8W+SbHhUXHsRSBzCAurYdJOAICEBjsyMIUEopxW1n2cVsxRvu6/ziW9cWeeKNZ738ys/+dva3SCI69s33nl5kGNf7vnFbMS7K/Qc6cybG8tA1bcGC9rkzNiUSyYHBoXzPnnbKSUVamd//6MVFvuOWC69400d+NDf73pd38lsHVDKCjzAR4H38Gx/kH8uSNgbpbefJqcp78fY9ylUKV7xKDJ78pkRY0zQ1rcRKac2ZlTEj6eJ/DwbuGPI3An+Tr/6deG9xm6GZBNvC7vwcf9dv1M3fU175OnbjAnQngShg12c7MUDjMPhsUV9AhrgbVDNSv+b/94+ff7kkY3Sor7OY0x7df/fc/N3idxLf9vMvF3NOr4h6PizbFq4LKefIP8uy8t0KQ9eLbKZHb/9FScbonO17CwwhhYCUJIpHjBjwAnbvv/FPS0CmakwIDsEhGORBufpJ+QI+LZExgxzAonTUer40U541W/58KuHK/zngf2xcx0SukG+Lrz0vN/JCmZUzTXsuwMMYPY/95YvK236rbvqO8mpPiRNArG6VeLZY5EKsDogiR9LtD5VW+WD7g3+Z/fLw2B0ljOx7tt7btfeZGc8ZDocKH2HZc6jbJk0z333QDK3oZvo59b1i+t7qoIAUgCQNPjJYwAIMfoa/U4PFgAndxV657ibxofe6t7/Rfeqd7l1PyBdmSR6DfEIut5nqBVspSsoOTuMVKeCcg5Xr0HAkvr3PeDoy6d/UgFGEPi9+OoaW4pOCeTIswBsxdD67+YvK236jbvqu8urXsBsX4SCvbXKOY1l/IQVEUeFXw32dM65UTRsy7pvlnz+9EFjKyP7XYu5r4X9J05r99lm1/lmWne85Qysq90vXvq2ltmzX3q2zvO917dtaat/bu3XmvB8hRUohpBA0uh0BvMoT1/B3L2V7ANjQt8st14vPvN194HL3yS+Kb98tL0wgZEH5kvujcTRnabApI39xl+m6rum6puuGYXi/eAvAngx7xYnLzIT1owPq42PZ4q0Bz8sNI7K9kQ2XGofkedI5RBOGzmc3n6/cvE2efq34wkPyIpW6Q4n+Z++LelxQFBMxX+pgASARHZ3lE6MyPhQw87Rx5prOc8k6EfnFQNd1WVxHKqNlZ/ktLuNDJaJjsoivNVwHnAO8/uNWZ7n5Ahviffy/z+V/e1yed5982UPyor1yUwxQAANIxxb6gWex5tvu/3xWeUdmraTjVOcPTuPzsE70Wd7qr6Ionj3smcWe+VuyAHt7kG7pZbf181wXjc/xDyxnO0vdqpy5YWmP3PCIvOgBefFOeXIUzaS+ZZm/EsINKkWtGJVZH2aWK015V1fEhyqswUnTbJwbGuz5nyvtIaXfKn+waY72PSmkkBACXDIvix5RswZsRaRXLnmds30f1piABmgZujvFMwH8Vr79NHnnJewXngBLYLVhf6Sh85eRJZubRwxD9azeCccz90rlslIF2FPf/TH834Ec+hoF3shvLL5gU6bumvDtkic9IC9+UL5klzx5HJoC6IBCfaEsAxhSSOFGTLeY0PKOlSVXU1hVs8oHs33YrImmYI7eTGDVpnNLPXNH6cU/jpW+J6XrMFUruigtUSYciKLxd/JtyoT0FoABCvB199ublIcWs70CXIIHMLrMr5zBkg/EwpeGXFVVJxd9JwoAesFZxQqwF7LlCPn9vXx6EYI4sIlt/wj/d0xEi2GGi5YMMoaGbfL0++QlD4uL9mFdHNAAPc9Egyh2Hi2lFK50nd2jlkRRmU42nHnp9of+VvybbDjj0lkuMyvLGNlXbCzKBS1Jfmf+sPF4vHgN3ltKSMHc7XtSQrjSdZkiyAt9BCi+ToEO9KHtS+JH31cu8qzKLiwJKspLW5K3jDaOS96uKmmTl00NjS7BVyyl/EcvdkayG94Gwkh8nl8ZxmhxiTikDf1b7rdf62x9t3v7T8SHdmMdB8KAr5KwbCKlERJCeN/VIoM2z73sfcW/Qcv8ZR0rN87+SNTTXvyWEr5swcZVm86d+bQzhybNlT1IUha6D07Rfa+kZlq16dy66Hsbzry0pL634cxLZzxnxHSk60AKKYScfU54r16hI2EJJF3EHCTdOTTsBoF/yfN/Jv7Lsy3vS84bF6rC+QtanAOJybDnTA0uQYA95/OYJX57OMfSrwX8J//oOvbYdPXlECzXNikTvr/LK/ZjmedYN2g6V10rWArpuj1Rq9hxbeO5xQ8Zb/iPH9TFXbjo8k8Wf/C5l72vmLXwSCQ6kwTPKfs37z/XKTYD+akvvrx4R/Qr3/21urg1Jc1oizx494gphSuFmzkdPJItLSTcDIlN12uPOIi7sAUUhiYNywI4pRmv6MCZrbkLth6rBIBrxTXPyLMA2G70/4aaJdBuyFZ9ci4yfU/wzC7odN2Fv/dg2M5+fRR4DfvN6/n3Mz3P6cVdCQ4INm3VgkEGENXROpd1l9XAZ+kl6IYQkKI7YhZ/8jf8xw+H/+ul3TNtC3nDf/xw5cZz60JnmuYvvejyT95+03/P7ABcuenCyz9ZzIdyHGdGF/QcEuFCLuhE8ffh7Z/59XXF9b2FKzfVxe1dufHcqve9nogFwbyvdtlN5Km2zHhq0pMx9RfvAIZUvVQOGAoMDp8yWdG8SUObjlYDrTraDDTpaNLQoMKnAIAj8f4ncf9g6s/y+lcdCYQCJGB8UVx/k3KKjuSjMf+tw+5lC8Qyv2A8r6Fb1BqwlDJqi3/0ZR+cANax3R9T3gdAgqV114a2W25+QL70TvnyF7F/XM2vobCB6TfVkeOcBTi09Kwo8+tRiQgDKRl+ojtyysKiltR9gYarv3rLb7599Y48i8H+YOMbPvyD9Z6vrBqM9B0c7u9MD0NlBmMX5MI3fyIRHb3vz9cWHgGv/uotRX6oWCJBS8CZVlFBb0GkyFzQx2rfG+7rfPyfN1Wr720dSMRsH1cE45JBMgVy2piaHuYZSw24Xv3T9FMqBwc0Ds6gTvzzKZPi6ucIqAiqCE38C6sIa2hQEVQRVBBU4VNgFOE5VRnm+2AKaHxqt5FwZapKelrjsywTS8ASUDlcCSGh8xz15byTVI4rYQs4MnUlQsKnlHlmP7BNrrtOfEmBA+AP/cGTGmOrNalASikZY97PKR+2cC7odO2jf/bK7+yfEg7mACrMnygXbGYPpKa9CO6QW+6XlzwsL94jN8TAGGDA/ZFy8RZ2Z9pBzSGiaHijs/UglumYizDAlqOHEv8BpmhsgcYW6nyBxjo03qaydoU1lD8suo50LGElRSLqxsbeebz/3ScvKOkMe7fd9/g/b9rx0N8SsbH0MLHhzEvPeeV7yxinErGx7n1b9227f7ivc6TvoPfnjDaBP9jYsXJj8/xlHSs3Vj4+7njob3++/r9G+g5OH9bPvex9JX2ux558agYtMYz58+ZEUcKkmbcQocfSxYvnt88rte/d9+dr9229L7Pvnfriy0998eXHZN+78M2fKPZu2+7X7n7e39DkC4Z1f0DVDcbVgMbVyRrrUDj8E7amzmFwyIlfAAQVMJbKlWtwqBwGh8ZT1d4UBrVKJlLExoiNZ8dx9wAeGYKY8F17kqww+BQ06xi10JtMVXFNuBATkswAU2BlEO9YjkUBDFvYNoqHhrE3OkUabYGQijEbhpISZlfCEpCYnGGkXYymmzp5ehLgLVe7EpyhScPyINY34LgQGjV0xvHzTkScMm+IBFQ4rejtxWIObAw5nz3e0ry6C9MWgIsSYK/0wmeeVbZGlMy3sYAv8He/il8/itan5Tn3i5c9ivM75ar0rimvbySBldh7o3p6E4bS2TaiCL/R2XoQy+esACfEns7EBwBbSgkIbyIIxsLKWYt9ny9znu/FPzuWSMZFMurGxk9scH9w6XFHemiOje146G97t923d9t904eeMuhYuWnVxnNWbjx31aZzfeUOiDse+lv3vq3d+7YlY2MLV27sWLlpwxmX+kqpUjc6OrZn777Cx4TDc6gg0sFDXQWebWpqXL1q5THT99aXEleVs+/t23Y/gPL63sjwcF9fX1NTUzgcDgQCPp/P29kyq/qDI/G7Q1jXgA5/Sts0BlvCFrAFABgcugIfh1/BkIVBE0EVEQcHYnhuHLsi6DORcKExvG4J3rF88sxxFw8N4a/deHwYIzYciS3N+Mw6/PoQfn0o9S5tOtaE4eMYsXE4gRErlUbR4NjQgKiLQ/GUz0bnaFSxKIDjQ9jUhHUNWOKfsq36t4fwsa1o0KCXdYMFIDJ8yx9daZ4zj7GMIKxiBdgzf13X7Y65/77DZ2UsPZjAGey+N7Dv3iVf+bg8rxuLHEAHtFxe+wjwOvbLLymXewUlOMQoWt/obO1Bx9yqnpr2FDGM2w8eTl7D2ZRtQkJGG7VLFvk+Jsrdyy+FK21TmAmRjLqxMScy8q+3bQ4bRyidyeN33rTjob/vePhvtXuLU198+fozXrb+jEuPfKsdOtzV1z9Q+JjGxobGhjAJcKqxTj7xiF1MrfueP9i4/sxLj1bf27t3r2VZngAHg0HDMDRNm20CbAn8tRuvWVz+GZIubAkfn+K1zqQ7gZ0RCIkzWuHVefvtIXxrN85vx3tXYUnAG0XRb+JgHP0mGLAsgBMaEHPQk0z5mYMqWnUUKBNnCvz6IH51CAdiCKqVrp4u94tvrLcMTS1HgD3z92/duP5QtrHqQ2wcQRvQZ6rpK4EE8HX+jkv5DQKcQwxhwRudbQNoy7oJnqeiEs9+LSKbaiHAQ9Yf+szvcRacKsCxefq75hmXly/AngvaTLiJiBsbc6Oj15yz6BXrFtT04yRiY/f/+drH77ypKjZHMTTPX3rhmz9x6gWXH8lW27r9WdOaIbB8XmtLwO/D3KCnb6Bw8YnVK1fU2h/g9b37/3xt2mt9TPa9xx9/PBgMznIBPlp0J9Dhr/5pB018azf+1AW/UmmNu4+tss6ex9I7kaZoQWHz17OAnxnP8f4JBDUgmMfqzRJFDfi6+J9OuWYiUCs7hsOViDkIKGg3ypdPzmCJnoTYbQnEHMQcJGbrXjRL9OS6bVzjHRWdd6J10818977Bmmbk3/7w37565YY7fvmVI6a+AEb6Dv722//2lXdu2LvtviNTeGA8EjUtc8YDOZ9DwYacs8J3Y3BoqKaN8vidN3l974ip71Hpe/0DA07R27rmILVQXwBtBr6yEe9bjaSAqMyk+1ufkq+KhvLRT3+ukAYLEbfdX3XrccGmy2rxg40CjMJ/AJsv4TdxiARCvxfvjSPIJzwPPgVvW45r1iHp4tHhkp3vQkLhSLjPH0p+eti6/c1Lzr5iWcML58GvYF+szPlLTYPgR5w/W6J7aipQCaa0aK/R2TwJOBJJAVOk9t7ZErYEY9mfJfsivTyUji0dS9qmsM39/aMvX9teCy90Ijb2q6+/45+//Kpjm0fli5eMjT1x5y+T0dHjT35xzWfZPb2JeGLGw1pbmufOwOe4rpks1PTJpDm/fR6vQdZir+/d/ftvz4W+13nggG3bPp/P7/d7tq9n/jJKBz2Nh4Z23HTwn8NWJOGanDGdawqryE+wpQW2xENDOcKwSzCmLX5ig2gzwKZVCFYLezSFEN0JDNtV8HUEgXvlC34qPnkV/3zm41EHJ4TxufXY3AQAjw5DLe7dhIQl4EioDK0GBq2HDye+ITBmCfnE6Je/tOFrGg9ftggvvQ9DVnZImxcjkOmvZtOmFzqHIyud++S+cti2HJxWC1IwBB3ZGnHAGdoMbGzElmasDOGRIRxKQGV4fAS9SfgnQgG9oPmYk/qdAxCQAlIyRzBXcltwIdjN27red87qqo+AP/rky7r3bTvqX7n7/3JdIjb2+g9dV7u3cF13cGh4xsNUdW4lL9c0bcYvR1//QMfCBdT3yiYej/f29obDYZYBCW0+/tLz0Fe3/UgxGgOK0aSF2o3mZYH2Rf62q1a8bGNjmSGB/34cehL4UzfC5VoxEnhomJ3QIKdvQ1ILmb9SCiEOJ1CtfCYB4Drx6dPZHcexp1wJyTBu40Xt+PIGtBkA8NQIdkdnNn8lkHQRVnFCA05rxsnNuLn7L9fvvw5wOfP5FNzZ/9zrH/nGH8645sEhddiasqgsAVeiWcOIDVtA5/ApkDKVtCWtyl6wvutOmphCphzaXkS7d6R3M1n+60TGDncxIeeOHHflSFaxCQER4E2ntzStb8BJzdjciPkTi4nnTGxs6Urg//bjrz0YswAGg+NrmzBuY/sYDicQcZjlMGEzqTFN57qPBwLcb7J4X2fSWmbo1Yx4u/HLb54NI6DHE3f+0h9svPSqr9bo/L39A8XEFeiaOqfKEeqaOuNtGRwaWlhtAZ5Tfa+rq4tnQDJcmMOJAeghv2IIKQbM0d7k8BOju+CYL24/pWwBZsCn12FvDM+OI6CUeYY1AVsIzjj30oimm08toL7ef/1m1VpaARJQv+D+6LvaqxpU54CJty3Dx9dObus+EMeojWYtpW3pxBRsQnQ9GVMYPrQGF83H8iAYrC/vvPGH+3/FoCssFSkW1oJ/7bn3dY/8YNx8f9RJCbB3Ho0jqOKtyxB1sWvcWzZGbxI9SWgcMQe2gE+BKzFmT+px3EVYxRXLMGKjM4YhC+M2kiK1g9uVuW+6t+9N5dAYfEpqe3urjjG79+eHBjSuqgwc3PPRJR337Pa2G7cU2pm1yI/PrMPly3DPALaPYdTGlha06njDEgCwBUwHts0skzsJPj7OR0f5+LgSjYrO/fvWrFlTxUHH21Mxe7j/L9etO+NlKzecUwvzt6+vv5jABEM35lQuSkVROOOiYIl407T6+vpL3RBMfc/Dtu3Ozk5d19NFZMnzXNAwk53xXoUpDGCMc8Y1QJeaqgWPCy2q5MxhFV/egLc/hriTN0K7AE2qe4Lfcl2Ncy6nTp4KGdVCCCHEsF3N5cMA8Ki9/l/zfvDlJfpeE69YOOXZs9twyQI8NQpLQMqJLGgMroTBceUKL4UF1jfgovmpl3xqx8//e/tPQr4WNtUQDSjBPx7+w2sXtX9xxes7E3AEQioW+LA0gKUBtOipTetRJ5Xa1BLwKehJ4q/d+P1h6Dzl4E0KANjciH8/Dme0TviFHERdjNuIOoi7sARMF+ltWpwhoKS2nBteZhkFPgV+JfWmz0X0Puu0AXO0LzkyZseiTlJKASe+NFDUOLUyiJXBXC5BDkVltmSKy2Ne9WclVQL6wIEDK1as0LTqGMFP3PXLWfj1e+LOX9ZiEOzrH3DcomL5NH3O7aozDD2eSM5gw/X0trW2KEp1/PMP/OW6udP3du3a5boun/gu8zx7SQmPcTvekxxW2ZSe5kp3vt4039dS4cmPD+PTJ+BjW8FLz8CVFCzuiFCuKhozu6CjTjUbOyHwvhV44YrzFxlYP+3ZdgPXnoyeBIZtuDKVJk1jKXv0+HCOtKKvXfTCX3T+szs5GFCy7A8WUH139P/4nSsWvHFp3vq1WbvBFvjw+DDibir0qUHDuS141SJcOH/KTQ+oCKhoN8q8CSeEj7vtnK+bwh4yx7uSA4fiA3uiXTvG9724/eTK7zBjLP2NVVXV+8U0zed27ty4cWNVGnG2mSAeI/0Hq26AWpbV1dNT5ME+w5hrQ55hGPFEYiYXgtPV07tk8aKqvGP3/m1zpO+NjY7u37/f7/dnfpFJgwvNlZMjQ+Z4VtSVI90FvpZmvQpFbl+2EAMm/nc3JCstICsheE8SbT4hhOByykpwIRe0J8Cx6u3kcSVaNJzdhkUFR6qFfiwsOrL8pKbVv9jyiZc/8ClT2Bqf8nEUpiSFfPVDX7nzBa1ntq4vbg6FP3VjoQ8nNOCMVpzTijU1S6tgcK3D39rhbz2teW21zslYuvIVVyfwvrf79+1bMH/+vHnzjtnvn0TVl2D3H+gsclec3++Tck55oL05h17M/enr629taQ74/dT3iufJJ5/0ZtJZX2RS33wcSvRHnYShaFNFRyzxt7PKdrQMW3h8BC9ow9uXY9TG9fsms34We21JZb0QqbXdDHhO9c0QYZEUVWvshIs3LZ0MKaoW57Ztuu7kDzvSdafWCZGA6ZqntRzfZjQVeSqF4Zub8Oez8aNTcOXyGqpv7fC+n2kLOPOr+8QTT9gFMycUycIVG2fhB/dVO6V+d0/veCRa5GZNY+6ZvwA0TWOcF3N/9uzd77rusdr3mtuXVveEzz33XCQSyfwKp7/FlH8j73Q51msLm2VvzBQrgx0VnlkCX3oWr38Y738Kt/YUVYsii+cTGiYiq2YQYGT4n6cJdmXaAMyrzTD1piXnf3H9O+JOIl0OTkgRtWNvWXrR38/+SvEr8EEVJzSgpW5TVHvqm544axN4395kMvnYY49Vnhng7FdcPQs/+9mvuLqamTei0a6e3uLf/Vg272b44EVl/jIt6+DhrsrbZd0ZL5uFN+HkC95U3cwbzz33XNa3mCzgGdkby50bdVVoYYVnDilo1LE7grv60W+Wk1jiubiRECnjNtMOnkHKPcmu5te1ZlslP378m69e9cqoHQNgSzfump9Y+5Ybt3w8pM65kTHzq6vreuYXuLe395mnn56s6V3Wv5Nf9KbZZois3HDOivVnV/i50v/i8fievfuKHzN1TVUVXq13r69/fp+vyLs0ODTU3d1T4dtd8IaPzba+t+70S6rY90ZHRh568MF8c2gS4EICHO2Ba0bsWMSOx9ykKWxbOipXlwUq3QinKwgq0HgqurYMRl3lTwP+XpM/PDzl9bkzYXnxz67r2o7zz2HfmFuFQGjvW/iaxVgaqFUDXDj/lKdG924f2aUrvu+d+IGPHf9GNifrEKcdGK7rOo5j27Zt267ruq4rhBgcHAwEAk1NTZW8xeZzX/3IbTccrTxE092S7/js71S9OkmYXdfds3f/jGmfM2kMh3Vjblb2gqap45FYkY6ySDRq6HogUNGceOnxp269/+bZ0/eu+MQvqtX3bNv+5z//KYRQFEXXdS/7VTAY9Cog6bruyTAJcE7WNyx/0YLTtrScsDq0qEUP+xTNch2FKx9Z8/pWvaGSMzPgll50xYtNEpWT3XHt3mF1noFNTUjPomaIgpZSimppmITOauvdNbj201M/doVw/m3VK1/Zcfbc7IVZLmhd1w3D0HXdsizbth3HYYw9/vjjEli+fHn5tzrY+NEfPf3jT7+i52hHpa7YcM5bPvFzI9hYFUeN67q7du+ZMbI3C/9c9T+n3Fp+XzQWL/Lg/Z0HAbS2lr8tZMGKje//9j03feWKo9731p1+yWs++P1q9b3R0dHHH3vMcRxvxdczfHVd95xYmRYwaW3u5mhYtq5hWfrPpGv1mSOD5tiywPzKTx5UqpCQKuYyy50MsmKM5baA0/aTadu3jwRiogqOYwGEVbx9BYK1LI4XVH1vWXbh2vDSudwRM1cahBCO43jmr+M4E+v6sru7G1JWEhStasaWi9/OGNu//YGj8jF9wcaLr7jmlVd/S9WqE1kQTySe3bnLKsX2BaBr2twpQZj31sXjxR88OjamcCUULN8V5g82zoa+97J3/ne1+t7o6Og999yTSCS88EnP/A0EAp7562WB9oSZgrCKHaC40qSFOvytWTuDy+PuAeyKlFkhOJPlfvfUJskmJlIz5IKWYNXaheRIzPfVcXxTfRnBXiC0N482DMMwDNM0dV13HMdxHM65EOLZZ58dHR097bTTKknQcf4bPnbSi95412++/uRdvzqSw9/ZL7/6rEvfU8XI55HRsQOdB53SI3XDodAc3IA0RQ59PkVRHKeEW3fwcFc8kVi6eFElCTqOmb534MCBZ555xvNOeRsI074rz32laZonzDS4HbVOrlQnGMp0IYRgQnjOjLxrwFII13XjtnvHSCApqzDnSrg4vx3nt1NTHgkBznJmeP4Mbw3Yw9OMSCRy+PDhefPm+XzlL2L5g43rTr/k5PPf5As1jfYfStayNtzCFRte8Op/f80Hv7fmpAuqtfDmuO7h7p5Dh7tEWTra2tJMXkEpZdIsbVE2nkiMjUdCoWAl879673u2bW/fvn379u0ph6SieNLr9/uzzF9Pg8kFfbR4dBhPj1bBAu4w3DOb3cmk3n1JOV19Xdd1bNuyrIGY+akDbZGKXdASMF386FSc1UpNeYQGRM/5bJpmIpGIRqORSGR8fDwajcbj8WQy6YVlpQPi161bt3r16qrkquzZv/25R2/Zv+OBKroHV2w4+4Qtl6zbcklT+5Lq3qhINHqg86Bplbk9OhQMzKkShHknMY5b0q6tKUPSwvkdC6pTsKG++t7AwMDjjz/uee/TyXN0XfekNxwONzQ0hEIhLwIrLcDU2Y4K392D7+/JzpxYBqeErf9aZWqapqgq53yG8zmSOdUIwkq6uKAdZ7RQOx45IzjtzvJ8WV4stLcenF4J9jLpSymfffbZAwcOrFu3btmyZZUbCgtXbPB+37/jgZ7923v3bx8ZONizf3uRBkpz+9Km9iULl29oal+6cMWGFetrEk9nWlZ3T28xdQYLEA4FMbf9zx6qwv0+X6nBax5d3b2Dg8NLFi9qbmqcVX1vxfqz02erLvF4/Jlnnunu7s78tnprRp7b2e/3+/1+L/KZbN/ZQLU20FpCuq6rKAqXEjOuAduSObIKrS4kwlo5+5eJSjTYE2AhhGEYXhBWpiNaSumFZXltHY/HH3/88c7OzrUnnFCtjJXL15+9fKp8JmNjPQe257U2cmltLTI8Vy69AHyGUUxN3DlCOBwsT4C9ydCeffvD4VDHwgXhUOgY7nvxePy5Z5/t7OzM+p5OV1/P85y59YgE+Cjir5IAmy4TwvUWeeWMFrAlpF0NAdY5nhpBzKltCDRRwAjOKcAAMjUYwMDAwMDAQCAQOGHduo6OjmoVUJoUrWBjjSza4oa/RP/AQOXS69HYGKZuljkd8RlGqSvBmUQi0V2RPQG/f377vEr2Kc3Ovjc2Orpnz55M6QWQisRRFC9Y0ot89tZ9fT4fLf0eewLsTqSYTLmOCh8dczmrxjRQ5ehKYHcUJzVRUx5pI9j7eoupZAbuZmmwN09/4vHHt2paR0fH6tWrGxsb6/o+eHVVDx0+7DiuruuKqqqqpqoVTQYNn+Gbk/mfC81IGsLJ/mQlZ0gmE7HIeE9PF4Roamo6BvpePB7v7u7u7OwcGxvLOT/mnKfV14u98sjKvEECfHQxeHUSYpiCyQwKJeKAlCrDh1sP74vzPyUqymfNAFPgqRES4CMtwN4sW1XV9KKvmFqUw/tuexqcJcyebnV2dgYCgY6Ojra2toUdHXX08b2xr7enZ2BgIOcBmq5zrngR4EbqZ7EpNZoawrT6O80I1o3ijGDHcVzHdhzHdVLYlunNAidNxrGxdN9buHBhW10V8vL63sFpupulvumw5/Su35x5r0h9j37fLjcJZRYiI8lVfgt4YmRZrFuOm9BsoSSkW9kMgDM8OYorqSWPuAanHdFyqvcjHQnvObi8bYgiV82seDy+Z8+ePXv2AGibN29eW1tbW9vsHBDj8fjgwMDA4ODgwMCM2SFsywJgJrNXLv2BgBDSy3uQ1mbOFU3XJ5TGMAyD5DeHEdwYTvabAIQQtmVOaK0DIJlMApgutDM2aL30vbGxsbHR0cJ9L/NLl6W+tO9ollvAnEGiUjvYlswS0GdwQU80uc7R7Ro/jc13K7a/NYY9EUSdKkRyE6VqsLd7QUqZWTUv0wnGObcsKytGOmd+icGBgcEJg7KxsbGxsTEYDLa1tWmaduS9hbZtj42NxePxsbGx0dHRsbGxqtRbTMTjAPLZcZxzfyDQ39sNIBgKpV3ZwWAw062d9ecxQCwWcxxn8s9oNJ23JBaNek85jhOLxWp0Afn6nqdeR6XvjY6OJhKJIvtepvSm1329qKu0+gYCAU99yfydVWi8anUFMkdVtUBf8WT4L+Mt/W4V1rpUjgETB+NY10CteaQFGBOO6CxVTo8FyWRSURQvX7QXqJW5UFFoyj/Vw5ZewQoGgwAaGhu9MK6y5dkb5lJvNzrq1ZYYHR0FMDg4eFTupxAiFo2m70AJXwFV9W5LIU+Xz2f4fLX+CGOjo4UPqKmOVs3crHHfi8fjaUO2wr6XOdnNzNOeue6bFflMhY9mFf4quaBdydyJAbXQGrDXaWzwTrs6wwEDYi72REmAj74GZw0H6brf3u/emlxmsLQsui505pg12z7+lEno0Vi+dRxnRsEuSdGP1Y5aXkvNwr6XVtCs75pXYsFT3zRe2HNafcn5PKtQq1RZzwFzxGTHVgt/E6o7AZPA/hg15dHX4KxBwZuPexpsWZZpml7KjnRklgemlpKui8+bXnJLP5i+/nTJisxRXlJc1RFvoCytSj+YVb28Tvteeoknq0BZOuzZ+5nO+UzqOzvxKVA4HIEKm4UBLGOcUQt3IIOjVXWG3eosZTGgJ0FNefQ1GFNd0OnyZ7quJ5NJTdM8X3Q6c9Z0azhLt2ahzZEOLku78tIjWuaAPv3jZA30pM1VMWezxDVTojL75PRm8npd/fa9TA9Tlvp6Jq8X8OwZvuR5nrUoDAqDU7kFLKecRJ3RdFhuWM+b1fFCc4YRm5pyVmhwvkUpXddN0zRN07IsLyzLWxXOsobzSdfRNaQyg7r5NLxn05ea+SlyfqLpHy2fGE//4MewWmdpw3SpyGfaZv2SReY8Kd1MIhf10ve8GGZ1An0CT3fTeHV/Mw1fUt9ZiMahMiQrPo8rmSsKCnAWJ/iSd4xXYdnW+37EXWrKWTFP96qvpJPQZmqwp77eT3uCzIXhdKR01mhYQKUqHB+z7KecI/v0WUUmmUNb5n7o6T9zUrwkF/jUdafKBbQ2S2XzmbY5bdxMrc2aLWUawemq5GlmYd/zPlemr8XrbN4Xygt1zlRfz9Wcdjino52n+2mIWYXKoLKqfKemnnbGFyzXk2HuRESlXmgvo1ZyFgpwJIK//Q1vfCPmUtfPNIUz7WBvmLBt25ogS4OzZDizrkPx7tyyh798JlR6+E4Pf5mRZVk7OtIjeOZHyCnJ5elxzmXmYpT4SCp0gYE+n+4WdiNPX3TPaeBmzZPyOSrS5q/nffF6Xc6+l1OJj3zfy1zrzfQ5e3hym5bhdNSF113J8K0PAebVyA0uSxTgIBdL1eQOq6IM6UkXZ7bipGbcMzD7bu3HPoZIBG960xw3hT13meM43s90AaVMMjU4q8BwgbW6wmZiJWNf1vCXNnbVDNLFzNOBLWm5zRzKp/s5sz6RF4aWmaik8CfNJ8M5P/uRtJVzLs0Waenm8yfna52ciptTtPIJsDONmva9wjb99M+V1fdyqm+aTN31yDwhidysFmAOlUFWnInDArMlwwyZsNJHSwZguZaoUIAdic1NeNsyHJptW1RuvRU/+AHe85657JEG4I2AQghPvbwBzslFekk4Mz4rpyk541BYvAaXMfylyRrs0heTdcHTR/NSLWNMTTJXWJVzyu0RCPjKZ87mPCznz+mClOWJne6WmC66BfQ4Mwgr0wLOFODKZbiYu1SM9GZ6XKb3vemkjyfprS8UBpVVxwIWcnIj8AwC/Mi4sVmNL1TMSr/2QIcfQRUXtB+Nm9fbi4cewnnnoXlq7fTDh/GudwGAoszlvpUeAtIyrCiKEMIrZZg52KXHvqwH0+Ogl8EjyzWdU5nKGwGzBvT0cObNG7yf6aGwwBpwlmlb4GfhXwozo1mcT4OruISZ07AroL7lGbvTpTfnL1lx6Zkm7/QgLI/0DC9fxyvglK5d30ub7EouMhc+sjph1sckYasnF3QNmkst/HV9Omq0BY0wrzz4C0ICwPlHRYCbm/H73+Pf/g2veAVe+Uqccw68zDhXXYWJmthE5ogjpfQGl7QMp8e4zCEva+zLF7Ca5bYt3g1Y2Oqd7sPMNEcy/0y/NlPVppNTVrM8z8WYvwWkd0YNLsNcK6+JC7ujZ1TfAj7nAr7o6VZy1lOZl5HZBPl6XY36XgH1zec8z+x1md0vqwdOD14j6kWAFV79+tCFEnEwxnot5SkeWMYq3f4kgT1RAOBHpeMZBr7/fZx8Mq6/Htdfj2XL8PKXw3Xxj39Qx8rX9N44xTnPMhMLjHcFPIElpdPKKRg5zakCkjw9sDZLgJFrQ3Dlf87ofC4cmVVrC3i6V7l45zPyBzkXUOXp/uqcf2bNDDLv24x9L+diQeV9L1+MfeH17Ol9LzMCnIaXuh0VYfDq1z8r5IIWYJZkd0fCbUqluaA1jidH4MiaWPFF0dSEG2/E+efDttHZie99b+r1adTD8g3EaSXOMgRn9NMWsAjLE2DkWmUs4OHMGuVzzAvzLL4WjnMuHPxcOBC6sBFWI/XNZ+zOKMAl/ZlTR6fHSE+XohkbaDb3velO9SL7HlFn4yGg8eqcSkopIWcWYFMwS7KkYIdFxQLMsDeKPRGsPYqJoM85B5/5DK65JsdTv/0tbBuXXYYzz0QoRL2tsEmUM5NU5niXlbeyPLfq9FF+Rs8npm2DKektCmtzMWo6o3s537vkfKS6LugiE2jMeHMK7wBG/o2z+d63Xvpe4e5Xat8j6g6jSi5oVsACzuzKSVfaojrdiDOM23h4+KgKMIBPfhKPPIK//z378Z4eXHstrr0WK1fi4ovx8pfj5JPR3g76FhU0j6YL0owWYVUmAflco1Uc+GY8YTFKWermotqpbwE7uGzBLumwOu17BXZhoQh/PnEsoVWjhT2/MmYsxiCltATsKg0CQiKk4fjw0b6FioLTT88hwGn27cN11+HPf8YHP4gPfQiGQd2u+OGpsBVYxlBY2Eo7ukNeJVdS/H2okQu68sOo79HXf67hU1KhxJUgAVeyvBYwMgIfLFe4Vfr6JwVeNA9nth7tW3jvvfjKV/I+u349LrwQl1yCLVtwxGvLH2OqTINUVUSO7iH1PWKWoPJqnUnOJMCpeEJRtTeUuHjB0b5/g4O48kokctVjuvBCfO5zOPVU6Dr1M4I49jCFbXCKtSQqsoBrvg1pSq0YUR0BdiXmGTij5Wjfv/e8B3v3pn5vbIQQiERSf553Hs46i3oYQRyTuFK8+ZEv9Zkja8NLlwcWrAp1LA20L/W3t+gNQdVH94coBp1X/5x5XdDpFATVmHvirEa0H91+/sUv4o9/RGsrzj0Xl16Kiy7C7t14yUvgOABtQyKIY5kxO/rI8HNdiYEHhrZDSjDuV3Q/N05qWv3ns75EGkwUZQFXQ4DZ1GQYuYOw0k7oqly3kDi77ajeuV27sG8ffvMbvOAFWDDhCl+yBJ/8JL7wBepYBHFs05scjrnJoOrnLDWISshhezzmJgMKBVoS+RkagmF4e1P91UhYzCF1JjP+zGMCQ0oGWXkkg5Bo0HD60fU/L1+On/4Ur3/9pPp6fOpTOOccALTdiCCOYQ4lBqJOYkoYMxiA40KLKVyLyEsigfe/H6OjVbSAPYUtKMCT1rFQK151tgRWh7A8eFTvY77dRLqOH/8YPh+SSepsBHGssjfa7QiXZVWSk3JlcCHdHCIvH/84/vxnBFPq5Ver/w55BVhCMkjOKhVgW+LMViizdpZ5/PH48pfhutTZCOJYZX+8F9NtCcZWhTro5sxpXBdjY7mf+stf8J3voGEydZS/BjXz8q4BA9CYrDDuWgJ+Bee0ze42+OAHsX8/dUWCOGYFONbDGM8yMAyuL/PPp5sz17nuOmzbhre8BeeeO5mHuLMT7343MKVSrY+j6nHQBV3QTFZoudoCK4NY3zC7G0BVcdxx1A8J4pjEke7BeL/KptgvQsqw6l8cmEf3Z06jKLjqKjzwAC65BJs24f3vx113YWAAV12Fvj4A8PnSK5h+BQpDVWqTzSDAXmCCAqioaCeSLfCi9ppsnyIIgiiGQWtsf6xHQLpSpKvQONKdZzS1G010f+Y6ra343e+g69i/H9//Pi64AJs24Y47Us9qGgKBSQGuWMtk8RYwZ1MCpsujg7bYEQRx9Eg41rqGZYv983SuJl0r4sQjdsyyo616Q0j10/0hcNpp+OIXJ//s7Z38fWgI//iHlz/R3wgolZYEVtiUiKi8cV0MjDGmVibAnOGufrxmMbUwQRBHhxXBBf96wbdH7WhPcqgrMbgn2nUg3rt9bP+WlrV0c4gUH/0o7r4bt96a/fjgIF76Uhx/PC55acPFrwzhzMGQ4bOglhu2qzKZqaqsLzlFYoUQruPYtm2ZZiKZ+O9DLXut8ieJUkIAPzoFp7VQCxMEQRCzlQMHsHEjotEChwy0dtzxwtfe9NoPdS1YUZ4G+5n4wpK+jrCu64au51yezVgirjAKmjG4Ep/ZjvsGMG4j6iDmUDsTBEEQs4zf/jZ3qR4Pzu1Nm+9+8RseOuXiaLCZV6ksg5pHOD0PNNMrfh+DoyeJDzyNeQZsgc+tx3kUeEgQBEHMHv71L3zqUzkSQmgazjoLl1yCiy5Krtv4/WeV7nGEHPByo5MZk6yYNWAPiUozaEhA45BAZwxnt836PcEEQRDEnKK3F1demSrMk8Xxx+Puu71f/UBrHENJ8ApioVVIjRWXipIxxqpUAJEBCsMrOqBS4lWCIAhiliAl3vEOHDgAAB0duPxyfPWrk9mLVTXTWg2qlUZBZ8rrzBawLauzh9dLiXVciFqbIAiCmB24Lr72NWzbhne/G5deirPPRktL6vFPfSolzxmENVReozez/oda+CBHVsdilRIqg0+hBicIgiBmB7aNF74QH/gAwuEpj//Xf+HOO3HXXVmHN1RsAWtMqpDpuiA8p+56PyVgy6q5jCWqMHcgCIIgiOrg8+Hss7PVF4Ci4PrrEQ5nxUU3VFwfkE0tflvIwyzAE1VyQTMGS2DMogYnCIIgZj0rV+Kb38wsxgCgWa/ymxRaAzYFM0WVBBiwBLoT1KoEQRBEPXDVVTAMmGY6JqtyAdbZlCjovAIsgahg1bKAvRPui1GTEgRBEPUAY3jb2zJXfVt08Ip35rKM82frq1cJWEo5YvOdMb2Ka8CcYW+UmpQgCIKoKxmeoFmHzitaBuZsShR0XgNXY+KZuFHFT6EydMaRcKk9CYIgiPqjRYPOKwqEThUYZMyT4bwCHFKqUIswS4D7TFoGJgiCIOqSBg3BygKhs1zKuQRYSiklpDwpUE215AwxB/vj1IgEQRBE/RHW0KDCrcgCFnkFWE6Y1p4CN6tVLl3kSnRSHBZBEARRhxgczXpFAsxRcA1YeuYvIKUMM1erqhcaQBe5oAmCIIj6pN2AqMQCnlpgMPcasCfDBhMGqzR7FQNMkYq94gwjlIuDIAiCqE8W+CpaA1YgkWEEF9rmqzKpVFwNKSlwVitethBJFwAcSS1IEARB1CWL/BW9XJ3qVC6UCUtjUq3MBS0BV+J9q3F8GE+OoDMOjcoREgRBEPVJh78iFUtL6gzbkKpCwsHLFmJ9AwyOlyxA3MUCP7UgQRAEUZcs9MGnlL8MrDOZ9j+z6Zmw0rCJncJl40o06fjgaigMAC6cj4CCExupBQmCIIi6ZJ6BJr18Ac5yKvN80ssYsyWrpB6wJbChEUsCqT/XhPGKDpzWQi1IEARB1CUNGtqN8oOZ9AICnGX1umAC5QuwkGjWJv/0K/jMuuqXcyIIgiCIIwMDlgbK3wrsWcAzREEzxhiYDV5JMQbOMGBOeaRJo+YjCIIg6hLP8F0bLn93kMHlTMUYJp42JatEgDWOvbFsDSYIgiCIesR0cWsv2gyo5QpjVibpQlHQplDcClzQKkN/Eg8PUasRBEEQdU9QxX0D+NJzMJTyLeAJO3embUgRt9JNu4zhlh5qNYIgCOJY4LgwBszyDVNl6itzV0Py/o+6le4S9nE8NoLno9RqBEEQRN2zxA+jAmH09gEXlYoyUrEAc4aIg1vJCCYIgiDqnzYDOi8/CEtjxa0BS8gxtwp5snSOuwdgCQDYNoqDVA+YIAiCqE8aNGgs7SYuXYAzqiHlzYTlVSQcd5XKL1fn2B/D7ggA3N6P58apBQmCIIi6xK9Aq8ACzkxFmW0Bywm83yPVsIAZkHCxYxwAnh7F1jFqQYIgCKIuUVn5AswyEnF4MqwWsIBjbnVKF0lgfwwAPrsOoza1IEEQBDHn4ExmBXDlLUfoCBkX1amVxICYAwCrQ9QEBEEQxJy0niEVFMyElfZCWwKmqFrxXj5xpt4kbEENQRAEQdQfroQjy9wHrDBZxD5gwBPgSkohZbEiiN4krtmOH++fFGOCIAiCqCNsAbvcIkUqpMaBwsUYvAVgWzIH1ZHKgIJ7B3DFo/jJfpwQzk4FQhAEQRB1QdytqBRSOhf0DEFYouyNTtPgDI+PgDE062gzqAUJgiCIuiTmwJVl+nFVSIVPpsHK3gecuQ2JVU+AAegcGoOQSNICMEEQBFGfRBzYFVjASjGZsKSUOpcqZHUvXQBDVJ2QIAiCqE9GbbjlrgFrTHLGUHgN2MOA8PPqm6tdCWpBgiAIoi4ZsSpKgwWAgRWygKWUkFJhsolXOWsGZ5QLmiAIgqhXhq3yX6uxDJu2cD1gKeUKPVndS1cYepLlh5ARBEEQxNG1gMvex5NKBF1MOcJOS99pBqpsAQPjDqIONSJBEARRf4zbYOUqcFYtwkICfM9YsNP2VfG6GWAKMEDn1IgEQRBEHQpwBfkxjKmlkFAgF3S3pVb3uk2B01rwnpXwK9SIBEEQRJ0hJCJO+ckcdZ4qhTSDBexIjLlVNlRtgaUBnNNGjUgQBEHUH6aA5VayBpwKwmITm5GmqWyqECGvVimkSaln6EtSCxIEQRB1iSVgygpc0FxmpsGaYgHLidRXUsqIi6oLMABKAk0QBEHMTYzCQVjpVJT9Fhc12CxEdZAIgiCIOSrAXLKMPUh5BXhXTK36e0tQ+BVBEAQxZy1gUcgCTmvwuoDJUX0TmAxggiAIok7ROXRWaSpK5MwFnTZ/hRBrfcmT/LHqXjoHBi1qQYIgCKIu8SkIqSi7RoLOUcgFjYlE0FLKswNjVZ877BzHH7twiNJBEwRBEPUGA9oNlB0gNVMmrIxA6BVaorrFGDiDK/GxrfjRfmpHgiAIov5YFixTgBlg8MlXssLFGDQmFylVrh3IGRSG40PUiARBEET9sb4R5e3QZZDatFSUhU7Vxs3qXroEdI5VJMAEQRBEHbK5ES1GOTX9OIPBU7ZvnmpI3hOMMcY4502KW2UBlggoWOCjRiQIgiDqjwU+nNyEZOnaqEEqhdeA2YT0eui8yjuRBBBS0ahRIxIEQRB1yasXl1ORUGVSRX4XdDo9dFqDyy97mE+AJcIqgiq1IEEQBFGXnNuGLc2IlVjYXmVS5QwFqiGl1VdRFK4oglU5c5UAgmrKD04QBEEQdYfC8KE18CulrQSrEOpEEFbuakgsDRjnPCGrLMBSkvlLEARB1DcnNuE/1iDhlpAVS2VS4VPUFtNd0GCMc+75oKOiymopAR+ZvwRBEESd85ZleN1iRIt2RKtM8kypBZDTBZ3+ZazqAiypHgNBEARxLPCJtTizFWZxqSl1Jj3vcuaDOQzStD6PudVXS5UKMhAEQRD1T0DFBfNgFy3A0x/M7RFmjFmS10KAJTUaQRAEUf+MO/jdYejFratqTEw6n3Mn4sg8tctjgvzFeaYRyZi9/WG6DwRBEHMT08VntuH5WLECbHgWcOFqSCmBkXLEZpYkf3GeW3/PnxK/+Frit9+R48N0NwiCIOYUIxY+8DRu60OwaCt1eiLo3AIspQQwaFO8cm6cPc9YD93KAmF72/2xn3zOee4xuicEQRBzxQATuGYH7upHqJQwZS+z5AzFGDz1lVIO2eR/zuUbiI0n/34DpADnzAjIsaH4b/43ecvPpJmgm0MQBHHM053AA4NoKHGTkMGmBGvlKEeYVt/aCXC9O7XN224SA11M01N/qxpTVOvBv8d/8jn30G7qmgRBEMc2SwM4qbnY3UcZAjwl33NuC9iTX0g56lRfKxmDJer4vtvP3Gc9fQ8z/Fmfihl+t+eAjEWoaxIEQRzbKAwnNZVckVBjOcQv9xqwhIy6NVkDTtatAIvhvuRtNzFFnV6jQpoJ4wWXqWtPoa5JEARxzLMiWLI31yi8BiwnACCkTIiaCHCduqClmUj+9ccyMgIl2/EvraSy7Hj9vFdTpyQIgpgLtBnQeWlpLfTio6BdIV1KmZFp/g71ul17c8wfhMsMv+9lVzLNoLtEEAQxF2hUoXHIUlRSm8iEVWgfcKYdTKRROlYEr/ycunK9TMYhRIb5axrnv07pWEG3iCAIYo4Q8gS4JAuYZ6svCkRB0y3O9hUsWOp/6yeMC14PBtgmwKSZUNeeqp/xUro5BEEQcwefAl+JAlxUIg5PehWWvWmJAMAU1XjRa/1XfJzPXypjY6yh2feyt0+PySIIgiCObQEOqKW5oL1EHCkpmVCNHHuJPQu4QXGA6q9rHgOWtbp8nXLlZ5P/uFFdvo43t1NfJAiCmFP4FQQVFG+kMkDNZQGr081fj3bFrr76SviOiQSXzBfwX3Y19UKCIIg5iMLQZsAdL0GAvSAslq8YQ3oB2Pu52kjW4roNSnBJEARB1DnLAiXk4mBM6rnWKnnGEZPPS6BRcfzMrbIFDARIgAmCIIg6Z0tLCWktOKAWFuBMGWaM/W28xZLV9xc3atRwBEEQRB3z5Ag2NeEF85AszkrVIJQZ14DTTzPAkcytQd6qNspXQRAEQdQzf+xCTxI+Dl6cSHIGZcK4zSvAaRlmjPEabK5RGeb7qO0IgiCIOiak4p99aNRgFLcbWGNSnZoJK0c5wpoiJHwKOkiACYIgiHomrMKvlJAOmkFyluFjzleOkNUsrYQr0apjoZ/ajiAIgqhjFvpLW6DVmFSKCcJKU/WMGbbEqhDCKrUdQRAEUccsC0BXSlBJDnjWcqFc0MjIxZEu3VBFC/i0Zmo4giAIou4FuFkrYR+wyoTCGUMR5QgnXlBNARYSDRpeSHkbCYIgiDqn1cDyIOyic1Hykh6vej2kuIuzWrEySA1HEARB1DcM2NgIp2iV1DM3AReoB4ypGaGrZf4aHO9YTq1GEARBHAuc1JQ7uVVuS5elpHeGNeBaYAm8dTlObKImIwiCII4F1jWgRS92GThfed+aC7AEVI5LF+LpUYzb1GoEQRBE3TPfh5WhYpeBWZ4tvjUXYAaYLnqTSLr4Zz+1GkEQBFH3lLQMrHN5dCxgj54kTm/FP3rwpy5qOIIgCKLuWRcuNhe0kmsT8BESYAmMWGDASc3Vz+9BEARBEEeelSEEFIgiVC0ttGxqSYYjJMCH4gDgSJzQQK1GEARB1D3tBho0FLMKbHAxPRH0ERJgv4IHh/DLg3h2DCtoKzBBEARR/4Q1NGpFWcAyT+ro2gqwlOAMn1qLBg3/9iTWNsDg1GoEQRBEfTNqwxbwF12OMOfjta2NIIAAx8ULcM483N6Hyzqo1QiCIIi6554B7BxHjvzOudCZQK4grNoKsAT8CiSw0Ie3LaMmIwiCII4FehL46QE069CKcOtKsKOwD5gBpoAlqLEIgiCIY4fDCUjAEkVZwAo7GvuAOTBuoydJjUUQBEEcO3QloBXnfwbgOyoCzBgSLh4aosYiCIIgjhFiDvqTUIouxiAnNfHIFmPQOf7WjbhDTUYQBEEcCwxbGLaLTYNVgCMhwM9H8ZvD1GQEQRDEsUBfEnGnBAHWuGSMHZ1UlD4FP9mfSoZFEARBEHVNd7LY8KuUIcqOXjEGlWHQxP/splYjCIIg6p5D8dLqGsg8Rx+hxFRBFbf34U4qR0gQBEHUuwWcAKvGefIKsCmrqc3etf5oH+0JJgiCIOqbHrOEEGhMDX4uqhhD1esG+hVsG8P9g9R2BEEQRL2ScDGYLC0EmpVqAdcCKXFrLzUfQRAEUa+M2RixS7OAfVwcfQHWObaNIUp7ggmCIIj6ZMBEzCl5E/BRyAWdhcIwZKI7QS1IEARB1KsAm6LGQVi1gDEkBfpNakGCIAiiLulOwC0rSGp6Lg5+hC9dSjiSWpAgCIKoS6pYXuiICzC1HkEQBFG39Jlg1VgAPqICzABbQAA+Ti1IEARB1CX9SShVOpV6xC46IXBWK96xHOsbqQUJgiCI+iPhYqQadZCOtAC7Aq9djDNbqQUJgiCIuiTiYMwqbRNwAY6QO1gCKkdYpeYjCIIg6pURC3EXVdLfI7gGLAFBIVgEQRBE3TJowhIlB2EdZQFmgCvw5Ag1H0EQBFG3AmzBLj0Lx9HPBa1x3NpLeSgJgiCIeqU/Wc5mWvfo1gMGoHPsj+GeAWpBgiAIoi4ZKCuTYzJPed8jnYryT13UggRBEERdMmRVLQLrSAuwT8ETI9gxTo1IEARB1KUAK9VT4CMqwByIu7iZjGCCIAii3rAERquXhQNHPhe0xvHUCO1HIgiCIOqMmIuYU45qBrk7KwRYSDTr1ZxBEARBEMQRIGoj5pSjXyEuZoUAOxIrgtSOBEEQRJ0xZsMUJb+KA4E8Apw3OaTORFWuWAIJFwqDylLBY2dTOmiCIAiiDgXYEtBLtFtVJvxclmYBV6XckpAIqbhkAdY3wK/Alrh0Ic5uo3YkCIIgSsQ2nb1bj+L7j9pwSk+DpTGpMVmaBVyVMCkXMDi+vBEqQ1cCUQdrw7QATBAEQZSM+eAt5m2/0E6/yHfhm1kgfOQvYMQqRxk1SLVUAa4KHIg6GDLR4cfSAPUfgiAIoixz7tBu694/MSNgP3ane2iP76VvVVdtPPIWcBmoTKhMslwFHGobhMUAWyBC+Z8JgiCIcpFmIvnX/5OOBUVhvoAY6Erc9HXzzt/AsY/kZYxa5QkwFMYATNfgGgswgyUwblP/IQiCIMrEvPM3bvdephkpZdF0gJn/+kPshi+5XfuO2GWMOeXkoVQgOU+pL5uqxPmDsFgVVoEZYMsyzXaCIAiCcHY+YT1yOzOmrmJyzgy/u2+7GOk7YlcSKSsNlsokm2KXspktYINVJ1uVlOhNUhciCIIgSleQyEjy1p8xxjDNfyvNhH7mJdqGM4+cAJdlAUuAeR/gCLugvfc+GKdeRBAEQZSIbSX/foMY7oOqZSuLbfKFy40L33jErsUSiLvlWMB6pjU7VYN5AeGsCirDzggo9zNBEARREu5gt/P809NtXwjBFM3/sncw35FLrJgUSLrlWMCpEGhWnAXsHaRWyQWtc+wcx74o9SWCIAiiBJSFywNv/7SyeLVMxiAnkzNKK6mf+wpl+QlH8mJMF0kXrKp5LHhRVnMlb8AQc/GjfbAFdSeCIAiiFA1eclzg7Z/Wz3klhAvbApi0kurK9ca5lx3hKzEFkqLMVVuWR7fzu6Cr5zVmwJ4obHJDEwRBEKUqiO7zveQt/jd9hLXMl/Fx5gsal14JVT3Cl5FwyzYj81rNaj65VqsUniUkdI5PnICAQh2JIAiCKAd1zUnBjhXJv/9UWb5OaV9y5C8g7sCV5QRhsfxGcN5JhFGlakhJgXevxKnN1H8IgiCICkzhUJP/DR8+Wu+ecCHK2jhkTdkGXNw+4Ko4jG2BVUFcuZx6DkEQBFHHJFy4ZZml6c3DJewD9lUjCEvlOJTA33uo7QiCIIg6JingSpQXBF1sENZkjsoqpaJMuNg6Rm1HEARB1LMAu9VPaJHXAtaqtNtJYVQNiSAIgqhvzHLDoizJXFm0ADPGGGNalfYBs4kSTrQLiSAIgqhT4mVbkhIyz77evBZwVTJhCYmwijNaIYH9Mdw/SI1IEARB1B9uuZLogHkpLKfLcAEXdBUE2JHo8ON1iwFgTxR/6ko9nrBhudSgBEEQRJ1YwOVqliuZyJDTTBmeIsCZkVo6r4IAS0DnmGeAAftj2DEOVyLpYDiBqAWT1oYJgiCIY9oCdics4OnkTcShVemibQlHQmd4PoK+JAYtuCaiFiTAAZVD4dSyBEEQxDEqwBIizzJw3lSUOq+Cj5gDURu2AAd2R5AU2DqMdiklh8KZyqE5COrUsgRBEMSspmwXtCOZI4veB5wuR1j5RiTOEHFgCeyMoDMOzvDMgBy3kHRgOrBc2AKCqiQRBEEQx6rpDOaIEqOgNVaFQGgOJF0MWvhTN+IC8zW0AeMmLBeOkEJCSoBRAxEEQRDHqADL7HTQafKvATOpQtqVyaMX1PWtXXhmDCEFSYFDkp09H/N8UDk0BQorp7gEQRAEQdQFEswT4OnLwHnXgDUmFSYrT5/BgAeGoDG4Eu1+fGA9mlRqEYIgCGKOCDBsARQZhOWtAescSpWyVxkcACwXZ7WS+hIEQRBzi0kX9FQZ5lm6m94KrDLorJrxUQxYGqCGIAiCIOYWtigiCjqtvowxhUNnVc7f3EQ7jgiCIIg5RlIwCVlCKkoGGLxqFrAEFAY/5dwgCIIg6pBK7NFkkfuAPfOXgTHGfNV1QTOoFPBMEARB1CGVlOg1XZY2f/Pmgs7CqLYLmioSEgRBEPWIX6lAgCcsYE990xrMcxiqE3ZwgFe5YhEJMEEQBFGPVOLATYiiyxF6HmgAfl5NFzRn8NEaMEEQBFGHBCqxgAXPWYwhfxAWY8EqBmFJaAwhjRqRIAiCqD/0CgxIs/ggLEzsRwrwKu8D1igIiyAIgqhHC7iCLFLmhAta5kvEgYlSSOmMHEGlagLMGWIuto9TIxIEQRD1RyVBWEnJSnBBpyxgVuVKgb85hCGL2pEgCIKoPwHm5YYSm2JSaovahsQYC1XPAk64OKUZr1qEq59Ad4KakiAIgqgnggrUcpeBLcmElEVVQ0onpPQr0Ji0ZaUrt45Ei44vrse4jT1RRBxqSoIgCKKeCGlQOaRM79UtAVsyN1dFwrwuaMaYzoSGKhjBposrlmF5EHf147QWHB+mpiQIgiDqSoDV8pM5WpI5uZzXPJ/5yxjTOdSKk2FJQOU4sQkAHhrGQh+1I0EQBFFnBBQYvMw1YI5UDPQMApw2fwFwVoVtQwwQEuM2AKwIYomf2pEgCIKoPwEOqhBlKXCAuTrP8cq8O5sYq9qmXVdixzhePB+fXQeX0lESBEEQ9UZQRUgtc1G2QXExkQV65ijo9FbgqoiwxvHgEAD4FYRUakeCIAiizlAYmrQyLeCGqYUVchdjyErE4YIJVEGCdY7nxvHzTtiCGpEgCIKoS1r1cgVYcZCrGINawAJ2JHNQnWVgjeNrO/H7w1gexPtWYQ0FQhMEQRB1xTyjzCCsJiV3acH8iTjAJGOiSku2lsD57RASN3Xid4epHQmCIIg6Y2G5QcQN3EGuyKpCS7J2lSxgALbAyxZiVQiveZDisAiCIIg6FGAflLIkMaS4jCnIiK8qSoCFrIIAS8CvoMOP1SH811okXGpHgiAIov4E2KdASPBShFGBDCsCSBVzyLSDCwlwUrCqGKuuxDwDSwMA8OpFGLWpHQmCIIg6Y56BBrVkCfMxEeIyHeCcSaHc0gnBq3LRjsBiPxo1APApWEDJsAiCIIh6o1lHmwGnRMPUz12/IjM3GR1RAbYl1jdQ2xEEQRB1jMKw2F9yGFOQuXqGlmZqcG6JlVJKyJhbnQgsneNwAn/uxp4otSBBEARRr6wMlbwVOKy4LINiLeCIWx0L2MdxWx++vRuC4p8JgiCIuuW4EErVxQbu5lTfbAHOTFMppayWAEsgoGDURneSmo8gCIKoV1YFSy7J0KA4yEgxmanEOSQ2LcPRKgkwAAYkXdzSQ81HEARB1CuLA2j3lRaH1eC5oFFKFHQVLWAPjWNfDA6lgyYIgiDqE7+C1aHSBLhRERP6y1DkGrAEoqKaAqwwDJsYc6gFCYIgiHplU2NpLmgvCCvnU3ld0EkX8aoKMAdiLiKUhYMgCIKoW5YHSsiExSHDXLCp5BXgdBBWQrBkVQWYMdiC0mARBEEQdUxAhcKKLYtkMBFUcqfBKmQBR51qCzBgCgxb1HwEQRBEvdKbhC2KrVMU4MKXJw0WCiTiiLis6vFSrkQf7UQiCIIg6pN9MfzyIPSijVM/c408abCQVYxBTgBgzOa1uPrdlAyLIAiCqDdu78NP9+NgHBEHBi/WBR3iLs+TBquQBTzmVl+ADY7HhmHSTiSCIAiirrilBw8NIe5CL1p9AYTzp8FCvjVgSDnmVF+ANY79MVy3t+RqEgRBEARxFFkRhE+BUmKFhLDi5kuDlUuAJ6KgayHAAHSOXx/EkEmtSRAEQdQNq0MoozxRgTRYmJ4LGhOlkMbdmgiwBPylTyIIgiAI4iiyNAC/glK9t41eFg5PfQusAU+qr7cNqTYC7Eo06WjUqDUJgiCIumG+D2Gt9FqEXKT9zzNYwGlsIaubhzKNI7AiCI1TaxIEQRB1Q5OGFh1uiQIcVETm0u8M9YA98zfhsoSoiZtYAJsaqSkJgiCIekLnaDNKE2CVybAi0ro7cz1g75eEYFYNLGCvMPDJzdSUBEEQRJ3RXqIFbDDh47IEF7RnAcddWLL6FrAtsNiPNSFqR4IgCKLOaDNKO97PXE+AS6uGFHNZLXbq2gLrG+FTqB0JgiCIY1yAA0zoHKyYTFiZeSijTm0WgCU20gIwQRAEUYc066VtBQ5MpMHKd0BuCzjuVl+AhUSDhvUN1IgEQRBE/dFQSiFCACHuFlgAnibAngUsZS1CoJMCZ7dhcxM1IkEQBFF/hNTS9tCGeKE8lHksYNTKAj6hAZQCiyAIgqhHgipUls7XXIQAe5uAUUQQVjoTFoBaWMAMWGBQCxIEQRB1Sal5lFNpsBibzEaZU4Az1VdKadUmC0dApRYkCIIg6hJDKaESMICw4haIwEK+fcC12AQMlJxFkyDmArYUn3tux7ORcboVBDGbURnUUgQ4qMgCeSiRLxe0WRsLeNSmFiSIbH5yYP/nn3rynH/985u7d9lC0A0hiFktwMUpMAMC3EX+PJSYnorSw63BpUugJ0ktSBBTOJxIfGb7duj6iGV/9KknXnjPv+4dHKDbQhCzEIYS4og1JgIF81BiehDWpFpWG86wL0otSBBT+PiObYPxGDgH59C0hwb6X/ivO39xsJPuDEHMNnRewhqwzqRfkeUk4qjFpWsMe2IYSCBmwSE3G0EAt/b23rR/H9SM6ETOW3y+LS0tdHMIoq7xMdfLQ5mynossxlCjq1E5ehK4vw+DUQzEYLvUQMScZsS2Prz1ae+rOfmo6351w6Y1oTDdH4KocwEWOk9Jb1GZsGqnvgAYYEvsHpO9UWm74JSSg5jb3HDgwK6BPvCM76Bjv3BhxzuXr6CbQxD1jp8LXtD/jHxR0LXTYUdgcSOWNELh1EDEnObypUs/deLJfs7hON7816dp3950Imc0OSWI+hdgJjC1DlJR25CklDqrySKtI9AYYosaGY0wBNFu+L60fuN9L7rgwoUdcBxY5ofXrD2pqYnuDEEcAwR5ap21QCB07txUOquVDUwrvwSRySlNzbed+8Lv791zc9fhTxx/At0Qgjg2CPBUIugCx6jTzV8ABqtVmHLEoXYhiCkw4P2rVr9/1Wq6FQRx7FjAygyJoJFvDTjAayLADBi1qF0IgiCIY12AvUoMBckWYO8FNRJghaHfpHYhCIIg6g9LwBTFJsPyZLScKOgQr8larcrQl0SEMkITBEEQ9YYsZYtQYMICzgyEnlmAGWONak0EWOEYMHEwQe1IEARBHMv4OFh5+4AbuMtrsBmYAXEXT41Q0xAEQRB1hiVgFZdFigN+RaZt2qIEOC3Xjarw12YZWGW4ow825YImCIIg6oriXdAqEz4myrGAGWNBLlao8Vp8AIWhM444bQcmCIIg6gpHwilOgVVIY6ZKDFMEOPNQxtirQv1naIMqqmmruhJRB29eikaNmpIgCIKoKwEWcIqLgtaZ1GaqxICcLmiPNtV+tf/wicpgVcx2UyDigAHvX413Uqp5giAIot5wZfHFgIXG5Iz7gNXcAsxTzONmhdkjXQlH4vgwzmjBJQuxroEakSAIgqg/ki7c4hTY4CJtAc8swJnlGhjjjPN/xVtO4MOj8FWoviEVnzoBF7RDo/JHBEEQRN0iULwFLDFFVVkRxRgmTF9FUR5ONNzuNruV7UVKunhxO16ygBqOIAiCqG8SLlwJpYhF4HQ9hWKjoDMXgBXO1/isqFASUqnkchWGIUr+TBAEQcwlfEzOWAoJOYOwPCO4w6hC3SKdY9sYdoxRcxAEQRD1TdyBU9zGICOzEkORUdAZdjCfp1VhAxJniDjYHaWGIwiCIOqb4pdkfZ4LuqREHJPFC4EmrWo7gAeoAhJBEARR51gCAkXtAzb4zHuQsgVYSgmZ0niDCZVVIR00Z9hGLmiCIAii/gVYFrkNiUnMFIGFnKkoPRnWILRqCLDB8eQIuqgCEkEQBFHPsKKP9BVRizCvAEtIFUKpRkEkhWHYwg0HqO0IgiCIOibmlrIPuAwLWE4Y2AorQe0LE1Dwm0P4ew81H0EQBFGviKJt0iLXgNWcj04sBlenJDBj4MA127E3ivPacTiOc+chrFJrEgRBEMcgBpu5GDByuqA9XAlZNRsYKoMEfrAPb3oYPz2AIKkvQRAEcYyiccxYDBg59wF7P23JXMmqeEGcIaBASCzwgdJCEwRBEPVF8S7oIkOYs1NRTr4T425tPkOIzF+CIAii3ogXJ4oM0LjMMmuLsoDTR9uSOVW1gD0k4FeoHQmCIIg6o0gDmAFqESHQyLcGzMAsyQVYLT4Do2YkCIIg6g1fcaunnMl0MeAyg7ASgoSSIAiCIFLoRQowpFLqGvA0Aa5VpJQrqR0JgiCII8a+qpyleBe0xmT5LmgJGXFr5X9OCuoNBEEQxJHhBuD6IynAHFAn9hOVLMBeMqyYWxMLmDGYLnUIgiAI4ghwAPgg4KvKufxKUTFMnEmG0l3QMqPQQ6RGAgzESIAJgiCImuMA7wQigL8qp9NYkYdJhTOWYQTPXIzBU9/0zxpZwByIOdQtCIIgiFpzDXCXp29VOZ1PAWcln6u0fcCeBkdFrVzQcRc2LQMTBEEQNeRW4KvVPaOhgBdhBKsTUdDlrAHX1AJmQNKlOCyCIAiieCzAKuX4Q8C7Mgzf6ljAAQVqEQKsMKkwVkxBwRzlCKWUrkSsZhZw0qU4LIIgCKJ4ksC/AZ8DthVxsAtcBXRPMUqrJ8Cyejtpcwdh2QLJ2iTi4IApYJIFTBAEQRRLA/B24PPAycCZwFcKKvGXgdumPhKqykWEVGhVtUxzrwEnXFiyVok4bEEuaIIgCKIkzgW+BTjAw8AngVOAM4GvAs9NPexO4As1ugKfAr+CGeVLYxmZsEpKRekZwaZktqxVKkoBckETBEEQpfJh4KVpUw54GPgEcBLwAuBbwB7gIHAlUCuBCSoIqjMXJeQAZ0UJaG4L2HTh1EaAGYOQ5IImCIIgShYQ4IfAgqkPmsB9wEeAzcCZwMHavb1PQaNWdFXgmSoxIGsfsAcAU6B2EilB25AIgiCIMlgCfDfPU/GpgVeZVK0IbpteTXHMYwHL2pZCokJLBEEQRFm8Fri6xJeMVOu95xlFW8DlCTBqaaFKCc5gKNSHCIIgiPL4OrC+lOO/AFwAXFt5WaSO4pJasnLWgD0XtJRmLYsBc8BHAkwQBEGUSRj4MaAXfXwMuAt4H7AZuBi4rmwlXhKAUj15zOWChpSyVjV7JWBwhEiACYIgiPI5A/h86a+KArcD751Q4muBAyW9fpEfPqVqXujc25BUVisBFhJhDWGNeg9BEARRCR8HLiz3tZ4Svw/YBFwE/M+0/cS5WeBDs1YDAc60etcYZoti1+KGuRLzdIRU6joEQRBEJYwBQxWfJALcD9wB7C4mZXSThkV+OEUIcDHLwDxTfdM//VxsMqK1uGGOxPIgRUETBEEQFfJ+4MkKXr4ceCdwM9AJ3Aq8ssgNOqtDRQlwMeQ1RU/1jd8db67FPdvUSP2GIAiCqIQfAL8o64XrgYuAlwKnAw1lvH5dQ9U+g5rPZF6qJV/tP3xLcmFSVi1iSkg0aji1hboOQRAEUTZPAR8p5XjfRNTVS4BTSgmfzi3AQRVSglXsy+XT1Zcx5uXQ2qBF3Kpm5DAFNjRiRZB6D0EQBFEe48DbgVgpL/ke8DDweeDMCtUXwPIgOnyw83uhixdmPl19GRjnnHO+zw3ZqGZNJJ1jbxT3DlAHIgiCIMrjP4CtJb5kSRXf3q9gc1OhdFWuLHYfEc8SbsZYSn457xb+6t42hWHYwn88g10R6kMEQRBEqdwA/CTPUyuBlXmeqvKmnjMKLqRakhXpPOZ5xJcritLn+qp+83SOcRu391E3IgiCIEpiB/Dv0x5cC7wP+DuwFbgNaD4C13FqC9oMuHns3OIXbtV8BjDjfETUJF+GwtCVoJ5EEARBFE8cuBwY92QE2AS8BLgEOA0wJo5ZDfw/4K3TXhuq7qUs8OH4MB4agr+yGOUcAswY44ybTIuKmuTLkKj0ogmCIIi5hA28B9gGnAu8DLgY2JSnmNAVwB3AzwsoXVXo8Oe1gG3JXIliMjqrmeorpUxbwXHBTclrdC8DJMAEQRBEsXQCpwCfAdYUcfD/Ax4C9ky1+6rMwvwrtALF1gzmOS1gAJbkVs2qAquUCosgCIIoltXAh4pTXwDNwPVAbe285cG8e4QkIFFGOcIMJU7KmhVkqMVshCAIgiBSnAd8sqZvsDSQtyySJXmRuSpzC7CU0hZkpRIEQRB1ymeAc2pn9C3xo1XP62ousqQvz3qNB1AozQdBEARBzG404McT2Z79VT97g4ZlwdzpOFwJS1TggpZSWoLajyAIgqhfjge+CaDy9JM52dCYuyySBBPFrQGrObRXSnj/CIIgCKKOuQq4a2L3cJU5uQkay2kBM0syTLiTSxFgT4IhlVpGSiVc6hYEQRDEEeA7RW8LKtkCnmdgxM7e1yOR4ZouqMHZa8Dp3zVWQx+0Q9Y1QRAEcSSYB8yvxXlbdGxqgjXNnpRFB1HxLPVN/6xdDDQjC5ggCIKof86bl9u4tmW5QVieBvtqtg2YMZgkwARBEESdc24bFvhy+HRNwWQRy7h5k00qEDVKRMmAJAkwQRAEUee0GTi3LYeimYKhiN3AeUVWY1KpjRHMgCTtcSIIgiDqn1ctgsGzrV1TlrcNaQKdQ4Wwa5BOkzEkXEgJRrm2CIIojr4kdkUwYsMW2NyE40J0S4hZwUlNOKMV9w9OqfKXdFk6oKqAHazmEkgGQOdSLcqJXQ6mC0fm3kFFEMcqEmCABPqTcCRadfhmmt9GHPQnscg/85GzFktAAkbRC1qjNvZEsTKIlozcCTd24gd7MWbDlXAk5hv46kacO6/km08QtTApt2hD98qWzC6WnGoBSylZLoszrwWsManVzAVtSVgCGqe2I441Ei62j+HUlinDvQQOxtDhh8Lw8W24bxAMaNHx2XU4rSXvqYYtvOtx7InihAZ8bh0W+eHIKbJUAFvgvkEs8uP48AxHJl1YApxh0MTuCJ4ew+E4PnBcFUzM58bx0wPYFYGQaDVw9Uqc0Zr7yKiD+waxYww7I9gVweoQ/u+0yWf/1Y+v7wRnkxZGxMGHnsEX1uNlCwtdwIiFbz+PvVFoHN/chDaDuidREzqcgY2K3Ie2TAsYRawBq1mGb/qnCmnUZiswZ7AELIEgtRtRLv0mbunBkIWFPqwJY3kALTokcCCGGw7gtUuwuXHy4K2j6E3iogVVe3chwXPZU3f04Qd70ZXA786CztBvoi+JPVHcPYBXduBNS3HDAfypCwEVDNgVwXf34MYted/lG7uwfQwKw1Mj+P1hvGcV2nQAeGoUGseGhkn1enwYwzZOa8aSQEqf/uNp3DOAFh2vX4I3LMGi/KlwbYnb+/D0KAZMAFjsxwvmYV7FWvWPXnx2B0Zs+DjiDt67Gic25T34UBz/+TQcCY1DSGxpwW298CtwJJ4dx28OQeFTHGY6hy3wiW0YNPHmpXmn8pyhJ4Gto/jUumInLgRRBk0aLlH2f9dtTZu5CcmLqcegTjWlJ/s450yvmQVsCyr2cCwzbsPgMGrmNe2M4x2PYW80ZRIZHK0GWnVI4HAcfSYu7Zhy/OoQPrUdPUm8bXl1LmDQwoEYTmyCzlOm6iPDuKkTDw/BUOBTcPUTiDqI2DAFXAkAAya6k7i5C0EVCgOAsIrtY9gxjvUNOd7iD4dxcxdCKjY14qqVOLstJfwf34obO3F8A/58NhpUAAipOKUF1+3FF57Fm5bgA6shJfbG4FdgCvxwH/7UhZcswGsW57aGwypeuxiv6IDCUheWxZCFBwYhgQU+bGhAMI/XTAJxBwkXrsSfunHdXgiZukKbQ+eFvOhLAlgWxKE4fAoYcEcfbumBwiABR0ACnMHMNXX49SFcsjDvdKFRww9OQU8Si2dKxT9soTOOzhgOJTBu4/2r0ajV9jsiJKIOGjQaLY4F/CpvloktrPsxLEoJcHG7iPKuAQPw1SwZli1AxR6qiARMF7aEJeBIOAKOhOmCMdgCZq5bbXBoPBUK51cgJRq11HBgCdw/iDXhQsOWkEi4UFiOUXV/DB/fhlcvwhuW1OrzGhxvWoK/9aAzDpVBAsMWBkwwwHRxRssU8xdAQIWh4OauGQR40ETcxdLAzBfQbuDZcXz5ObTqmGdASAxYWBEEY9gxlpoHcDbpNWXAsIUf74NfmRQ5zxX06e145wqsCKJZxwIjZVjvjuCbu6AwtBm49hQEMm7yogD+cw0YQ28CDeFJET2xET92cP1+XDAfJzZhoQ/9JjSGsIpxBzd24uZunNOK1yzGWa05zHc9/3AxZOLj2+AIGAqW+HHlCrx2ce4v9c5Iavr1neeh8clz+hX89ABObMI5bbnfIqTiqpX4xDZIN9UzPaNWSoRVXDAfJ4ThV2BLJFyYLhSGgIolfpzROvkuErBE9mKzwnJ3YyHRk8TuCJ4exbZx7I9i2EJSQEq4EquCePXiQvekcr67B786iP89Ma9bnqgjOOec84v5oW63qUsEASQmtiEVtoPVPEYqY4wZvGYWsIQziwXYFIjYsAQUhpCad8p/JIm7GLMxbGHIxJCFIRPDNsZsRGxEHMRdmC5MAUvAlrAnxhFvVHJzNaPCUouUDOAMtsR1J2NLCwD8v+fxP7vx09MKCfBNB/F/B3ByE0wBlSGsgjEIid4knhvH4UTqVJWzN4qbuxBxcMUyrJ5YlVzgw1UrYQl8bw9UFQxQGVQGVyKk4aNrs6cFPzuAJ0bwmkVTHhwwcc8AHh7CsIVLFuK1i3HDAfzmEN63Gm9YMiWgMSfnzcMZLehJYp6BUEYPuakTX90FnWevASssR0dSGHZF8MO9uGwRLpyf2heQdPH5ZzHmIKCgN4lrtuMTJ6BVT2n2B1bnuJgdY/jmbvgUBFX8+iC+thN7o/BN6IfKEFLhCvyjF//sx4lNeO1iXDR/5s+Y9jdwIKwBwKEEPrUdXQn8+3E5JPyUZgB4cAgcU4zp9FTjZ1uwLM/85tWLoDHccAAH47AldA4hEXfx4TW4YlmOSzoQQ08SPz2AoIJTmnFCAyTQl8RTo9g6iqTAQh/etBStOiyBpIu4i0ETfSb2RbE7il0RHIxj1AJjMDh0DoUhqEAAtsBnduCnB7AiiHYDGse6BrxmcZW/0XcPIOFiGa3DHRMwxjjnKsdr+f7rrbVxqSbFpAu6tCjoSTujZhawkNnZq0v1QM43SosLvbMfe6NYEsAZLWjOtRo0amP7GJ4axbPj6ElgzEZSQGVo0LA8gNcuwYumhlyO2ehNIqxigS/3cmAljFjoSuBgAgeiOJRAdwJDFkbt1PTfnQhOZwBj4ABjYBN/smnRnjkvT8gpv+sc3QnsiuDpUfz6EBo13NGHi+bn/WjnzUODhoSLn+zHgdhka3IGncOvTK5QVhJ9esMBXLsXoxYSLoYsfO+k1OMRB9fvw68Owj+1/yZdfGwtTm6afKQ3ie/vwe8OY2UwpRlxF9vHcGsv7hlAdyJ1bU+OQue4sx9xF1/Zib924wPH4bypLd6TxK4Idoxhbwz9JhTg1Yvxyo7sa14cKHbrniOxKogPrcG5U+3C6/fjseGUN0Ln+HsPdozjLctw8YLUGnDWzOx3h/DDfYg48HHYArf2grMcUcecIahCAk+O4PFh/F8Yb1yCSzsQLji/7Erg27vBJ6ZrBofGcO1eLPDl9XDc0Qdbwsiogc4Ag+NwAr/sxCdOyPteL+/ASxfgYAJRB1/biW1j4Cw1CzEF+pN4Poqto9gxju4kIjZWBHFeO1pCqZkEB5YGoDL0JvDQEB4dxinNOKUZVz6GPhNJFxEHIxZUhg4/TmjAC+dhRRDzDDSok8slSRcjFrqT2DGGJ0dway8Uhk+eUFq/jToYNBF1oHIs8eeewV+6ED89gFt68OQIJHBmK17egSZt0iWecNHhp8jtehJgzvgCxXyLdugn0eURVynGfmV9ycnDhBCu6zq2bZpmMpm4oSd4b6yxFv5SKXH5MjRqiNhwJZICjkhN/6WExuFTEFTQoKFFR6uO+T60GQgoMAWu2Y4Hh/C7M7HAl/ct/tmHE5smgx4/twO/PAjG4Eqc3Yobtkx264iDh4ZwZx+eHEFPEraEwqCyyRFHSJgCGsOVK/CB46bMGx4Zxn88jcV+rAzhuBBWh7AsWPLMIG1zH4jhuXHsGMfzURyOY8RGwoWQYIDCwFnKZuW1+UZ65TsMjqSAxsAZYg4+uw5vXJp7fPn9Yfy5G3ujORYOLYENjfjOiXh0GH/qRlDBlzdOcaJmzQM64+hNYsTCyhDWZixS3tiJLz6LoAoOKBzXn5KK4nlwCF/diV0RBJUpdyPp4pRm/N9pqeuxBX51CDfsR3cSPgUtOjY1whY4GMehBJIufMpkawqZWjFNn4oBr1+CF8/HgImdEewYw74YRqxUD+GALdGo4XdnIqxi1MaAiQMxPDGC+weRdItqJgn4OI4L48J2nNmGDj80hmdG8Z4n4Mgpd9USsAUW+XFKM05qwooQ2nQkXDwwhFt6sDsCQyl5RmsJRByc2IhrT8HCPF+lJ0bwme3ojCMwtTiaI2Fw3Lgl96Ly55/FLzuhK6keK2QqumrMxifX4qqViNh4YhQRGwAaNMwz0OGf1B4AvzyIb+xKfQe976NnDZsCDNA4VAYXWOLH/2zGmjxh3u5EoNxXnsPPOgGgRcfF83HxAmxonGHake4Gdw+gVS8UqT5h4uD5KLaPYWcEQxZ8Cpb4sbYBx4VSNnROvrcH//s8HAGfAgmsDOJNS3FiE/7chVEbVywrFLZGzCqe3XPgcP+g54hWVXWbaP1HrO2a5aMtAUPXdUVVFUXJuQ2pkAD/utd/e7S5FperMYw7Uyy56WNT2qTTGAIqWnUcF0Kzjt8egiPx3lX44HF5z/+Se6FwfHUjNjbi+n34xm6EFTAGKWEKfOcknN+OraO4pRf3DOBgPGUCqjzvfFNIxBy8YB6uWZcKNH0+gv99HncPgAOOhARUhrCGdgPLA1jbgI2NWBueYefD4QSeHMGjw9g+hq4Eok7qPCoHr5nWFp4YsYmZR8TBGa342Wk5Jjff24PnIinHXc6Bb00YlsCuCKSEC9x8Vu44o5u78NtD6DdTa6VXLMPrMhx9r3oQOyMIKql78sJ5WBWEAH56ADEnh/s04uDK5fivtSlr9RPb8OAQ/BOrid5EyjuVlquh3amaJ5HSUSfjVcq0omMLfUi4iDpIuKkCZH6lhIaTgOXCkWjUsNCf8kNEnNxq6q3rS6R8DI5EzIHOy1yqjDpY7MdHjseL5+d4O1Pgp/vx4/1ICvh5jnQAcRebG/GTUxFQs83fb+yCkPjo8ejwgzPEHdzSi7/34IpluHolNI5v7MKP9yOgIGJD4wiqaNKxKogTGtCkYesY/tmXmgR7DSczvDuZK1kJF806/vfElOs7H9vH8KZHcGYrPnb85CpGtehO4M/deGQYlsDyAE5swuYmLA8Wu+/50WH8aB8eH0HCRdLFGa348gaYLlZOmPUJF9vGsCSQd5JEHC0OxhFWU/7UnfsPdg8MewKsKIqqacM8tCCoNvj0cgTYsqxkMvGXfv3msSpHCFgCq0MwOJ4dL3YfsASETG3AZ0BgYp3mxfNx6UKsDaNBg8ZhCUQddCfw0BB+egAJF/MMnN6Cu/qnbBrxEiAs8WPrGOITER/Fj1krgnhlB3ZH8eAgIlNlIPM6XQmNo03HpkZcvAAvnj/lC3kwjnsHcO8gdoxh2AImJvV81vibhIRPwZc34EXtqUcSLh4bxq8O4b4BADNY+baABDSOcRtnteHak3J44W7tRU8CGxqxyI8mLccBNxzA9/ZMerDjE/6AfArnSjRo+MBqXDQfX9+FXx6sws6TGf3ntpiyClDJDU9P4xQ281V5i0rldRhXIu7iRe245gR05Frm3zqGr+7EEyMIKIUuJubg/HZ8Yi0WB2ALbBvDLw7ijj4AUBj+ZzPOb5/80vUkUjNXz62ddGEoeGYUX3ouVRvNnggX92ZjxXwyBiQEmlR8fgMuaM+tjrf14TeH8HwEn1mHty+vcmeIOfjlQagMp7VgTbj8oK0nR3BnP+4ZwFuW4Y0Tjv0DMfz2MP7RizNa8L7VhTaSEUeFr+0EY/jY8QCwu/Nw3/AY55xNGMGarhuGoWmlCLCU0nEc13FM0zTN5J0D/Ocj7dW1sVyJb23G7w7h/sGKkvtIpKJwG7XUEk7SRdRBxIEl4FdShqkpcnyZvThhnZczfnlBxd4aW+GB0vuwXt2ndQ346PHY3IT7BvG3bjw+gmELCkuFfsxChESDhhOb0KJD4xhIYk8MB2JwZLGDoyORcPGiefjihhy7RO4fxK8PTa7pphm2sG0MT4xgZwTjNg4nkHBLEDZXwhJYGkDMQdSZRROaWdWyQRVXr8Tly3If8NtD+PouxN28qwaZJFy0G1gRxLiDfVEkBAIKGBBzcOF8fOekmc/wtkfxxEj5QwFDaj/FKzrw6sVYGUzNgIdN3DeIO/rQGU99bS+cj69tKvNdnhvHDQfQlcB/b5wSJJ9vO3jZeHEqnpAfTuBrOzFg4obT6jgP2jHM6x/CsI1bzoHO8dz+QyPRuKIoaSNYUVVd1zVN1zStBAFOu6BNM/nYML4/uKCKV2wKbGrETafjHY/hseEq9CrP6Ew7qXjG2u2sIuGiQcN8A3uicCV8yizV3ayR2swwSvJ5bnM2StxBs46rVuKty3J8UkfgbY/h8RFsbsI5rVgUACR6TTw3jufG0ZeELVOGYJHvOH2SxFkd3OGjgi2xuRHntiHm4mULs9Nd/bELn9oGXSkhTawjUzdcZ5PZ3W2BhX78+ewZPLE7x/G+pzBkQuWV9tWEC5+CeQbeuAQvak/NHgwFUiLmQkjMM4qN+k7Tl8Sjw7i9Dw8PIerAFHhlB759YpVHBtNFUiDqYMDEA4O4Yhnm+6bMKaknz0IOxfGVnehO4HsnY5FPPrOn03aFJ8DME2BFUVVNVVVN07y/S0hFyRhjjDWpDkM1s0G7EqtDKduoKp3Ki9GY/R3Ur8B0sS8GQ6mbsMbMzH/F43kdLmjHh9bkXW/7wT48MYKwiufGsXU0dUPkRAS1oaDC1S5KcVoAneGZUdw/iA+szt5mlnDx431QWGlJ2lUGVcnRBIfj+PZuvHvllIUAb728L4n9MTw2grv6U8vAlffVoIq4i1UhvGwh2owpY0LxYSzeVqWDcewYxzOjeHYc/UmAwccRVOHYqNa2kISLH+zFEyMYsxFzU3kR4i6iDlaHcFnGfjlS39lJwsX7VuH7e6FzJC3bdlx1wtL1jGDGeEqPGWP56w4VSsTRyF0/c+Oyau4Pv4J/9mHIQn9yzo2SnolwbOOlQfjYCXjz0rwukJ/sxw/3TRgovIQc/URV8CY67QZeP22vswRE9SoW+BT8ohN39WNFEA0qLIkRCyMWxp1UzJqU8CnVHAf8CraN4fUPo0HDujBe3pEj78evDuL5KNqMyTqstkTE22FvYdDEkIWIM2HT88kQMyGxqRFvW45+E0k3tRTlypQP3MvrpzHoPHWHfRwKg6FM5BVhU9a8DI4Hh/D0aCqgwQs41Tl8HP8amCLAZeNIRB0MW2jUUpvIK/92e/OnqIO4C4VhU+Pc/R6tCaMviYU+tOnoG4qBMa4oqqqqispSAsw8AS5c9a+QBRxWRaPixJ2qCbAXuHjPQJnrr8RsxpEIq/ifE3H6tD0bQxb2R7FjHLf24pnR0uKEiaqjMCRcfPApfHnjlH1fAQXvWI4vPVe1wkE+BX0muhIpL5oX2O/tTQrUYFHTG16ExIiF5yP4aw8uX4qPr51iREZdXLs3O82kt3qVdqfpueaFCoMp8JltiLpwRGqlWUgwBkekLGMOqBPZ5byYSi8/jBe17lcQUBFSU4q4Nox9sdS7Z07Tvd1ZXnxo8eZv3EVvEl0JdMZwMI6uJPqTGLYQdRBWcWITTm7GmjA6fGjS4cs1/Hp5xLxQ1jEbYzYGTfSbkz/HbIzbSLowJWwBV+DSDlyzrhw/2bGBLXDZInCGgZGxVPCzoqaXe72dwWwmCzh7DVgI4UVBm2YymUhc19v8lNlAYxZRzBBwzbrJGM5MDsTw0a14YgRBlUzeWQEDxhxsbsRNp2fH7n5uB37fNZlFq34REmM2Pr4WV63MEGAH734iNQssY4qZvnupLHIsu66596ecSEKHiZB1ORGwkv5T4/BN29/lSCwNYFkA28dw1cq8niQASRcH49gdxc5x7IniUAKDJmJO6iK9iY63YV0gtXvN4GjQ0KChUUNQmdLuyYlkYTEntSEqKeDKVLoeNnFCnpHwR0qM2vjAanx4TaXNFHen5JKrI2cSA4bGxnd2dgcCAcPnS4VceYbvhCHrWcOYWmqhkAXMMlihJUiAiWL6op7fJbU8iA8dh/c8Qeo7i9pLY2jRU6OwKXAojoeGcM8AdkeOkWbiDCENP+/EZYsm4/BDKv57A976GCJ2ycurOTdnZw2q3p/ZIy3L2wpZaAyH4tgTRdJF/7TqEzEHz0fxzCieGcPzEfQmU/FlXq4Sz+M9PX6CA6qaeruog3EbnROTgMwLTLsBvJ/6TPGPjCGs4q/deMeKVBIVKYHSY2APxDG/PstEMkAIue9wryexfCL2ik9YwJmim88ILuSCZoytMRI8KgUlRCNm6ou2xO8P42PHI+Gi38SAic1NReUbIo4KGke/iX9/GrZATxJdCYzbUBiMY2h5SGPoM3HfIF69aMp08Nw2/PHwrMjxPl2SFYaAAo3jn31Y34A1YbgSW0fx4BC2j6E7mUrT5mUOKMmTn/axa9XrQr0mnhpJZQvYE8OntqHdhxfNKyp19rCF3x7ChkasrNuE2HsOdcWTps/vZ+ktwBMLwAVEt5AAT5Fuxjo0a5GSOOQGaMAiCuNTcHMXnhhBzMGYjT4T16zDu1aknv1DF6j81WwTp/0x7IqkbDuvYMOxBwcenCrAgyYOx6HMbitfZzgUx388g7AKITHmABPZ+mZbM/2xKyXAq0M4oQE/PYCto7i9DwwIa2jR0ayhUUNATVVdizoYtPB8BI8MY3Mjrl4FADvGsTpYqICpV+q7N4nDiVTmWi/lg2e7B1QElAkHu4pGDWEtNY/x/ByuhOUiKbCpsWpxf4f7+ju7+3w+n2f7esu9aeO1sOGbW4AZY17dBsYYg5ddmm3Wxw8lSICJmefXnGF/DK6EKbDYP5l+8g+HcXvv3A3WmJ3IPDuIjjF0jmfGMGIhqGJ3BP/ow609GDRn+yK3t0jspRtiQHC2NlNAwd0D+OwOvHEJ2n04qQl/0jDu4P7BKYvfac82vMwNXs4GYEMj/tSFW3rx2DBuOA2bm/LfEIl7B/DVnTBFbvd4esXdq8TlZaZTWSpRHYCEiyUB3HJu6vghE2NO+cb3we7enfsPqRN7fDNt38JRV9nDZmYQFqZlo0zE410x9+ujq23Q8h0xM5bAfB9eNA+XL0sVnvtTFz7/LEA7GomjhABWBuBIHEog5pSWfZYoZq6QcBFUENYwbhcKoc/K/M8AR6YyriddvHc1/nOmeK7HhvHlnVPKr2W3tUxlNvUraNCgsNQjESeVzP/z6/HYMB4awkNDeNWiVOr4zCuccZRyHHfn/s6DPX2qqhmG4fP7fX6/z+fTdUPXdT6x97fIu5fbBZ2Oouacz1PNNer4DqeJuhpR+HvoSrxrBa5ckfKSDVu4fh9+cTAVJEIQRwUO7I4COGbd7EcXb1OZK1PpddNVxm0J052S9Y9NGzG8DCpColnDaQUTpkQcdCWQcHFGCw7HcyulLeBXcMF8nDcP6xpSu78YEHexL4Z/9OBfA3jTwxi1U2bx3QN46cJU6Kgj0ZVASEFr/ogwx3W7+wb2HuqKJ01VUVVVVTVNVVVVVRVFVRQFpdi+uQUY6dKGEzktGefn6IMkwMSM30OF4c5+7I1hiR8ax2292BdDgHb9EkcbnUzeWs9y2BQfqS1xXMDdELKfHGFdtgbG8w0anouixUBSoD8hfLCFEJ4GRYS2P862j2PbKPbEMGCmzGWD51bfFQH3k8c5m5v5sFD/0s0eG8Y311sGkz6GlhBOPQ7rAvji84Y3CWNAVwJXPY5TmrHC717Q5izwwc+RSALAqMMeHtPPa7GlYzHhxpPm8Nh439BwPJH0ai0oqqppmqZpngZnJr0qSYOzXdDeVmDhupZlWZaZSCSSiUQikbh2fMV+EaZ+Rszgn5GwRGr7IPn6CGJuIhz7P/3bGkXcFBgRWhJ6Wmbi0A6ypm2YH58Ix/bMZUdgoU/MV0xD2i54HHqfo43YzBLgDNrERuS87yjRpruLVTsq+UFTH7HRiuR/GU+qE9Gfjit6jPbrEmszByVdOqvdvgu0rjZuTZ4KeExZ9tv4kvUBcxVGVmNonj3Egclqg6qm67puGD6fTzcMz/mcmYKjfAs49fqUEaykkkorygV6z4+TJMDETP1pDsT1EARRyBqGfJ2yM2hHHEBlbB43AdOz7pJQd6FtCAEnw2BOxwMOWLxP+oFUjnKvHEuR3gvOMGgpvabijUKLVfNiuVu6tjMhhwcR/lV8uTYxOjUhuRF9m1lvk5qEhCOmqOYBWwup2JM0nscCRy6Yh/jl+u7FSsLLdaVpXplBXdN1r+KCUuLSb14BTmswz1Bgrihr9Pg6e+RZt5m6F0EQBJGPS9jzJ/BRYMp22CFpPCo6tsr2BNQC0/dKUk54+fabkDyR9Z6M3hC3GVMACLAH3Y675HKpMACLMX4Sek5gQwYcxph3nZnaKaV8BT+wUQwnFVVh0s/cABdt3FWVVHWjVK1fXddUTdM0VVVZKXt/ZxBgZCwDe0WVPBl+qd61N9FgggwcgiAIIhsN4hK250Tez9jknhwL/H5n4YNiYbJKdX1UCCfXrpxGmGej80TWpzJwzhlLOYQPivCd7grGsJ4NnsJ6l2Nkws5UMoOOvQAyCSmlVKRcr4yldJ1zzrgXdOUt/Hq2r5d40lPfGaselSzASBVz8CRYdRSlXTUvUA/f4iyjfkYQRMGB2D0eg90ID4NSCFSZMEwTqnVUDSEfnOMw1CLj97Hl6TyJHYhczPct41HOFYUrniwdFKE/m4u7qpfKaRWGz5f7HmRLd6B9eq+LMd9B3tLA3RZuBbj0ZHaRtF/FOheyWAeLCCE81Us5ehlnGbmrPPM3hRCeFk4U902pr6pp+oTnWVVVXq7zOa8Ap03piQVnr8iSqjjO2Vr/brdxj2yirwFBEPmwoQRhvVM++Vu2oRM0XFQHFWIj+s6Rnb9imwaP0szGgHMquk6WPY1I2lDuxzIGtgjjJ7HeTaxf42wiakhRFOURu+3PiQWWzLZWOWQLSy5EZCEiLTIehgVgFL49aNmO+flyTjQiuR79Z8uDBnO3yMM7WZsL7pndPjghWC0s6eOiSXHbFUtXJsvx6lKerY8JIYTQhBBexYy0wHk/vUek9AxgKYQQQng66C3CpmOeNU2bUEU1vV8IpTufU2qbFQWdOQvwMnKYpulVRjKTyWQyOWyzH5jrxmHQ94EgiJwEYZ+PfZvRG4d2H5YNw38QjfasXL3S4Opwdbg+OEFYLvh+zKJIFwUiCLsN8eVyZA0G21gCwL1YfggNAkyA2VAA6YJ7aiTAXDAALrhM/ckl4FYjk9IJGHghDrQh7umNANuBeW2IL0Q0I2ZI1TRNKPrfEgvujTdliC6aubVYiS9j40vZWIuIMuF6QpP5FgMIdCMcg25KxYTCIQ04IVhtiM9HzFu1FWDdCDuSqRBe83nLtOkLSNumXlgyAG9rjyerUsrJrbapOOOUVE+YvsJ13bQAe/uOsqTX26DLy136nUGAU1cshOs4tm2bZtJMJhOJhJlMWpa1x/bfaJ/gUG4sgiiXZiTOlIcakRxGYDdrnVWDfiVithDRtRhYx4bCSFXzGYfxe3lCF450UTUO6Y3OGlw/HB8cP2w/7KC0A7D9qX+OAceAq8NVJvarHELjs2zeITSNwpcsEDEEkf6nTZxBg2ATdYYEuA2ehGpCTU44jTW4DTAbYQZg+WFrELp0lVQBQzBAh+NZdQacAOwg7CCzDLjTh/hJ6ZJSgnl/uOAuGAMccAEmAQccYA64C+aA2+AOFAuKBcUGN6GaTE1CNaEkoSahJqF5zzop+9INwVqC8U3oXcHGputNOmhX4Up6oXQAwTtiLQCCimjkbgu32nmiWSa4azmOI1zXFa4ndVM+SMbnynow833TKZMnEydnXIC3LpvenuuVTvQ01XVTkp8V4ZTOIpm2fV3XlRMCzCY9wRMBzxm7fitR30ICnN4Q7DhOujywmUyapmlb1pN20x/cNTSMEkSphGGeIrtPYd1+OOkHn5ctt7PVIxMbMGaJmmoQCoQyoSjO/2fv2nokSarzF5GXqu6d6R71XHZGu7AssGDJKySEVvKzX+xf4Ac/85949TOvtmxZfrJktE8IkEAIBAizXlgGbU/fquuSmXH8EJlRcc+s6u7Z3uF8GrWye+oSmRV1vjjf+U4kZAu5RkGuV7VC9x7OvoXP38fZiVjZ2xH8Lx39sPubxY1vwCNABUgPpoQqoOohc63RzTS/UjtHM0er/83Q1Wj1A2T8ToLJuKkj+yXqBVVLVHayoem2sn6WUAVIgBC+IBFBNJBLVJeYXaN6gsUjrKZsTWNv6B8Geo+lPLrKn1f+ER2kJmOtWNRCPcC6FiSsu9t6hiNdSS2Kwoi0OgHtxVSl2rZt27bTPzURKkXk3BTRnJF9ajpbhbtFoy3TWgRc6AFUdW32x9CjtTlVP8XNfQsjI5sMWLOfyZWFkOVgRtZ3G7yJ7DyVgL1NOVar1Vr/W6/btvm4efrv6hscTxmMiQnZC1x+iJd/i5dvidb+9uqgcEH1v+Fbn+D49ftr3sLmCOsTLE+wPKbVQ6wfYKOpS7OdIeAGxQrlFepTHLwUDz7Dg3dx/j386QRLO0Abae6P6vBKlQ2BCBtCSzp5EWEzhQTV6DS1V+g0pemDYR2gNNXpP0pQJvp5kdHL2FIHKRqwD1IxN/X3KOdFxxN9TGjT7V8W5A114luHf4wmoF6Cu9VshRSu41cfG+lXk5/Wfo2cq5VUfWB04CjjmCqszc16Y4oUAWtCNT6poT23LIpS06RNqFv9WUg5FIDNdLUMWH0NGJYdytxy8OaJ7zgBw6oEd0MSrMvAm/V6s9m0bfNx++w/1Dd0oeIYq2vUGcWGwbhvEKCH2DzB4hjrUxx8jsMFKrrVu18fY/U2rt6js/fF2TMshAsv9BDRGc3WKK6pusDsErNTcXCB2TnmC1Tr3b9cJdTX8Oo5rv4HTvPCHO0TXD/H5XO6eoarR1gdinZidhiykf5p3Q1VCjuiKaWoL6pFJceJieB0ig3JNfkrIpklWR/I6GjzVJp6buZ2deHYbO6JzhnnXbJsarNadHkRDth2CxfWnX+2Ix+4WXt1e3fSUHntus7OfSmgXjNPBqb0z8umf7NPlH3+/QOKoizLuq5NsVYP1ai59uOltGfrdj3Rf+Lug/XcRiL7vyHK0dkvpSQpy7JUXaVqpZTSywNS6u+KP9fU/St98ATX36cfX6L+Ax79Ujz9PR6t/5qYeIb2GRZv4+qElrquoyCuUZ2L+U/wghcl9wQF1AHaI6wfYfkY10/pWlPvbJCCVygvMD/FwSscnIqDc8wuMFuiWqOc7nio0J1g+QKX79DFc1w9Fssanei/ucU2lMANJegX3SfUEG2Iru041ZFYoLrE7AzzM8xfiYNLzK5QL1FtUHSD0UaCSqgK6gjrJ1i8Sxfv4ewxrq9R/Uh8dYbubVx9BedfofNnYqGtpxCGk+TE7DBKwMLdO89OKbTkKIXsVGfi4N7sOzGXdZjVLR+Goq5PwFsdsudim7rsNNQmoSijREkRibcOj33ucRM1mEG6b7fTsaf3RgZs7QlhnE1e2+uQTxZlWUrZN9cqpcQgXBtRxJ45dirppZ7mBM0APA42DzYDkFIOBeDKyMVeXusxus2pzgSwL3IgRdxyDpDJgG0hWmsIm03vidZurLZp2q79dXf8n+r9fxK/OKFr/axzzH5DJ78STz/BUfNGb9zxDIvv0affxOmxWIf/e4X6B/jojVmLHKKp0J1jfp8pVpflZmgP0B6ieYDNQ1ofYX2E1UNs3sJmLrp8dmXHKQWxpmKJconqGtUC9RLlUlTaWaNtLLrIJ4AXuPwqnb/A5SOxEq58t42kQyYRhhKdHyhLK0O21EdAQ3KDokHRQhKEhKqg5qKdwTnHFvIPdPQEPemGVBQ5hsikdFF5sDBFNdd9qiU0kwApUjuqFDnCyyS43nn5vBv80Zyg7lSxmSCaF6bePXK5YqKu99b+c4O70kk3UQuRWSdF/pgg4HDAPflZ9mIZI2DTUGsnnV3X6g9fz+vtmXoZrXXl+2tuJcr2VTDXxDvr3qtclDoPNnKxc/rmpAIVKlNcnyJa3CEB29dFC9FNs9Fl4F6IbppOdZ918zOafSBOvY/zFQ4+oaNPxdFfcHiB+QplM9jlTeFHu//1cv7LRUgf4dO/x+8qqPDbqK/Af6n3P8a7X1559hDNMVaPsdRC5TMsFMS/iO/uxMHaPiPdf3qHdHNAQAUlofROdBJUDhSia36EvuUAQI1OgmrqjPtUW0ZtV04V+G5SMRpBLdYrL+3kc4lyWx/CxNb3YfcwDBpt79LUUi0pZYTQKYXJ1BhSg/Qqi4aQQj6OrsjNscMQQ4w2Z+cZcGwb6k6JbyrTjf+MkW50nWE/2DlBtUXIcOEYMhc8Q8DhE0NrMQL1NSNBjyS76ZTXnl1RAjb5pVlhRcvA3ppymMxO88/2kVZZ1zkja+Y7CavoE1Y7Y4ZlhDZz0KvUYsxQPVpqufWsdwcJ2l5foCiqqiIiVSvn6rTtO7J5QWugtK8LET2m9Qm9/A79GUADuaZiNYhmGGwXuiVggfq/xdd+ihd3SirHWL2Di2e0eIBNCbVE+X/iONxRZQrewcU/it+G+5mZT25Bxc/U8/uvyuqUcd73PGyOsTqi9SOsjrA+wvpAlwatGfgP+M0P8aGuL9bo5tBNHW3f2kHNDN0crWbEaujTkIN/VYIESIL0qxZQ1CdbOy8QsiFbZkhxGwThc4xxf0TjUb5UFuc2q9pk2h4MS/WvZkplXacGDvbzYMugklIOR32zJrs1Q7Pjpl1jyycH9ukbi4q9ba2dBun/68rSEDDyBDyhmhtqyKM5burYS7J1LSCuhWZlZG+cUY3XI+C8EL01XgXVR29y+rPRkUlotOIbLu/87LPfFbH/nMPVwPZY/7TYQSlpdHJvSTpxSSECRGe+eenwlaMMOoVW75R6pxLw9jQGo7l32lJK217RFydIeaXvGVBT+xBt9E0e0ua7+MwmYJMtFVDeZeggFISW3SaW5b6OV9+hz94T53O09pM+wh8/xMuf4Pmf8PAaVRf0G+gO/TlazTcCaCCvUb0rLh3XiRDCXZ39unmsgLfF9SE2h9S8hc2cmvmQqJnuBc2ChfWlMT18+tcWokUhQApC+2PNAYANSvPETkhvExmdKerjGp0AaV+rnSzqLo5S9KRo1wVtJjP1m2/T6T/j5wV1D7A5RFNTWwiayIsxSLnjLM9/nZLxGk5c9oKI3VnoBwLzd+SyTy+btKtWds+DVvBKc+cyCFP91f2RWq/rM8XAkxJRHWPcED01jzK37GsfBzQcyQkCArbLv7qpw2RCSqmyKNuy3Wb2YxlwvCyaSXkzrAxhLkj+KbkaMNISNESoh0fKGYkacCoJi+oooVSeyrAn/porA7s1YM+1pKunGfeZvmaFsRCFNJmYYM7XLTT6JfSq6Ar4tTHonUvQXjFYdV3TY9NsNk3TGInfm7smiGgyRsIxf0azv9DBGeYzajcQB9TM0FbUU9SQP9lrOqH7ERvIDco1iivUC9QLUV9gdoX6ajBjF6CnWHyTTj8Qn+s2ifhcAYhojfIS9YqKDlI3PGjq1Tmc/SQ9qzpZziQK2Tdl285AfdJnXUFtM6MNdUnnfW4G3/UHv3uekVql5o0kE/l4vwWpZ7oJfTdeumNne0ivwWFN4zAzyOuKDvVafQ6Gd+05432zukGHJiv98g6QLv559hYvKcnEU+FSb1gMtjOqMPmw63/hF2HbhUl7OrDCTxnp1HPKz7wCGV3oRNuQ8kaqzFotPwD/xNNqRC5W7NJulClt2BMb6dJpVCbxxYOoUDGm2Ecve/4x9593dyZguIastu/rapumUa5itv3WdZ1Zy5vYgZgz3sZOjQoTy3L27tZImB7zLQdhtUPvuhI6AzE4P/VKpa9+Df7PPVjnjsg4kzJ6QqUnfBl5w3MJjkTMmM1kVyYetYwm84bA0rLlG0u3gNWBYHTIaDacJODBjmTnvlsOlvaxDO0nJk00V9gZQGxInlhnXDPh2sIpJw2DNNYwxIS+Ka4iX1d0N6anUM4dq15P+dB3OEhUWPNrX09gGPnmTgn3Lg/lF8E7VfQnhogpPcER53bCr4cxA2N0nkyhyelZypuBcteoLaWkoii1u7KVhSxsdjGOErP117ZtKUauPveSSjUqRMz9E1aCoREGXlSymkAyk8aJbug9gVVVaeO71hadzcy6rm3b7dt30pgLImlcTEj3OvZuhZid00FylR0t1TgrsMFKE+0HTVlLMlFv+uYGkVfLlHjdE0Gs3hnub+AxnJd3ImaGcpgvyC79v0jfTgJAKFUQFUWhErKzt+5JZcBREo3ypblhXEjYkaAvBPL178Sb6o03hJRFwqm7zzSYNpGm09sUhXaPoU5X2m/4sIkvNRoxppBf/r0mNmd/sWXXLysB6y+VXuCbb3DXdUXgFlHbHLiz8+OQ5Gy5z/aeIGY7jHxJQHntotfH3LBoM4pnuIi/b7DbgGZcfX+MwuzNLcx23qptW2HF+n4hkqD26QrETWSAjNocIa3QmGMrip3T0BmXlfYl4+mBNcIWab9rytKSKgE6cjRGVGhbYgm5zfxErJ5nM5aumMFl+lRxemINOLUq9S9C1pSbn2/hE+0dBKdsZ7F3XL5hUWMi0+ynXd03Lhkdzy0O+K+NR19fBmx2EgGwbTYI3HRq2KzDkHE0cNgPNiWwlO8/I3SEYdFOSkwRTlqdajajkNt1kBc2pXd7yGIrQZvXFGIb3dqiMFvApBoZd2DWadvLjSpmSYpyOdhrLSAiY9P1+gRSflTvHUdD/E58HPmMkEzoUwlimOFFk91MY2607ygqgI9ugZQ0OU8rRWOsMQZui0vm8XvvrRit2N1ow/ovOpoznTDuBQF7HExEsAjYSyLsrNepASPC1mEDxqiw43VoINEg4Vg03RZyuwUzJGDEfJW2qdVseKZh3C5d19mxuChLcncWnVjaGa/T7JJYxO0nIgsENeBgRYVUE0hi279ozWwnXQsTKn/J8aSHF0opmQZKZE2YGW4bzeRCuqLRAQT1xYxjJdI6siPB7MFGTGAMxu0QMNIdb16YkAnHJgWpht4sO8OCcU6KSXMI/Ca2EcYIxbYArsjvux/JgJ2uzlIfOg1qNvsWpXJve7lf1BvdQj38+yhvbVPGdLtkaBKeuFLJn+weiuJ0aRpZVsYED06K/PJXfuLuSLvSVarv4oZ2FSZFBuNLScAe++bjhc+LMfXYblcwVbftCwYeJbv0m9rGxdkg3jLCRF1Fdse9/9ZBEDclPXs/I+fmXIO/ZtAJykxCv7MEPSHxzWzgMm5+9gTkqGctsP9MZzjcpffk1j0gKfL7Qrhtj9NhMBhvJgGPRgFPTMtvBU4Jl1a+EJXZFQix1syw7QRB+1NmzzmHn2JNk/bdMxRQWlum3W7o3NvSMiVljJ54dNOciUuKWzR8flEpHbMdg8G4dwS8T7iPdSLpWrIc3aYuTcOImbCiRhi4hTE9AJn2lKbSx2iFz3BwURR3xL77MfH0JsvU/5pT2+mkmLoYDAYjHh6nb8RxF8jU2EYD9+idtlJ7zu22oUyWS3btJZ/y+q9hGyymRgaDwXjDM+DplJPf4G3X/C9TmU6R0P3pgWNeZDAYDCbg10rDt/hE5jAGg8Fg3HNIvgQMBoPBYDABMxgMBoPBBMxgMBgMBoMJmMFgMBgMJmAGg8FgMBhMwAwGg8FgMAEzGAwGg8FgAmYwGAwGgwmYwWAwGAwGEzCDwWAwGEzADAaDwWAwATMYDAaDwWACZjAYDAaDCZjBYDAYDAYTMIPBYDAYTMAMBoPBYDCYgBkMBoPBYAJmMBgMBoPBBMxgMBgMBhMwg8FgMBhMwAwGg8FgMJiAGQwGg8FgAmYwGAwGg8EEzGAwGAwGEzCDwWAwGAwmYAaDwWAw7in+fwBWHMyPWsGAngAAAABJRU5ErkJggg==")};
__resources__["/resources/score_bg2.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/resources/star.png"] = {meta: {mimetype: "image/png"}, data: __imageResource("data:image/png;base64,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")};
__resources__["/Sock.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var Tool = require('Tool').Tool;

var Sock = Tool.extend({

    direction: 'up',
    jumpTo: null,

    createBox: function() {
        var frogBox = this.get('picture').get('boundingBox');
        var x = frogBox.origin.x;
        var y = frogBox.origin.y;
        var w = frogBox.size.width;
        var h = frogBox.size.height;
        if (this.direction == 'up') {
            x = x + w/5;
            y = y + h*3/4;
            w = w/2;
            h = h/10;
        }
        return new geo.Rect(x, y, w, h);
    },

    getJumpPosition: function(scale) {
        var frogBox = this.get('picture').get('boundingBox');
        var x = frogBox.origin.x / scale;
        var y = frogBox.origin.y / scale;
        var w = frogBox.size.width / scale;
        x = x + w*3/5;
        return new box2d.b2Vec2(x, y);
    },

    getJumpVelocity: function(vel) {
        if (this.direction == 'down') {
            var y = vel.y;
            var x = 0;
            if (y > 0) {
                y *= -1;
            };
            return new box2d.b2Vec2(x, y);
        };
    },

    revolve: function() {
        this.get('picture').set('rotation', 180);
        this.set('direction', 'down');
    },

    init: function() {
        Sock.superclass.init.call(this);
        this.filepath = '/resources/pipe.png';
    }
});

exports.Sock = Sock;

}};
__resources__["/Star.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry');

var Tool = require('Tool').Tool;

var Star = Tool.extend({

    eaten: false,

    init: function() {
        Star.superclass.init.call(this);
        this.filepath = '/resources/star.png';
    }
});

exports.Star = Star;

}};
__resources__["/Tool.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry');

var Tool = cocos.nodes.Node.extend({
    picture: null,
    filepath: null,

    createPicture: function(point) {
        var sprite = cocos.nodes.Sprite.create({
            file: this.filepath}
        );
        sprite.set('position',point);
        sprite.set('scale', 1);
        this.set('picture', sprite);
    },

    createObj: function(x, y, program){
        this.createPicture(new geo.Point(x * program.m_phy_scale, y * program.m_phy_scale));
        program.addChild(this.get('picture'));
    },

    init: function() {
        Tool.superclass.init.call(this);
    }
});

exports.Tool = Tool;

}};
__resources__["/VPoint.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var VPoint = BObject.extend({
	x:0,
	y:0,
	oldx:0, 
	oldy:0,
    init: function() {
    	VPoint.superclass.init.call(this);
    },
    setPos: function (argX, argY) {
    	this.oldx = argX;
    	this.x = argX;
    	this.oldy = argY;
    	this.y = argY;
    },
    update: function() {
    	var tempx = this.x;
    	var tempy = this.y;
    	this.x += this.x - this.oldx;
    	this.y += this.y - this.oldy;
    	this.oldx = tempx;
    	this.oldy = tempy;
    }, 
    applyGravity: function(dt) {
    	this.y -= 10.0*dt; //gravity magic number
    }
});

exports.VPoint = VPoint;

}};
__resources__["/VRope.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var VPoint = require('VPoint').VPoint;
var VStick = require('VStick').VStick;

var VRope = BObject.extend({
	numPoints:0,
	vPoints: [],
	vSticks: [],
	ropeSprites : [],
	spriteSheet: null,
	antiSagHack: 0,
	bodyA: null,
	bodyB: null,
	PTM_RATIO: 30,
    init: function() {
    	VRope.superclass.init.call(this);
    },
    initWithBodys: function (body1, body2, sheet) {
    	this.bodyA = body1;
    	this.bodyB = body2;
    	var pa = new box2d.b2Vec2(this.bodyA.GetPosition().x * this.PTM_RATIO, 
    			this.bodyA.GetPosition().y * this.PTM_RATIO);
    	var pb = new box2d.b2Vec2(this.bodyB.GetPosition().x * this.PTM_RATIO, 
    			this.bodyB.GetPosition().y * this.PTM_RATIO);
    	this.spriteSheet = sheet;
    	this.createRope(pa, pb);
    },
    reset: function() {
    	var pa = new box2d.b2Vec2(this.bodyA.GetPosition().x * this.PTM_RATIO, 
    			this.bodyA.GetPosition().y * this.PTM_RATIO);
    	var pb = new box2d.b2Vec2(this.bodyB.GetPosition().x * this.PTM_RATIO, 
    			this.bodyB.GetPosition().y * this.PTM_RATIO);
    	this.resetWithPoints(pa, pb);
    },
    update: function(dt) {
    	var pa = new box2d.b2Vec2(this.bodyA.GetPosition().x * this.PTM_RATIO, 
    			this.bodyA.GetPosition().y * this.PTM_RATIO);
    	var pb = new box2d.b2Vec2(this.bodyB.GetPosition().x * this.PTM_RATIO, 
    			this.bodyB.GetPosition().y * this.PTM_RATIO);
    	this.updateWithPoints(pa, pb, dt);
    },
    createRope: function(pa, pb) {
    	this.vPoints = [];
    	this.vSticks = [];
    	this.ropeSprites = [];
    	var dx = pa.x - pb.x;
    	var dy = pa.y - pb.y;
    	var distance = Math.sqrt(dx * dx + dy * dy);
    	var segmentFactor = 12;
    	this.numPoints = Math.floor(distance/segmentFactor);
    	var diffVector = new box2d.b2Vec2(pb.x - pa.x,
    			pb.y - pa.y);
    	var multiplier = distance/(this.numPoints-1);
    	this.antiSagHack = 0.1;
    	var i=0;
    	for( i=0;i<this.numPoints;i++) {
    		var tmpnor = diffVector.Copy();
    		tmpnor.Normalize();
    		tmpnor.Multiply(multiplier*i*(1-this.antiSagHack));
    		var tmpVector = pa.Copy();
    		tmpVector.Add(tmpnor);
    		var tmpPoint = VPoint.create();
    		tmpPoint.setPos(tmpVector.x, tmpVector.y);
    		this.vPoints.push(tmpPoint);
    	}
    	for( i=0;i<this.numPoints-1;i++) {
    		var tmpStick = VStick.create();
    		tmpStick.initWithArgPoints(this.vPoints[i], this.vPoints[i+1]);
    		this.vSticks.push(tmpStick);
    	}
    	
    	if(this.spriteSheet != null) {
    		for(i=0;i<this.numPoints-1;i++) {
    			var point1 = this.vSticks[i].pointA;
    			var point2 = this.vSticks[i].pointB;
    			var stickVector = new box2d.b2Vec2(point1.x- point2.x, point1.y-point2.y);
    			var stickAngle = Math.atan2(stickVector.y, stickVector.x);
    			//TODO 
    			var tmpSprite = cocos.nodes.Sprite.create({
    				spritesheet: this.spriteSheet,
    				rect: new geo.Rect(0,0,multiplier, this.spriteSheet.get('textureAtlas').texture.get('size').height),
    				});
//    			ccTexParams params = {GL_LINEAR,GL_LINEAR,GL_REPEAT,GL_REPEAT};
//    			[tmpSprite.texture setTexParameters:&params];
    			tmpSprite.set("position", geo.ccp((point1.x+point2.x)/2, (point1.y+point2.y)/2));
    			tmpSprite.set('rotation',-1 * 57.29577951 *(stickAngle));
    			
    			this.spriteSheet.addChild({child:tmpSprite});
    			this.ropeSprites.push(tmpSprite);
    		}
    	}
    },
    resetWithPoints: function(pa, pb) {
    	var dx = pa.x - pb.x;
    	var dy = pa.y - pb.y;
    	var distance = Math.sqrt(dx * dx + dy * dy);
    	var diffVector = pb.Copy().Subtract(pa);
    	var multiplier = distance / (this.numPoints - 1);
    	var i=0;
    	for( i=0;i<this.numPoints;i++) {
    		var tmpnor = diffVector.Copy();
    		tmpnor.Normalize();
    		tmpnor.Multiply(multiplier*i*(1-this.antiSagHack));
    		var tmpVector = pa.Copy().Add(tmpnor);
    		var tmpPoint = this.vPoints[i];
    		tmpPoint.setPos(tmpVector.x, tmpVector.y);
    	}
    },
    removeSprites: function() {
    	var i;
    	for( i=0;i<this.numPoints-1;i++) {
    		var tmpSprite = this.ropeSprites[i];
    		this.spriteSheet.removeChild({child:tmpSprite, cleanup:true});
    	}
    	this.ropeSprites = [];
    },
    updateWithPoints: function(pa, pb, dt) {
    	//manually set position for first and last point of rope
    	this.vPoints[0].setPos(pa.x, pa.y);
    	this.vPoints[this.numPoints-1].setPos(pb.x, pb.y);
    	
    	//update points, apply gravity
    	var i;
    	for(i=1;i<this.numPoints-1;i++) {
    		this.vPoints[i].applyGravity(dt);
    		this.vPoints[i].update();
    	}
    	
    	//contract sticks
    	var iterations = 4;
    	var j;
    	for( j=0;j<iterations;j++) {
    		for( i=0;i<this.numPoints-1;i++) {
    			this.vSticks[i].contract();
    		}
    	}
    },
    updateSprites: function() {
    	if(this.spriteSheet!=null) {
    		var i;
    		for(i=0;i<this.numPoints-1;i++) {
    			var point1 = this.vSticks[i].pointA;
    			var point2 = this.vSticks[i].pointB;
    			var point1_ = new box2d.b2Vec2(point1.x, point1.y);
    			var point2_ = new box2d.b2Vec2(point2.x, point2.y);
    			var dp = point1_.Copy();
    			dp.Subtract(point2_);
    			var stickAngle = Math.atan2(dp.y, dp.x);
    			var tmpSprite = this.ropeSprites[i];
    			tmpSprite.set("position", geo.ccp((point1_.x+point2_.x)/2, (point1_.y+point2_.y)/2) );
    			tmpSprite.set("rotation",-57.29577951*(stickAngle));
    		}
    	}
    }
});

exports.VRope = VRope;

}};
__resources__["/VStick.js"] = {meta: {mimetype: "application/javascript"}, data: function(exports, require, module, __filename, __dirname) {
// Import the cocos2d module
var cocos = require('cocos2d'),
// Import the geometry module
    geo = require('geometry'),
// Import box2d Physics Engine
    box2d = require('box2d');

var VPoint = require('VPoint').VPoint;

var VStick = BObject.extend({
	pointA:null,
	pointB:null,
	hypotenuse: 0,
    init: function() {
    	VStick.superclass.init.call(this);
    },
    initWithArgPoints: function (argA, argB) {
    	this.pointA = argA;
    	this.pointB = argB;
    	var dx = this.pointA.x - this.pointB.x;
    	var dy = this.pointA.y - this.pointB.y;
    	this.hypotenuse = Math.sqrt(dx * dx + dy * dy);
    },
    contract: function() {
    	var dx = this.pointA.x - this.pointB.x;
    	var dy = this.pointA.y - this.pointB.y;
    	var h = Math.sqrt(dx * dx + dy * dy);
    	var diff = this.hypotenuse - h;
    	var offx = (diff * dx / h) * 0.5;
    	var offy = (diff * dy / h) * 0.5;
    	this.pointA.x-=offx;
    	this.pointA.y-=offy;
    	this.pointB.x+=offx;
    	this.pointB.y+=offy;
    }
});

exports.VStick = VStick;

}};/*globals module exports resource require window Module __main_module_name__ __resources__*/
/*jslint undef: true, strict: true, white: true, newcap: true, browser: true, indent: 4 */
"use strict";

function resource(path) {
    return __resources__[path].data;
}

(function () {
    var process = {};
    var modulePaths = ['/__builtin__', '/__builtin__/libs', '/libs', '/'];

    var path; // Will be loaded further down

    function resolveModulePath(request, parent) {
        // If not a relative path then search the modulePaths for it
        var start = request.substring(0, 2);
        if (start !== "./" && start !== "..") {
            return modulePaths;
        }

        var parentIsIndex = path.basename(parent.filename).match(/^index\.js$/),
            parentPath    = parentIsIndex ? parent.id : path.dirname(parent.id);

        // Relative path so searching inside parent's directory
        return [path.dirname(parent.filename)];
    }

    function findModulePath(id, dirs) {
        if (id.charAt(0) === '/') {
            dirs = [''];
        }
        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            var p = path.join(dir, id);

            // Check for index first
            if (path.exists(path.join(p, 'index.js'))) {
                return path.join(p, 'index.js');
            } else if (path.exists(p + '.js')) {
                return p + '.js';
            }
        }

        return false;
    }

    function loadModule(request, parent) {
        parent = parent || process.mainModule;

        var paths    = resolveModulePath(request, parent),
            filename = findModulePath(request, paths);

        if (filename === false) {
            throw "Unable to find module: " + request;
        }


        if (parent) {
            var cachedModule = parent.moduleCache[filename];
            if (cachedModule) {
                return cachedModule;
            }
        }

        //console.log('Loading module: ', filename);

        var module = new Module(filename, parent);

        // Assign main module to process
        if (request == __main_module_name__ && !process.mainModule) {
            process.mainModule = module;
        }

        // Run all the code in the module
        module._initialize(filename);

        return module;
    }

    function Module(id, parent) {
        this.id = id;
        this.parent = parent;
        this.children = [];
        this.exports = {};

        if (parent) {
            this.moduleCache = parent.moduleCache;
            parent.children.push(this);
        } else {
            this.moduleCache = {};
        }
        this.moduleCache[this.id] = this;

        this.filename = null;
        this.dirname = null;
    }

    Module.prototype._initialize = function (filename) {
        var module = this;
        function require(request) {
            return loadModule(request, module).exports;
        }

        this.filename = filename;

        // Work around incase this IS the path module
        if (path) {
            this.dirname = path.dirname(filename);
        } else {
            this.dirname = '';
        }

        require.paths = modulePaths;
        require.main = process.mainModule;

        __resources__[this.filename].data.apply(this.exports, [this.exports, require, this, this.filename, this.dirname]);

        return this;
    };

    // Manually load the path module because we need it to load other modules
    path = (new Module('path'))._initialize('/__builtin__/path.js').exports;

    var util = loadModule('util').exports;
    util.ready(function () {
        // Populate globals
        var globals = loadModule('global').exports;
        for (var x in globals) {
            if (globals.hasOwnProperty(x)) {
                window[x] = globals[x];
            }
        }

        process.mainModule = loadModule(__main_module_name__);
        if (process.mainModule.exports.main) {
            process.mainModule.exports.main();
        }

        // Add a global require. Useful in the debug console.
        window.require = function require(request, parent) {
            return loadModule(request, parent).exports;
        };
        window.require.main = process.mainModule;
        window.require.paths = modulePaths;

    });
})();

// vim:ft=javascript

})();
